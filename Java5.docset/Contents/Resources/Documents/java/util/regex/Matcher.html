<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<meta name="collection" content="api">
<!-- Generated by javadoc (build 1.5.0-rc) on Wed Aug 11 07:23:33 PDT 2004 -->
<TITLE>
Matcher (Java 2 Platform SE 5.0)
</TITLE>

<META NAME="keywords" CONTENT="java.util.regex.Matcher class">
<META NAME="keywords" CONTENT="pattern()">
<META NAME="keywords" CONTENT="toMatchResult()">
<META NAME="keywords" CONTENT="usePattern()">
<META NAME="keywords" CONTENT="reset()">
<META NAME="keywords" CONTENT="start()">
<META NAME="keywords" CONTENT="end()">
<META NAME="keywords" CONTENT="group()">
<META NAME="keywords" CONTENT="groupCount()">
<META NAME="keywords" CONTENT="matches()">
<META NAME="keywords" CONTENT="find()">
<META NAME="keywords" CONTENT="lookingAt()">
<META NAME="keywords" CONTENT="quoteReplacement()">
<META NAME="keywords" CONTENT="appendReplacement()">
<META NAME="keywords" CONTENT="appendTail()">
<META NAME="keywords" CONTENT="replaceAll()">
<META NAME="keywords" CONTENT="replaceFirst()">
<META NAME="keywords" CONTENT="region()">
<META NAME="keywords" CONTENT="regionStart()">
<META NAME="keywords" CONTENT="regionEnd()">
<META NAME="keywords" CONTENT="hasTransparentBounds()">
<META NAME="keywords" CONTENT="useTransparentBounds()">
<META NAME="keywords" CONTENT="hasAnchoringBounds()">
<META NAME="keywords" CONTENT="useAnchoringBounds()">
<META NAME="keywords" CONTENT="toString()">
<META NAME="keywords" CONTENT="hitEnd()">
<META NAME="keywords" CONTENT="requireEnd()">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Matcher (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Matcher.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/regex/Matcher.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Matcher.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.regex</FONT>
<BR>
Class Matcher</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>java.util.regex.Matcher</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex">MatchResult</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public final class <B>Matcher</B><DT>extends <A HREF="../../../java/lang/Object.html" title="class in java.lang">Object</A><DT>implements <A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex">MatchResult</A></DL>
</PRE>

<P>
An engine that performs match operations on a <A HREF="../../../java/lang/CharSequence.html" title="interface in java.lang"><CODE></code>character sequence<code></CODE></A> by interpreting a <A HREF="../../../java/util/regex/Pattern.html" title="class in java.util.regex"><CODE>Pattern</CODE></A>.

 <p> A matcher is created from a pattern by invoking the pattern's <A HREF="../../../java/util/regex/Pattern.html#matcher(java.lang.CharSequence)"><CODE>matcher</CODE></A> method.  Once created, a matcher can be used to
 perform three different kinds of match operations:

 <ul>

   <li><p> The <A HREF="../../../java/util/regex/Matcher.html#matches()"><CODE>matches</CODE></A> method attempts to match the entire
   input sequence against the pattern.  </p></li>

   <li><p> The <A HREF="../../../java/util/regex/Matcher.html#lookingAt()"><CODE>lookingAt</CODE></A> method attempts to match the
   input sequence, starting at the beginning, against the pattern.  </p></li>

   <li><p> The <A HREF="../../../java/util/regex/Matcher.html#find()"><CODE>find</CODE></A> method scans the input sequence looking for
   the next subsequence that matches the pattern.  </p></li>

 </ul>

 <p> Each of these methods returns a boolean indicating success or failure.
 More information about a successful match can be obtained by querying the
 state of the matcher.

 <p> A matcher finds matches in a subset of its input called the 
 <i>region</i>. By default, the region contains all of the matcher's input. 
 The region can be modified via the<A HREF="../../../java/util/regex/Matcher.html#region(int, int)"><CODE>region</CODE></A> method and queried
 via the <A HREF="../../../java/util/regex/Matcher.html#regionStart()"><CODE>regionStart</CODE></A> and <A HREF="../../../java/util/regex/Matcher.html#regionEnd()"><CODE>regionEnd</CODE></A> 
 methods. The way that the region boundaries interact with some pattern
 constructs can be changed. See <A HREF="../../../java/util/regex/Matcher.html#useAnchoringBounds(boolean)"><CODE>useAnchoringBounds</CODE></A> and <A HREF="../../../java/util/regex/Matcher.html#useTransparentBounds(boolean)"><CODE>useTransparentBounds</CODE></A>
 for more details.

 <p> This class also defines methods for replacing matched subsequences with
 new strings whose contents can, if desired, be computed from the match
 result.  The <A HREF="../../../java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer, java.lang.String)"><CODE>appendReplacement</CODE></A> and <A HREF="../../../java/util/regex/Matcher.html#appendTail(java.lang.StringBuffer)"><CODE>appendTail</CODE></A> methods can be used in tandem in order to collect
 the result into an existing string buffer, or the more convenient <A HREF="../../../java/util/regex/Matcher.html#replaceAll(java.lang.String)"><CODE>replaceAll</CODE></A> method can be used to create a string in which every
 matching subsequence in the input sequence is replaced.

 <p> The explicit state of a matcher includes the start and end indices of
 the most recent successful match.  It also includes the start and end
 indices of the input subsequence captured by each <a
 href="Pattern.html#cg">capturing group</a> in the pattern as well as a total
 count of such subsequences.  As a convenience, methods are also provided for
 returning these captured subsequences in string form.

 <p> The explicit state of a matcher is initially undefined; attempting to
 query any part of it before a successful match will cause an <A HREF="../../../java/lang/IllegalStateException.html" title="class in java.lang"><CODE>IllegalStateException</CODE></A> to be thrown.  The explicit state of a matcher is
 recomputed by every match operation.

 <p> The implicit state of a matcher includes the input character sequence as
 well as the <i>append position</i>, which is initially zero and is updated
 by the <A HREF="../../../java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer, java.lang.String)"><CODE>appendReplacement</CODE></A> method.

 <p> A matcher may be reset explicitly by invoking its <A HREF="../../../java/util/regex/Matcher.html#reset()"><CODE>reset()</CODE></A>
 method or, if a new input sequence is desired, its <A HREF="../../../java/util/regex/Matcher.html#reset(java.lang.CharSequence)"><CODE>reset(CharSequence)</CODE></A> method.  Resetting a
 matcher discards its explicit state information and sets the append position
 to zero.

 <p> Instances of this class are not safe for use by multiple concurrent
 threads. </p>
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.4</DD>
</DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer, java.lang.String)">appendReplacement</A></B>(<A HREF="../../../java/lang/StringBuffer.html" title="class in java.lang">StringBuffer</A>&nbsp;sb,
                  <A HREF="../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;replacement)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implements a non-terminal append-and-replace step.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/StringBuffer.html" title="class in java.lang">StringBuffer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#appendTail(java.lang.StringBuffer)">appendTail</A></B>(<A HREF="../../../java/lang/StringBuffer.html" title="class in java.lang">StringBuffer</A>&nbsp;sb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implements a terminal append-and-replace step.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#end()">end</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the offset after the last character matched.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#end(int)">end</A></B>(int&nbsp;group)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the offset after the last character of the subsequence
 captured by the given group during the previous match operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#find()">find</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to find the next subsequence of the input sequence that matches
 the pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#find(int)">find</A></B>(int&nbsp;start)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets this matcher and then attempts to find the next subsequence of
 the input sequence that matches the pattern, starting at the specified
 index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="class in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#group()">group</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the input subsequence matched by the previous match.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="class in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#group(int)">group</A></B>(int&nbsp;group)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the input subsequence captured by the given group during the
 previous match operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#groupCount()">groupCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of capturing groups in this matcher's pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#hasAnchoringBounds()">hasAnchoringBounds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries the anchoring of region bounds for this matcher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#hasTransparentBounds()">hasTransparentBounds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries the transparency of region bounds for this matcher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#hitEnd()">hitEnd</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the end of input was hit by the search engine in
 the last match operation performed by this matcher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#lookingAt()">lookingAt</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to match the input sequence, starting at the beginning of the 
 region, against the pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#matches()">matches</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to match the entire region against the pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/regex/Pattern.html" title="class in java.util.regex">Pattern</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#pattern()">pattern</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the pattern that is interpreted by this matcher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/String.html" title="class in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#quoteReplacement(java.lang.String)">quoteReplacement</A></B>(<A HREF="../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a literal replacement <code>String</code> for the specified
 <code>String</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#region(int, int)">region</A></B>(int&nbsp;start,
       int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the limits of this matcher's region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#regionEnd()">regionEnd</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reports the end index (exclusive) of this matcher's region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#regionStart()">regionStart</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reports the start index of this matcher's region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="class in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#replaceAll(java.lang.String)">replaceAll</A></B>(<A HREF="../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;replacement)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces every subsequence of the input sequence that matches the
 pattern with the given replacement string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="class in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#replaceFirst(java.lang.String)">replaceFirst</A></B>(<A HREF="../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;replacement)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces the first subsequence of the input sequence that matches the
 pattern with the given replacement string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#requireEnd()">requireEnd</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if more input could change a positive match into a 
 negative one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#reset()">reset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets this matcher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#reset(java.lang.CharSequence)">reset</A></B>(<A HREF="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</A>&nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets this matcher with a new input sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#start()">start</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the start index of the previous match.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#start(int)">start</A></B>(int&nbsp;group)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the start index of the subsequence captured by the given group
 during the previous match operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex">MatchResult</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#toMatchResult()">toMatchResult</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the match state of this matcher as a <A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex"><CODE>MatchResult</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="class in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the string representation of this matcher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#useAnchoringBounds(boolean)">useAnchoringBounds</A></B>(boolean&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the anchoring of region bounds for this matcher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#usePattern(java.util.regex.Pattern)">usePattern</A></B>(<A HREF="../../../java/util/regex/Pattern.html" title="class in java.util.regex">Pattern</A>&nbsp;newPattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the <tt>Pattern</tt> that this <tt>Matcher</tt> uses to
 find matches with.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Matcher.html#useTransparentBounds(boolean)">useTransparentBounds</A></B>(boolean&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the transparency of region bounds for this matcher.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="../../../java/lang/Object.html" title="class in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="pattern()"><!-- --></A><H3>
pattern</H3>
<PRE>
public <A HREF="../../../java/util/regex/Pattern.html" title="class in java.util.regex">Pattern</A> <B>pattern</B>()</PRE>
<DL>
<DD>Returns the pattern that is interpreted by this matcher.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The pattern for which this matcher was created</DL>
</DD>
</DL>
<HR>

<A NAME="toMatchResult()"><!-- --></A><H3>
toMatchResult</H3>
<PRE>
public <A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex">MatchResult</A> <B>toMatchResult</B>()</PRE>
<DL>
<DD>Returns the match state of this matcher as a <A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex"><CODE>MatchResult</CODE></A>.
 The result is unaffected by subsequent operations performed upon this
 matcher.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>MatchResult</code> with the state of this matcher</DL>
</DD>
</DL>
<HR>

<A NAME="usePattern(java.util.regex.Pattern)"><!-- --></A><H3>
usePattern</H3>
<PRE>
public <A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A> <B>usePattern</B>(<A HREF="../../../java/util/regex/Pattern.html" title="class in java.util.regex">Pattern</A>&nbsp;newPattern)</PRE>
<DL>
<DD>Changes the <tt>Pattern</tt> that this <tt>Matcher</tt> uses to
 find matches with.

 <p> This method causes this matcher to lose information
 about the groups of the last match that occurred. The
 matcher's position in the input is maintained and its
 last append position is unaffected.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>newPattern</CODE> - The new pattern used by this matcher
<DT><B>Returns:</B><DD>This matcher
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If newPattern is <tt>null</tt><DT><B>Since:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A><H3>
reset</H3>
<PRE>
public <A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A> <B>reset</B>()</PRE>
<DL>
<DD>Resets this matcher.

 <p> Resetting a matcher discards all of its explicit state information
 and sets its append position to zero. The matcher's region is set to the
 default region, which is its entire character sequence. The anchoring
 and transparency of this matcher's region boundaries are unaffected.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>This matcher</DL>
</DD>
</DL>
<HR>

<A NAME="reset(java.lang.CharSequence)"><!-- --></A><H3>
reset</H3>
<PRE>
public <A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A> <B>reset</B>(<A HREF="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</A>&nbsp;input)</PRE>
<DL>
<DD>Resets this matcher with a new input sequence.

 <p> Resetting a matcher discards all of its explicit state information
 and sets its append position to zero.  The matcher's region is set to
 the default region, which is its entire character sequence.  The 
 anchoring and transparency of this matcher's region boundaries are 
 unaffected.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - The new input character sequence
<DT><B>Returns:</B><DD>This matcher</DL>
</DD>
</DL>
<HR>

<A NAME="start()"><!-- --></A><H3>
start</H3>
<PRE>
public int <B>start</B>()</PRE>
<DL>
<DD>Returns the start index of the previous match.  </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../java/util/regex/MatchResult.html#start()">start</A></CODE> in interface <CODE><A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex">MatchResult</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The index of the first character matched
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</A></CODE> - If no match has yet been attempted,
          or if the previous match operation failed</DL>
</DD>
</DL>
<HR>

<A NAME="start(int)"><!-- --></A><H3>
start</H3>
<PRE>
public int <B>start</B>(int&nbsp;group)</PRE>
<DL>
<DD>Returns the start index of the subsequence captured by the given group
 during the previous match operation.

 <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left
 to right, starting at one.  Group zero denotes the entire pattern, so
 the expression <i>m.</i><tt>start(0)</tt> is equivalent to
 <i>m.</i><tt>start()</tt>.  </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../java/util/regex/MatchResult.html#start(int)">start</A></CODE> in interface <CODE><A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex">MatchResult</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>group</CODE> - The index of a capturing group in this matcher's pattern
<DT><B>Returns:</B><DD>The index of the first character captured by the group,
          or <tt>-1</tt> if the match was successful but the group
          itself did not match anything
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</A></CODE> - If no match has yet been attempted,
          or if the previous match operation failed
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If there is no capturing group in the pattern
          with the given index</DL>
</DD>
</DL>
<HR>

<A NAME="end()"><!-- --></A><H3>
end</H3>
<PRE>
public int <B>end</B>()</PRE>
<DL>
<DD>Returns the offset after the last character matched.  </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../java/util/regex/MatchResult.html#end()">end</A></CODE> in interface <CODE><A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex">MatchResult</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The offset after the last character matched
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</A></CODE> - If no match has yet been attempted,
          or if the previous match operation failed</DL>
</DD>
</DL>
<HR>

<A NAME="end(int)"><!-- --></A><H3>
end</H3>
<PRE>
public int <B>end</B>(int&nbsp;group)</PRE>
<DL>
<DD>Returns the offset after the last character of the subsequence
 captured by the given group during the previous match operation.

 <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left
 to right, starting at one.  Group zero denotes the entire pattern, so
 the expression <i>m.</i><tt>end(0)</tt> is equivalent to
 <i>m.</i><tt>end()</tt>.  </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../java/util/regex/MatchResult.html#end(int)">end</A></CODE> in interface <CODE><A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex">MatchResult</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>group</CODE> - The index of a capturing group in this matcher's pattern
<DT><B>Returns:</B><DD>The offset after the last character captured by the group,
          or <tt>-1</tt> if the match was successful
          but the group itself did not match anything
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</A></CODE> - If no match has yet been attempted,
          or if the previous match operation failed
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If there is no capturing group in the pattern
          with the given index</DL>
</DD>
</DL>
<HR>

<A NAME="group()"><!-- --></A><H3>
group</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="class in java.lang">String</A> <B>group</B>()</PRE>
<DL>
<DD>Returns the input subsequence matched by the previous match.

 <p> For a matcher <i>m</i> with input sequence <i>s</i>, 
 the expressions <i>m.</i><tt>group()</tt> and
 <i>s.</i><tt>substring(</tt><i>m.</i><tt>start(),</tt>&nbsp;<i>m.</i><tt>end())</tt>
 are equivalent.  </p>

 <p> Note that some patterns, for example <tt>a*</tt>, match the empty
 string.  This method will return the empty string when the pattern
 successfully matches the empty string in the input.  </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../java/util/regex/MatchResult.html#group()">group</A></CODE> in interface <CODE><A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex">MatchResult</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The (possibly empty) subsequence matched by the previous match,
         in string form
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</A></CODE> - If no match has yet been attempted,
          or if the previous match operation failed</DL>
</DD>
</DL>
<HR>

<A NAME="group(int)"><!-- --></A><H3>
group</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="class in java.lang">String</A> <B>group</B>(int&nbsp;group)</PRE>
<DL>
<DD>Returns the input subsequence captured by the given group during the
 previous match operation.

 <p> For a matcher <i>m</i>, input sequence <i>s</i>, and group index
 <i>g</i>, the expressions <i>m.</i><tt>group(</tt><i>g</i><tt>)</tt> and
 <i>s.</i><tt>substring(</tt><i>m.</i><tt>start(</tt><i>g</i><tt>),</tt>&nbsp;<i>m.</i><tt>end(</tt><i>g</i><tt>))</tt>
 are equivalent.  </p>
 
 <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left
 to right, starting at one.  Group zero denotes the entire pattern, so
 the expression <tt>m.group(0)</tt> is equivalent to <tt>m.group()</tt>.
 </p>

 <p> If the match was successful but the group specified failed to match
 any part of the input sequence, then <tt>null</tt> is returned. Note
 that some groups, for example <tt>(a*)</tt>, match the empty string.
 This method will return the empty string when such a group successfully
 matches the empty string in the input.  </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../java/util/regex/MatchResult.html#group(int)">group</A></CODE> in interface <CODE><A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex">MatchResult</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>group</CODE> - The index of a capturing group in this matcher's pattern
<DT><B>Returns:</B><DD>The (possibly empty) subsequence captured by the group
          during the previous match, or <tt>null</tt> if the group
          failed to match part of the input
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</A></CODE> - If no match has yet been attempted,
          or if the previous match operation failed
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If there is no capturing group in the pattern
          with the given index</DL>
</DD>
</DL>
<HR>

<A NAME="groupCount()"><!-- --></A><H3>
groupCount</H3>
<PRE>
public int <B>groupCount</B>()</PRE>
<DL>
<DD>Returns the number of capturing groups in this matcher's pattern.

 <p> Group zero denotes the entire pattern by convention. It is not
 included in this count.

 <p> Any non-negative integer smaller than or equal to the value
 returned by this method is guaranteed to be a valid group index for
 this matcher.  </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../java/util/regex/MatchResult.html#groupCount()">groupCount</A></CODE> in interface <CODE><A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex">MatchResult</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The number of capturing groups in this matcher's pattern</DL>
</DD>
</DL>
<HR>

<A NAME="matches()"><!-- --></A><H3>
matches</H3>
<PRE>
public boolean <B>matches</B>()</PRE>
<DL>
<DD>Attempts to match the entire region against the pattern.

 <p> If the match succeeds then more information can be obtained via the
 <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><tt>true</tt> if, and only if, the entire region sequence
          matches this matcher's pattern</DL>
</DD>
</DL>
<HR>

<A NAME="find()"><!-- --></A><H3>
find</H3>
<PRE>
public boolean <B>find</B>()</PRE>
<DL>
<DD>Attempts to find the next subsequence of the input sequence that matches
 the pattern.

 <p> This method starts at the beginning of this matcher's region, or, if
 a previous invocation of the method was successful and the matcher has 
 not since been reset, at the first character not matched by the previous
 match.

 <p> If the match succeeds then more information can be obtained via the
 <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><tt>true</tt> if, and only if, a subsequence of the input
          sequence matches this matcher's pattern</DL>
</DD>
</DL>
<HR>

<A NAME="find(int)"><!-- --></A><H3>
find</H3>
<PRE>
public boolean <B>find</B>(int&nbsp;start)</PRE>
<DL>
<DD>Resets this matcher and then attempts to find the next subsequence of
 the input sequence that matches the pattern, starting at the specified
 index.

 <p> If the match succeeds then more information can be obtained via the
 <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods, and subsequent
 invocations of the <A HREF="../../../java/util/regex/Matcher.html#find()"><CODE>find()</CODE></A> method will start at the first
 character not matched by this match.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><tt>true</tt> if, and only if, a subsequence of the input
          sequence starting at the given index matches this matcher's
          pattern
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If start is less than zero or if start is greater than the
          length of the input sequence.</DL>
</DD>
</DL>
<HR>

<A NAME="lookingAt()"><!-- --></A><H3>
lookingAt</H3>
<PRE>
public boolean <B>lookingAt</B>()</PRE>
<DL>
<DD>Attempts to match the input sequence, starting at the beginning of the 
 region, against the pattern.

 <p> Like the <A HREF="../../../java/util/regex/Matcher.html#matches()"><CODE>matches</CODE></A> method, this method always starts
 at the beginning of the region; unlike that method, it does not
 require that the entire region be matched.

 <p> If the match succeeds then more information can be obtained via the
 <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><tt>true</tt> if, and only if, a prefix of the input
          sequence matches this matcher's pattern</DL>
</DD>
</DL>
<HR>

<A NAME="quoteReplacement(java.lang.String)"><!-- --></A><H3>
quoteReplacement</H3>
<PRE>
public static <A HREF="../../../java/lang/String.html" title="class in java.lang">String</A> <B>quoteReplacement</B>(<A HREF="../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;s)</PRE>
<DL>
<DD>Returns a literal replacement <code>String</code> for the specified
 <code>String</code>.

 This method produces a <code>String</code> that will work
 use as a literal replacement <code>s</code> in the
 <code>appendReplacement</code> method of the <A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex"><CODE>Matcher</CODE></A> class.
 The <code>String</code> produced will match the sequence of characters
 in <code>s</code> treated as a literal sequence. Slashes ('\') and
 dollar signs ('$') will be given no special meaning.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The string to be literalized
<DT><B>Returns:</B><DD>A literal string replacement<DT><B>Since:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="appendReplacement(java.lang.StringBuffer, java.lang.String)"><!-- --></A><H3>
appendReplacement</H3>
<PRE>
public <A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A> <B>appendReplacement</B>(<A HREF="../../../java/lang/StringBuffer.html" title="class in java.lang">StringBuffer</A>&nbsp;sb,
                                 <A HREF="../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;replacement)</PRE>
<DL>
<DD>Implements a non-terminal append-and-replace step.

 <p> This method performs the following actions: </p>

 <ol>

   <li><p> It reads characters from the input sequence, starting at the
   append position, and appends them to the given string buffer.  It
   stops after reading the last character preceding the previous match,
   that is, the character at index <A HREF="../../../java/util/regex/Matcher.html#start()"><CODE>start()</CODE></A>&nbsp;<tt>-</tt>&nbsp;<tt>1</tt>.  </p></li>

   <li><p> It appends the given replacement string to the string buffer.
   </p></li>

   <li><p> It sets the append position of this matcher to the index of
   the last character matched, plus one, that is, to <A HREF="../../../java/util/regex/Matcher.html#end()"><CODE>end()</CODE></A>.
   </p></li>

 </ol>

 <p> The replacement string may contain references to subsequences
 captured during the previous match: Each occurrence of
 <tt>$</tt><i>g</i><tt></tt> will be replaced by the result of
 evaluating <A HREF="../../../java/util/regex/Matcher.html#group(int)"><CODE>group</CODE></A><tt>(</tt><i>g</i><tt>)</tt>. 
 The first number after the <tt>$</tt> is always treated as part of
 the group reference. Subsequent numbers are incorporated into g if
 they would form a legal group reference. Only the numerals '0'
 through '9' are considered as potential components of the group
 reference. If the second group matched the string <tt>"foo"</tt>, for
 example, then passing the replacement string <tt>"$2bar"</tt> would
 cause <tt>"foobar"</tt> to be appended to the string buffer. A dollar
 sign (<tt>$</tt>) may be included as a literal in the replacement
 string by preceding it with a backslash (<tt>\$</tt>).

 <p> Note that backslashes (<tt>\</tt>) and dollar signs (<tt>$</tt>) in
 the replacement string may cause the results to be different than if it
 were being treated as a literal replacement string. Dollar signs may be
 treated as references to captured subsequences as described above, and
 backslashes are used to escape literal characters in the replacement
 string.

 <p> This method is intended to be used in a loop together with the
 <A HREF="../../../java/util/regex/Matcher.html#appendTail(java.lang.StringBuffer)"><CODE>appendTail</CODE></A> and <A HREF="../../../java/util/regex/Matcher.html#find()"><CODE>find</CODE></A> methods.  The
 following code, for example, writes <tt>one dog two dogs in the
 yard</tt> to the standard-output stream: </p>

 <blockquote><pre>
 Pattern p = Pattern.compile("cat");
 Matcher m = p.matcher("one cat two cats in the yard");
 StringBuffer sb = new StringBuffer();
 while (m.find()) {
     m.appendReplacement(sb, "dog");
 }
 m.appendTail(sb);
 System.out.println(sb.toString());</pre></blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sb</CODE> - The target string buffer<DD><CODE>replacement</CODE> - The replacement string
<DT><B>Returns:</B><DD>This matcher
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</A></CODE> - If no match has yet been attempted,
          or if the previous match operation failed
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If the replacement string refers to a capturing group
          that does not exist in the pattern</DL>
</DD>
</DL>
<HR>

<A NAME="appendTail(java.lang.StringBuffer)"><!-- --></A><H3>
appendTail</H3>
<PRE>
public <A HREF="../../../java/lang/StringBuffer.html" title="class in java.lang">StringBuffer</A> <B>appendTail</B>(<A HREF="../../../java/lang/StringBuffer.html" title="class in java.lang">StringBuffer</A>&nbsp;sb)</PRE>
<DL>
<DD>Implements a terminal append-and-replace step.

 <p> This method reads characters from the input sequence, starting at
 the append position, and appends them to the given string buffer.  It is
 intended to be invoked after one or more invocations of the <A HREF="../../../java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer, java.lang.String)"><CODE>appendReplacement</CODE></A> method in order to copy the
 remainder of the input sequence.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sb</CODE> - The target string buffer
<DT><B>Returns:</B><DD>The target string buffer</DL>
</DD>
</DL>
<HR>

<A NAME="replaceAll(java.lang.String)"><!-- --></A><H3>
replaceAll</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="class in java.lang">String</A> <B>replaceAll</B>(<A HREF="../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;replacement)</PRE>
<DL>
<DD>Replaces every subsequence of the input sequence that matches the
 pattern with the given replacement string.

 <p> This method first resets this matcher.  It then scans the input
 sequence looking for matches of the pattern.  Characters that are not
 part of any match are appended directly to the result string; each match
 is replaced in the result by the replacement string.  The replacement
 string may contain references to captured subsequences as in the <A HREF="../../../java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer, java.lang.String)"><CODE>appendReplacement</CODE></A> method.

 <p> Note that backslashes (<tt>\</tt>) and dollar signs (<tt>$</tt>) in
 the replacement string may cause the results to be different than if it
 were being treated as a literal replacement string. Dollar signs may be
 treated as references to captured subsequences as described above, and
 backslashes are used to escape literal characters in the replacement
 string.

 <p> Given the regular expression <tt>a*b</tt>, the input
 <tt>"aabfooaabfooabfoob"</tt>, and the replacement string
 <tt>"-"</tt>, an invocation of this method on a matcher for that
 expression would yield the string <tt>"-foo-foo-foo-"</tt>.

 <p> Invoking this method changes this matcher's state.  If the matcher
 is to be used in further matching operations then it should first be
 reset.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>replacement</CODE> - The replacement string
<DT><B>Returns:</B><DD>The string constructed by replacing each matching subsequence
          by the replacement string, substituting captured subsequences
          as needed</DL>
</DD>
</DL>
<HR>

<A NAME="replaceFirst(java.lang.String)"><!-- --></A><H3>
replaceFirst</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="class in java.lang">String</A> <B>replaceFirst</B>(<A HREF="../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;replacement)</PRE>
<DL>
<DD>Replaces the first subsequence of the input sequence that matches the
 pattern with the given replacement string.

 <p> This method first resets this matcher.  It then scans the input
 sequence looking for a match of the pattern.  Characters that are not
 part of the match are appended directly to the result string; the match
 is replaced in the result by the replacement string.  The replacement
 string may contain references to captured subsequences as in the <A HREF="../../../java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer, java.lang.String)"><CODE>appendReplacement</CODE></A> method.

 <p> Given the regular expression <tt>dog</tt>, the input
 <tt>"zzzdogzzzdogzzz"</tt>, and the replacement string
 <tt>"cat"</tt>, an invocation of this method on a matcher for that
 expression would yield the string <tt>"zzzcatzzzdogzzz"</tt>.  </p>

 <p> Invoking this method changes this matcher's state.  If the matcher
 is to be used in further matching operations then it should first be
 reset.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>replacement</CODE> - The replacement string
<DT><B>Returns:</B><DD>The string constructed by replacing the first matching
          subsequence by the replacement string, substituting captured
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</A></CODE> - if <code>replacement</code> is null.
          subsequences as needed</DL>
</DD>
</DL>
<HR>

<A NAME="region(int, int)"><!-- --></A><H3>
region</H3>
<PRE>
public <A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A> <B>region</B>(int&nbsp;start,
                      int&nbsp;end)</PRE>
<DL>
<DD>Sets the limits of this matcher's region. The region is the part of the
 input sequence that will be searched to find a match. Invoking this
 method resets the matcher, and then sets the region to start at the
 index specified by the <code>start</code> parameter and end at the
 index specified by the <code>end</code> parameter.

 <p>Depending on the transparency and anchoring being used (see
 <A HREF="../../../java/util/regex/Matcher.html#useTransparentBounds(boolean)"><CODE>useTransparentBounds</CODE></A> and 
 <A HREF="../../../java/util/regex/Matcher.html#useAnchoringBounds(boolean)"><CODE>useAnchoringBounds</CODE></A>), certain constructs such
 as anchors may behave differently at or around the boundaries of the
 region.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>start</CODE> - The index to start searching at (inclusive)<DD><CODE>end</CODE> - The index to end searching at (exclusive)
<DT><B>Returns:</B><DD>this matcher
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If start or end is less than zero, if
          start is greater than the length of the input sequence, if
          end is greater than the length of the input sequence, or if
          start is greater than end.<DT><B>Since:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="regionStart()"><!-- --></A><H3>
regionStart</H3>
<PRE>
public int <B>regionStart</B>()</PRE>
<DL>
<DD>Reports the start index of this matcher's region. The
 searches this matcher conducts are limited to finding matches
 within <A HREF="../../../java/util/regex/Matcher.html#regionStart()"><CODE>regionStart</CODE></A> (inclusive) and
 <A HREF="../../../java/util/regex/Matcher.html#regionEnd()"><CODE>regionEnd</CODE></A> (exclusive).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The starting point of this matcher's region<DT><B>Since:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="regionEnd()"><!-- --></A><H3>
regionEnd</H3>
<PRE>
public int <B>regionEnd</B>()</PRE>
<DL>
<DD>Reports the end index (exclusive) of this matcher's region.
 The searches this matcher conducts are limited to finding matches
 within <A HREF="../../../java/util/regex/Matcher.html#regionStart()"><CODE>regionStart</CODE></A> (inclusive) and
 <A HREF="../../../java/util/regex/Matcher.html#regionEnd()"><CODE>regionEnd</CODE></A> (exclusive).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the ending point of this matcher's region<DT><B>Since:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hasTransparentBounds()"><!-- --></A><H3>
hasTransparentBounds</H3>
<PRE>
public boolean <B>hasTransparentBounds</B>()</PRE>
<DL>
<DD>Queries the transparency of region bounds for this matcher.

 <p> This method returns <tt>true</tt> if this matcher uses
 <i>transparent</i> bounds, <tt>false</tt> if it uses <i>opaque</i>
 bounds.

 <p> See <A HREF="../../../java/util/regex/Matcher.html#useTransparentBounds(boolean)"><CODE>useTransparentBounds</CODE></A> for a 
 description of transparent and opaque bounds.

 <p> By default, a matcher uses opaque region boundaries.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><tt>true</tt> iff this matcher is using transparent bounds,
         <tt>false</tt> otherwise.<DT><B>Since:</B></DT>
  <DD>1.5</DD>
<DT><B>See Also:</B><DD><A HREF="../../../java/util/regex/Matcher.html#useTransparentBounds(boolean)"><CODE>useTransparentBounds(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="useTransparentBounds(boolean)"><!-- --></A><H3>
useTransparentBounds</H3>
<PRE>
public <A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A> <B>useTransparentBounds</B>(boolean&nbsp;b)</PRE>
<DL>
<DD>Sets the transparency of region bounds for this matcher.

 <p> Invoking this method with an argument of <tt>true</tt> will set this
 matcher to use <i>transparent</i> bounds. If the boolean 
 argument is <tt>false</tt>, then <i>opaque</i> bounds will be used.
 
 <p> Using transparent bounds, the boundaries of this 
 matcher's region are transparent to lookahead, lookbehind,
 and boundary matching constructs. Those constructs can see beyond the 
 boundaries of the region to see if a match is appropriate.

 <p> Using opaque bounds, the boundaries of this matcher's 
 region are opaque to lookahead, lookbehind, and boundary matching 
 constructs that may try to see beyond them. Those constructs cannot
 look past the boundaries so they will fail to match anything outside
 of the region.

 <p> By default, a matcher uses opaque bounds.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>b</CODE> - a boolean indicating whether to use opaque or transparent
         regions
<DT><B>Returns:</B><DD>this matcher<DT><B>Since:</B></DT>
  <DD>1.5</DD>
<DT><B>See Also:</B><DD><A HREF="../../../java/util/regex/Matcher.html#hasTransparentBounds()"><CODE>hasTransparentBounds()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hasAnchoringBounds()"><!-- --></A><H3>
hasAnchoringBounds</H3>
<PRE>
public boolean <B>hasAnchoringBounds</B>()</PRE>
<DL>
<DD>Queries the anchoring of region bounds for this matcher.

 <p> This method returns <tt>true</tt> if this matcher uses
 <i>anchoring</i> bounds, <tt>false</tt> otherwise.

 <p> See <A HREF="../../../java/util/regex/Matcher.html#useAnchoringBounds(boolean)"><CODE>useAnchoringBounds</CODE></A> for a 
 description of anchoring bounds.

 <p> By default, a matcher uses anchoring region boundaries.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><tt>true</tt> iff this matcher is using anchoring bounds,
         <tt>false</tt> otherwise.<DT><B>Since:</B></DT>
  <DD>1.5</DD>
<DT><B>See Also:</B><DD><A HREF="../../../java/util/regex/Matcher.html#useAnchoringBounds(boolean)"><CODE>useAnchoringBounds(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="useAnchoringBounds(boolean)"><!-- --></A><H3>
useAnchoringBounds</H3>
<PRE>
public <A HREF="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</A> <B>useAnchoringBounds</B>(boolean&nbsp;b)</PRE>
<DL>
<DD>Sets the anchoring of region bounds for this matcher.

 <p> Invoking this method with an argument of <tt>true</tt> will set this
 matcher to use <i>anchoring</i> bounds. If the boolean 
 argument is <tt>false</tt>, then <i>non-anchoring</i> bounds will be 
 used.
 
 <p> Using anchoring bounds, the boundaries of this 
 matcher's region match anchors such as ^ and $.

 <p> Without anchoring bounds, the boundaries of this 
 matcher's region will not match anchors such as ^ and $.

 <p> By default, a matcher uses anchoring region boundaries.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>b</CODE> - a boolean indicating whether or not to use anchoring bounds.
<DT><B>Returns:</B><DD>this matcher<DT><B>Since:</B></DT>
  <DD>1.5</DD>
<DT><B>See Also:</B><DD><A HREF="../../../java/util/regex/Matcher.html#hasAnchoringBounds()"><CODE>hasAnchoringBounds()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="class in java.lang">String</A> <B>toString</B>()</PRE>
<DL>
<DD><p>Returns the string representation of this matcher. The
 string representation of a <code>Matcher</code> contains information
 that may be useful for debugging. The exact format is unspecified.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../java/lang/Object.html#toString()">toString</A></CODE> in class <CODE><A HREF="../../../java/lang/Object.html" title="class in java.lang">Object</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The string representation of this matcher<DT><B>Since:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hitEnd()"><!-- --></A><H3>
hitEnd</H3>
<PRE>
public boolean <B>hitEnd</B>()</PRE>
<DL>
<DD><p>Returns true if the end of input was hit by the search engine in
 the last match operation performed by this matcher.

 <p>When this method returns true, then it is possible that more input 
 would have changed the result of the last search.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true iff the end of input was hit in the last match; false
          otherwise<DT><B>Since:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="requireEnd()"><!-- --></A><H3>
requireEnd</H3>
<PRE>
public boolean <B>requireEnd</B>()</PRE>
<DL>
<DD><p>Returns true if more input could change a positive match into a 
 negative one.

 <p>If this method returns true, and a match was found, then more
 input could cause the match to be lost. If this method returns false 
 and a match was found, then more input might change the match but the 
 match won't be lost. If a match was not found, then requireEnd has no 
 meaning.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true iff more input could change a positive match into a 
          negative one.<DT><B>Since:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Matcher.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/regex/Matcher.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Matcher.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">Submit a bug or feature</a><br>For further API reference and developer documentation, see <a href="../../../../relnotes/devdocs-vs-specs.html">Java 2 SDK SE Developer Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples. <p>Copyright &#169; 2004, 2010 Oracle and/or its affiliates. All rights reserved. Use is subject to <a href="../../../../relnotes/license.html">license terms</a>. Also see the <a href="http://java.sun.com/docs/redist.html">documentation redistribution policy</a>.</font>
<!-- Start SiteCatalyst code   -->
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code_download.js"></script>
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code.js"></script>
 
<!-- ********** DO NOT ALTER ANYTHING BELOW THIS LINE ! *********** -->
<!--  Below code will send the info to Omniture server -->
<script language="javascript">var s_code=s.t();if(s_code)document.write(s_code)</script>
 
<!-- End SiteCatalyst code -->
</body>
</HTML>
