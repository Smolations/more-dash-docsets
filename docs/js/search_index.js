var search_data = {"index":{"searchIndex":["dash","clean_dir_entries()","copy_docs()","copy_icon()","copy_plist()","create_docset()","create_javadocset()","dir_recurse_list()","find_toc_obj()","get_clean_docs_entries()","get_dash_anchor()","get_docs_repo()","get_file_paths()","get_noko_doc()","get_sql_insert()","get_toc_numbers()","get_toc_obj()","is_valid_entry()","new()","numbering()","save_noko_doc()","setup_sql()","sql_execute()","sql_insert()","traverse()"],"longSearchIndex":["dash","dash#clean_dir_entries()","dash#copy_docs()","dash#copy_icon()","dash#copy_plist()","dash#create_docset()","dash#create_javadocset()","dash#dir_recurse_list()","dash#find_toc_obj()","dash#get_clean_docs_entries()","dash#get_dash_anchor()","dash#get_docs_repo()","dash#get_file_paths()","dash#get_noko_doc()","dash#get_sql_insert()","dash#get_toc_numbers()","dash#get_toc_obj()","dash#is_valid_entry()","dash::new()","dash#numbering()","dash#save_noko_doc()","dash#setup_sql()","dash#sql_execute()","dash#sql_insert()","dash#traverse()"],"info":[["Dash","","Dash.html","",""],["clean_dir_entries","Dash","Dash.html#method-i-clean_dir_entries","(dir_path, more = [])","<p>removes unwanted entries for processing (e.g. ‘.’, ‘..’). You can\nremove additional entries by passing …\n"],["copy_docs","Dash","Dash.html#method-i-copy_docs","(options = {})","<p>copies the files in @docs_root into @docset_documents_path. Can pass +:noop\n=&gt; true+ to skip the actual …\n"],["copy_icon","Dash","Dash.html#method-i-copy_icon","()","<p>copies a user-supplied icon into the appropriate docset location\n"],["copy_plist","Dash","Dash.html#method-i-copy_plist","()","<p>copies the plist template into the appropriate docset location\n"],["create_docset","Dash","Dash.html#method-i-create_docset","()","<p>creates the docset hierarchy, the docset .plist, and initializes the\ndatabase.\n"],["create_javadocset","Dash","Dash.html#method-i-create_javadocset","()","<p>uses kapeli.com’s javadocset binary to generate a docset from\njavadoc-generated documentation. Since …\n"],["dir_recurse_list","Dash","Dash.html#method-i-dir_recurse_list","(abs_path, type = 'all')","<p>type (case-insensitive) is one of: ‘files’, ‘folders’, ‘all’\nreturns <code>array</code>\n"],["find_toc_obj","Dash","Dash.html#method-i-find_toc_obj","(arr, search)","<p>Pass a <code>search</code> string to find a specific toc_object in the\n<code>arr</code> array. returns <code>array</code>\n"],["get_clean_docs_entries","Dash","Dash.html#method-i-get_clean_docs_entries","(more = [])","<p>calls clean_dir_entries for the @docs_root. useful for looping through the\nroot docs directory in generator …\n"],["get_dash_anchor","Dash","Dash.html#method-i-get_dash_anchor","(docReference, name, type, anchor_id = nil)","<p>get Nokogiri doc for new anchor. if <code>anchor_id</code> is not passed,\nit will default to <code>name</code>. if <code>anchor_id</code> is …\n"],["get_docs_repo","Dash","Dash.html#method-i-get_docs_repo","()","<p>this method ensures that a git repo exists for the docs_root and that the\nmaster branch contains the …\n"],["get_file_paths","Dash","Dash.html#method-i-get_file_paths","(folder_path)",""],["get_noko_doc","Dash","Dash.html#method-i-get_noko_doc","(file_path)","<p>file_path is relative to SRC_DOCS_PATH or can be absolute\n"],["get_sql_insert","Dash","Dash.html#method-i-get_sql_insert","(name, type, path)","<p>returns the sqlite query for dash entries for given name, [entry] type,\npath or nil on failure.\n"],["get_toc_numbers","Dash","Dash.html#method-i-get_toc_numbers","(arr, prefix = '', type = 'Guide', insert = true, deco = '.')","<p><code>arr</code> should mirror the TOC structure. Entries should be hashes\nreturned from <code>get_toc_obj</code>. returns <code>array</code> …\n"],["get_toc_obj","Dash","Dash.html#method-i-get_toc_obj","(name, node, subset = [])","<p>{\n\n<pre class=\"ruby\"><span class=\"ruby-string\">'name'</span> =<span class=\"ruby-operator\">&gt;</span> {\n    <span class=\"ruby-string\">'node'</span>   =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-identifier\">node</span>,\n    <span class=\"ruby-string\">'subset'</span> =<span class=\"ruby-operator\">&gt;</span> []\n}\n</pre>\n<p>} return <code>hash</code>\n"],["is_valid_entry","Dash","Dash.html#method-i-is_valid_entry","(entryName)","<p>check if <code>entryName</code> is a Dash-supported Entry Type\n"],["new","Dash","Dash.html#method-c-new","(options = {})","<p>Constructor: Dash.new Takes an <code>options</code> hash with the following\nkeys:\n<p>:docs_root &mdash; Relative from the src-docs …\n"],["numbering","Dash","Dash.html#method-i-numbering","(a, p, t, i, d)",""],["save_noko_doc","Dash","Dash.html#method-i-save_noko_doc","(doc, file_path, xhtml = true)","<p>file_path is relative to SRC_DOCS_PATH or can be absolute\n"],["setup_sql","Dash","Dash.html#method-i-setup_sql","()","<p>Create the sqlite database at the appropriate docset location.\n"],["sql_execute","Dash","Dash.html#method-i-sql_execute","(options = {})","<p>Execute sql statements in the @queries array. To output the queries instead\nof execute them, pass +:noop …\n"],["sql_insert","Dash","Dash.html#method-i-sql_insert","(*args)","<p>Runs query in the docset’s sqlite database. Accepts either the query\nitself or you can pass the same …\n"],["traverse","Dash","Dash.html#method-i-traverse","(a, regx)",""]]}}