<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<meta name="collection" content="api">
<!-- Generated by javadoc (build 1.5.0-rc) on Wed Aug 11 07:27:44 PDT 2004 -->
<TITLE>
GSSContext (Java 2 Platform SE 5.0)
</TITLE>

<META NAME="keywords" CONTENT="org.ietf.jgss.GSSContext interface">
<META NAME="keywords" CONTENT="DEFAULT_LIFETIME">
<META NAME="keywords" CONTENT="INDEFINITE_LIFETIME">
<META NAME="keywords" CONTENT="initSecContext()">
<META NAME="keywords" CONTENT="acceptSecContext()">
<META NAME="keywords" CONTENT="isEstablished()">
<META NAME="keywords" CONTENT="dispose()">
<META NAME="keywords" CONTENT="getWrapSizeLimit()">
<META NAME="keywords" CONTENT="wrap()">
<META NAME="keywords" CONTENT="unwrap()">
<META NAME="keywords" CONTENT="getMIC()">
<META NAME="keywords" CONTENT="verifyMIC()">
<META NAME="keywords" CONTENT="export()">
<META NAME="keywords" CONTENT="requestMutualAuth()">
<META NAME="keywords" CONTENT="requestReplayDet()">
<META NAME="keywords" CONTENT="requestSequenceDet()">
<META NAME="keywords" CONTENT="requestCredDeleg()">
<META NAME="keywords" CONTENT="requestAnonymity()">
<META NAME="keywords" CONTENT="requestConf()">
<META NAME="keywords" CONTENT="requestInteg()">
<META NAME="keywords" CONTENT="requestLifetime()">
<META NAME="keywords" CONTENT="setChannelBinding()">
<META NAME="keywords" CONTENT="getCredDelegState()">
<META NAME="keywords" CONTENT="getMutualAuthState()">
<META NAME="keywords" CONTENT="getReplayDetState()">
<META NAME="keywords" CONTENT="getSequenceDetState()">
<META NAME="keywords" CONTENT="getAnonymityState()">
<META NAME="keywords" CONTENT="isTransferable()">
<META NAME="keywords" CONTENT="isProtReady()">
<META NAME="keywords" CONTENT="getConfState()">
<META NAME="keywords" CONTENT="getIntegState()">
<META NAME="keywords" CONTENT="getLifetime()">
<META NAME="keywords" CONTENT="getSrcName()">
<META NAME="keywords" CONTENT="getTargName()">
<META NAME="keywords" CONTENT="getMech()">
<META NAME="keywords" CONTENT="getDelegCred()">
<META NAME="keywords" CONTENT="isInitiator()">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="GSSContext (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GSSContext.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/ietf/jgss/ChannelBinding.html" title="class in org.ietf.jgss"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/ietf/jgss/GSSCredential.html" title="interface in org.ietf.jgss"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/ietf/jgss/GSSContext.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GSSContext.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.ietf.jgss</FONT>
<BR>
Interface GSSContext</H2>
<HR>
<DL>
<DT><PRE>public interface <B>GSSContext</B></DL>
</PRE>

<P>
This interface encapsulates the GSS-API security context and provides
 the security services that are available over the context.  Security
 contexts are established between peers using locally acquired
 credentials.  Multiple contexts may exist simultaneously between a pair
 of peers, using the same or different set of credentials.  GSS-API
 functions in a manner independent of the underlying transport protocol
 and depends on its calling application to transport the tokens that are
 generated by the security context between the peers.<p>

 If the caller instantiates the context using the default
 <code>GSSManager</code> instance, then the Kerberos v5 GSS-API mechanism
 is guaranteed to be available for context establishment. This mechanism
 is identified by the Oid "1.2.840.113554.1.2.2" and is defined in RFC
 1964.<p>

 Before the context establishment phase is initiated, the context
 initiator may request specific characteristics desired of the
 established context. Not all underlying mechanisms support all
 characteristics that a caller might desire. After the context is
 established, the caller can check the actual characteristics and services
 offered by that context by means of various query methods. When using
 the Kerberos v5 GSS-API mechanism offered by the default
 <code>GSSManager</code> instance, all optional services will be
 available locally. They are mutual authentication, credential
 delegation, confidentiality and integrity protection, and per-message
 replay detection and sequencing. Note that in the GSS-API, message integrity
 is a prerequisite for message confidentiality.<p>

 The context establishment occurs in a loop where the
 initiator calls <A HREF="../../../org/ietf/jgss/GSSContext.html#initSecContext(byte[], int, int)"><CODE>initSecContext</CODE></A>
 and the acceptor calls <A HREF="../../../org/ietf/jgss/GSSContext.html#acceptSecContext(byte[], int, int)"><CODE>acceptSecContext</CODE></A> until the context is established. While in this loop
 the <code>initSecContext</code> and <code>acceptSecContext</code>
 methods produce tokens that the application sends over to the peer. The
 peer passes any such token as input to its <code>acceptSecContext</code>
 or <code>initSecContext</code> as the case may be.<p>

 During the context establishment phase, the <A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A> method may be called to determine if the
 context can be used for the per-message operations of <A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>wrap</CODE></A> and <A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>getMIC</CODE></A>.  This allows applications to use
 per-message operations on contexts which aren't yet fully
 established.<p>

 After the context has been established or the <code>isProtReady</code>
 method returns <code>true</code>, the query routines can be invoked to
 determine the actual characteristics and services of the established
 context.  The application can also start using the per-message methods
 of <A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>wrap</CODE></A> and
 <A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>getMIC</CODE></A> to obtain
 cryptographic operations on application supplied data.<p>

 When the context is no longer needed, the application should call
 <A HREF="../../../org/ietf/jgss/GSSContext.html#dispose()"><CODE>dispose</CODE></A> to release any system resources the context
 may be using.<p>

 A security context typically maintains sequencing and replay detection
 information about the tokens it processes. Therefore, the sequence in
 which any tokens are presented to this context for processing can be
 important. Also note that none of the methods in this interface are
 synchronized. Therefore, it is not advisable to share a
 <code>GSSContext</code> among several threads unless some application
 level synchronization is in place.<p>

 Finally, different mechanism providers might place different security
 restrictions on using GSS-API contexts. These will be documented by the
 mechanism provider. The application will need to ensure that it has the
 appropriate permissions if such checks are made in the mechanism layer.<p>

 The example code presented below demonstrates the usage of the
 <code>GSSContext</code> interface for the initiating peer.  Different
 operations on the <code>GSSContext</code> object are presented,
 including: object instantiation, setting of desired flags, context
 establishment, query of actual context flags, per-message operations on
 application data, and finally context deletion.<p>

 <pre>
    // Create a context using default credentials 
    // and the implementation specific default mechanism
    GSSManager manager ...
    GSSName targetName ...
    GSSContext context = manager.createContext(targetName, null, null,
                                           GSSContext.INDEFINITE_LIFETIME);
 
    // set desired context options prior to context establishment
    context.requestConf(true);
    context.requestMutualAuth(true);
    context.requestReplayDet(true);
    context.requestSequenceDet(true);
    
    // establish a context between peers

    byte []inToken = new byte[0];

    // Loop while there still is a token to be processed

    while (!context.isEstablished()) {

        byte[] outToken 
            = context.initSecContext(inToken, 0, inToken.length);
        
        // send the output token if generated
        if (outToken != null)
            sendToken(outToken);
  
        if (!context.isEstablished()) {
            inToken = readToken();
    }
    
     // display context information
     System.out.println("Remaining lifetime in seconds = " 
                                          + context.getLifetime());
     System.out.println("Context mechanism = " + context.getMech());
     System.out.println("Initiator = " + context.getSrcName());
     System.out.println("Acceptor = " + context.getTargName());
  
     if (context.getConfState())
             System.out.println("Confidentiality (i.e., privacy) is available");
  
     if (context.getIntegState())
             System.out.println("Integrity is available");
  
     // perform wrap on an application supplied message, appMsg,
     // using QOP = 0, and requesting privacy service
     byte [] appMsg ...
  
     MessageProp mProp = new MessageProp(0, true);
  
     byte []tok = context.wrap(appMsg, 0, appMsg.length, mProp);
  
     sendToken(tok);
  
     // release the local-end of the context
     context.dispose();

 </pre>
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.4</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#DEFAULT_LIFETIME">DEFAULT_LIFETIME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A lifetime constant representing the default context lifetime.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#INDEFINITE_LIFETIME">INDEFINITE_LIFETIME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A lifetime constant representing indefinite context lifetime.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#acceptSecContext(byte[], int, int)">acceptSecContext</A></B>(byte[]&nbsp;inToken,
                 int&nbsp;offset,
                 int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Called by the context acceptor upon receiving a token from the
 peer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#acceptSecContext(java.io.InputStream, java.io.OutputStream)">acceptSecContext</A></B>(<A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;inStream,
                 <A HREF="../../../java/io/OutputStream.html" title="class in java.io">OutputStream</A>&nbsp;outStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Called by the context acceptor to process a token from the peer using
 streams.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#dispose()">dispose</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Releases any system resources and cryptographic information stored in 
 the context object and invalidates the context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#export()">export</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exports this context so that another process may
 import it..</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getAnonymityState()">getAnonymityState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if the context initiator is
 anonymously authenticated to the context acceptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getConfState()">getConfState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if data confidentiality is available
 over the context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getCredDelegState()">getCredDelegState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if credential delegation is enabled on
 this context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/ietf/jgss/GSSCredential.html" title="interface in org.ietf.jgss">GSSCredential</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getDelegCred()">getDelegCred</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Obtains the credentials delegated by the context
 initiator to the context acceptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()">getIntegState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if data integrity is available
 over the context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getLifetime()">getLifetime</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines what the remaining lifetime for this
 context is.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/ietf/jgss/Oid.html" title="class in org.ietf.jgss">Oid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getMech()">getMech</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines what mechanism is being used for this
 context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(byte[], int, int, org.ietf.jgss.MessageProp)">getMIC</A></B>(byte[]&nbsp;inMsg,
       int&nbsp;offset,
       int&nbsp;len,
       <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a token containing a cryptographic Message Integrity Code
 (MIC) for the supplied message,  for transfer to the peer
 application.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)">getMIC</A></B>(<A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;inStream,
       <A HREF="../../../java/io/OutputStream.html" title="class in java.io">OutputStream</A>&nbsp;outStream,
       <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uses streams to produce a token containing a cryptographic MIC for
 the supplied message, for transfer to the peer application.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getMutualAuthState()">getMutualAuthState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if mutual authentication is enabled on
 this context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getReplayDetState()">getReplayDetState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if replay detection is enabled for the
 per-message security services from this context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getSequenceDetState()">getSequenceDetState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if sequence checking is enabled for the
 per-message security services from this context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/ietf/jgss/GSSName.html" title="interface in org.ietf.jgss">GSSName</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getSrcName()">getSrcName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the name of the context initiator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/ietf/jgss/GSSName.html" title="interface in org.ietf.jgss">GSSName</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getTargName()">getTargName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the name of the context acceptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getWrapSizeLimit(int, boolean, int)">getWrapSizeLimit</A></B>(int&nbsp;qop,
                 boolean&nbsp;confReq,
                 int&nbsp;maxTokenSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used to determine limits on the size of the message 
 that can be passed to <code>wrap</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#initSecContext(byte[], int, int)">initSecContext</A></B>(byte[]&nbsp;inputBuf,
               int&nbsp;offset,
               int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Called by the context initiator to start the context creation
 phase and process any tokens generated
 by the peer's <code>acceptSecContext</code> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#initSecContext(java.io.InputStream, java.io.OutputStream)">initSecContext</A></B>(<A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;inStream,
               <A HREF="../../../java/io/OutputStream.html" title="class in java.io">OutputStream</A>&nbsp;outStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Called by the context initiator to start the context creation
 phase and process any tokens generated
 by the peer's <code>acceptSecContext</code> method using
 streams.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()">isEstablished</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used during context establishment to determine the state of the
 context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#isInitiator()">isInitiator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if this is the context initiator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()">isProtReady</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if the context is ready for per message operations to be
 used over it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#isTransferable()">isTransferable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if the context is transferable to other processes
 through the use of the <A HREF="../../../org/ietf/jgss/GSSContext.html#export()"><CODE>export</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestAnonymity(boolean)">requestAnonymity</A></B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests that the initiator's identity not be
 disclosed to the acceptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestConf(boolean)">requestConf</A></B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests that data confidentiality be enabled
 for the <code>wrap</code> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestCredDeleg(boolean)">requestCredDeleg</A></B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests that the initiator's credentials be
 delegated to the acceptor during context establishment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestInteg(boolean)">requestInteg</A></B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests that data integrity be enabled
 for the <code>wrap</code> and <code>getMIC</code>methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestLifetime(int)">requestLifetime</A></B>(int&nbsp;lifetime)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests a lifetime in seconds for the
 context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestMutualAuth(boolean)">requestMutualAuth</A></B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests that mutual authentication be done during
 context establishment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestReplayDet(boolean)">requestReplayDet</A></B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests that replay detection be enabled for the
 per-message security services after context establishemnt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestSequenceDet(boolean)">requestSequenceDet</A></B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests that sequence checking be enabled for the
 per-message security services after context establishemnt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#setChannelBinding(org.ietf.jgss.ChannelBinding)">setChannelBinding</A></B>(<A HREF="../../../org/ietf/jgss/ChannelBinding.html" title="class in org.ietf.jgss">ChannelBinding</A>&nbsp;cb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the channel bindings to be used during context
 establishment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#unwrap(byte[], int, int, org.ietf.jgss.MessageProp)">unwrap</A></B>(byte[]&nbsp;inBuf,
       int&nbsp;offset,
       int&nbsp;len,
       <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used to process tokens generated by the <code>wrap</code> method on
 the other side of the context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#unwrap(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)">unwrap</A></B>(<A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;inStream,
       <A HREF="../../../java/io/OutputStream.html" title="class in java.io">OutputStream</A>&nbsp;outStream,
       <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uses streams to process tokens generated by the <code>wrap</code>
 method on the other side of the context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)">verifyMIC</A></B>(byte[]&nbsp;inToken,
          int&nbsp;tokOffset,
          int&nbsp;tokLen,
          byte[]&nbsp;inMsg,
          int&nbsp;msgOffset,
          int&nbsp;msgLen,
          <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verifies the cryptographic MIC, contained in the token parameter,
 over the supplied message.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#verifyMIC(java.io.InputStream, java.io.InputStream, org.ietf.jgss.MessageProp)">verifyMIC</A></B>(<A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;tokStream,
          <A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;msgStream,
          <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uses streams to verify the cryptographic MIC, contained in the token
 parameter, over the supplied message.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(byte[], int, int, org.ietf.jgss.MessageProp)">wrap</A></B>(byte[]&nbsp;inBuf,
     int&nbsp;offset,
     int&nbsp;len,
     <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applies per-message security services over the established security
 context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)">wrap</A></B>(<A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;inStream,
     <A HREF="../../../java/io/OutputStream.html" title="class in java.io">OutputStream</A>&nbsp;outStream,
     <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applies per-message security services over the established security
 context using streams.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DEFAULT_LIFETIME"><!-- --></A><H3>
DEFAULT_LIFETIME</H3>
<PRE>
static final int <B>DEFAULT_LIFETIME</B></PRE>
<DL>
<DD>A lifetime constant representing the default context lifetime.  This
 value is set to 0.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.ietf.jgss.GSSContext.DEFAULT_LIFETIME">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="INDEFINITE_LIFETIME"><!-- --></A><H3>
INDEFINITE_LIFETIME</H3>
<PRE>
static final int <B>INDEFINITE_LIFETIME</B></PRE>
<DL>
<DD>A lifetime constant representing indefinite context lifetime.
 This value must is set to the maximum integer value in Java -
 <A HREF="../../../java/lang/Integer.html#MAX_VALUE"><CODE>Integer.MAX_VALUE</CODE></A>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.ietf.jgss.GSSContext.INDEFINITE_LIFETIME">Constant Field Values</A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="initSecContext(byte[], int, int)"><!-- --></A><H3>
initSecContext</H3>
<PRE>
byte[] <B>initSecContext</B>(byte[]&nbsp;inputBuf,
                      int&nbsp;offset,
                      int&nbsp;len)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Called by the context initiator to start the context creation
 phase and process any tokens generated
 by the peer's <code>acceptSecContext</code> method.
 This method may return an output token which the application will need
 to send to the peer for processing by its <code>acceptSecContext</code>
 method. The application can call <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> to determine if the context establishment phase is
 complete on this side of the context.  A return value of
 <code>false</code> from <code>isEstablished</code> indicates that
 more tokens are expected to be supplied to
 <code>initSecContext</code>.  Upon completion of the context
 establishment, the available context options may be queried through
 the get methods.<p>

 Note that it is possible that the <code>initSecContext</code> method
 return a token for the peer, and <code>isEstablished</code> return
 <code>true</code> also. This indicates that the token needs to be sent
 to the peer, but the local end of the context is now fully
 established.<p>

 Some mechanism providers might require that the caller be granted
 permission to initiate a security context. A failed permission check 
 might cause a <A HREF="../../../java/lang/SecurityException.html" title="class in java.lang"><CODE>SecurityException</CODE></A>
 to be thrown from this method.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inputBuf</CODE> - token generated by the peer. This parameter is ignored
 on the first call since no token has been received from the peer.<DD><CODE>offset</CODE> - the offset within the inputBuf where the token begins.<DD><CODE>len</CODE> - the length of the token.
<DT><B>Returns:</B><DD>a byte[] containing the token to be sent to the
 peer. <code>null</code> indicates that no token is generated.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#NO_CRED"><CODE>GSSException.NO_CRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CREDENTIALS_EXPIRED"><CODE>GSSException.CREDENTIALS_EXPIRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_BINDINGS"><CODE>GSSException.BAD_BINDINGS</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#OLD_TOKEN"><CODE>GSSException.OLD_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#DUPLICATE_TOKEN"><CODE>GSSException.DUPLICATE_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_NAMETYPE"><CODE>GSSException.BAD_NAMETYPE</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MECH"><CODE>GSSException.BAD_MECH</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="initSecContext(java.io.InputStream, java.io.OutputStream)"><!-- --></A><H3>
initSecContext</H3>
<PRE>
int <B>initSecContext</B>(<A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;inStream,
                   <A HREF="../../../java/io/OutputStream.html" title="class in java.io">OutputStream</A>&nbsp;outStream)
                   throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Called by the context initiator to start the context creation
 phase and process any tokens generated
 by the peer's <code>acceptSecContext</code> method using
 streams. This method may write an output token to the
 <code>OutpuStream</code>, which the application will
 need to send to the peer for processing by its
 <code>acceptSecContext</code> call. Typically, the application would
 ensure this by calling the  <A HREF="../../../java/io/OutputStream.html#flush()"><CODE>flush</CODE></A>
 method on an <code>OutputStream</code> that encapsulates the
 connection between the two peers. The application can
 determine if a token is written to the OutputStream from the return
 value of this method. A return value of <code>0</code> indicates that
 no token was written. The application can call
 <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> to determine if the context 
 establishment phase is complete on this side of the context. A
 return  value of <code>false</code> from <code>isEstablished</code>
 indicates that more tokens are expected to be supplied to
 <code>initSecContext</code>.
 Upon completion of the context establishment, the available context
 options may be queried through the get methods.<p>

 Note that it is possible that the <code>initSecContext</code> method
 return a token for the peer, and <code>isEstablished</code> return
 <code>true</code> also. This indicates that the token needs to be sent
 to the peer, but the local end of the context is now fully
 established.<p>

 The GSS-API authentication tokens contain a definitive start and
 end. This method will attempt to read one of these tokens per
 invocation, and may block on the stream if only part of the token is
 available.  In all other respects this method is equivalent to the
 byte array based <A HREF="../../../org/ietf/jgss/GSSContext.html#initSecContext(byte[], int, int)"><CODE>initSecContext</CODE></A>.<p>

 Some mechanism providers might require that the caller be granted
 permission to initiate a security context. A failed permission check 
 might cause a <A HREF="../../../java/lang/SecurityException.html" title="class in java.lang"><CODE>SecurityException</CODE></A>
 to be thrown from this method.<p>

 The following example code demonstrates how this method might be
 used:<p>
 <pre>
     InputStream is ...
     OutputStream os ...
     GSSContext context ...

     // Loop while there is still a token to be processed

     while (!context.isEstablished()) {

         context.initSecContext(is, os);

         // send output token if generated
         os.flush();
     }
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inStream</CODE> - an InputStream that contains the token generated by
 the peer. This parameter is ignored on the first call since no token
 has been or will be received from the peer at that point.<DD><CODE>outStream</CODE> - an OutputStream where the output token will be
 written. During the final stage of context establishment, there may be
 no bytes written.
<DT><B>Returns:</B><DD>the number of bytes written to the OutputStream as part of the 
 token to be sent to the peer. A value of 0 indicates that no token
 needs to be sent.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#NO_CRED"><CODE>GSSException.NO_CRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CREDENTIALS_EXPIRED"><CODE>GSSException.CREDENTIALS_EXPIRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_BINDINGS"><CODE>GSSException.BAD_BINDINGS</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#OLD_TOKEN"><CODE>GSSException.OLD_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#DUPLICATE_TOKEN"><CODE>GSSException.DUPLICATE_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_NAMETYPE"><CODE>GSSException.BAD_NAMETYPE</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MECH"><CODE>GSSException.BAD_MECH</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="acceptSecContext(byte[], int, int)"><!-- --></A><H3>
acceptSecContext</H3>
<PRE>
byte[] <B>acceptSecContext</B>(byte[]&nbsp;inToken,
                        int&nbsp;offset,
                        int&nbsp;len)
                        throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Called by the context acceptor upon receiving a token from the
 peer. This method may return an output token which the application
 will need to send to the peer for further processing by its
 <code>initSecContext</code> call.<p>

 The application can call <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> to
 determine if the context establishment phase is complete for this
 peer.  A return value of <code>false</code> from
 <code>isEstablished</code> indicates that more tokens are expected to
 be supplied to this method.    Upon completion of the context
 establishment, the available context options may be queried through
 the get methods.<p>

 Note that it is possible that <code>acceptSecContext</code> return a
 token for the peer, and <code>isEstablished</code> return
 <code>true</code> also.  This indicates that the token needs to be
 sent to the peer, but the local end of the context is now fully
 established.<p>

 Some mechanism providers might require that the caller be granted
 permission to accept a security context. A failed permission check 
 might cause a <A HREF="../../../java/lang/SecurityException.html" title="class in java.lang"><CODE>SecurityException</CODE></A>
 to be thrown from this method.<p>

 The following example code demonstrates how this method might be
 used:<p>
 <pre>
     byte[] inToken;
     byte[] outToken;
     GSSContext context ...

     // Loop while there is still a token to be processed

     while (!context.isEstablished()) {
         inToken = readToken();
         outToken = context.acceptSecContext(inToken, 0,
                                             inToken.length);
         // send output token if generated
         if (outToken != null)
             sendToken(outToken);
     }
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inToken</CODE> - token generated by the peer.<DD><CODE>offset</CODE> - the offset within the inToken where the token begins.<DD><CODE>len</CODE> - the length of the token.
<DT><B>Returns:</B><DD>a byte[] containing the token to be sent to the
 peer. <code>null</code> indicates that no token is generated.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#NO_CRED"><CODE>GSSException.NO_CRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CREDENTIALS_EXPIRED"><CODE>GSSException.CREDENTIALS_EXPIRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_BINDINGS"><CODE>GSSException.BAD_BINDINGS</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#OLD_TOKEN"><CODE>GSSException.OLD_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#DUPLICATE_TOKEN"><CODE>GSSException.DUPLICATE_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MECH"><CODE>GSSException.BAD_MECH</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="acceptSecContext(java.io.InputStream, java.io.OutputStream)"><!-- --></A><H3>
acceptSecContext</H3>
<PRE>
void <B>acceptSecContext</B>(<A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;inStream,
                      <A HREF="../../../java/io/OutputStream.html" title="class in java.io">OutputStream</A>&nbsp;outStream)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Called by the context acceptor to process a token from the peer using
 streams.   It may write an output token to the
 <code>OutputStream</code>, which the application
 will need to send to the peer for processing by its
 <code>initSecContext</code> method.  Typically, the application would
 ensure this by calling the  <A HREF="../../../java/io/OutputStream.html#flush()"><CODE>flush</CODE></A>
 method on an <code>OutputStream</code> that encapsulates the
 connection between the two peers. The application can call
 <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> to determine if the context
 establishment phase is complete on this side of the context. A
 return  value of <code>false</code> from <code>isEstablished</code>
 indicates that more tokens are expected to be supplied to
 <code>acceptSecContext</code>. 
 Upon completion of the context establishment, the available context
 options may be queried through the get methods.<p>

 Note that it is possible that <code>acceptSecContext</code> return a
 token for the peer, and <code>isEstablished</code> return
 <code>true</code> also.  This indicates that the token needs to be
 sent to the peer, but the local end of the context is now fully
 established.<p>

 The GSS-API authentication tokens contain a definitive start and
 end. This method will attempt to read one of these tokens per
 invocation, and may block on the stream if only part of the token is
 available. In all other respects this method is equivalent to the byte
 array based <A HREF="../../../org/ietf/jgss/GSSContext.html#acceptSecContext(byte[], int, int)"><CODE>acceptSecContext</CODE></A>.<p>

 Some mechanism providers might require that the caller be granted
 permission to accept a security context. A failed permission check 
 might cause a <A HREF="../../../java/lang/SecurityException.html" title="class in java.lang"><CODE>SecurityException</CODE></A>
 to be thrown from this method.<p>

 The following example code demonstrates how this method might be
 used:<p>
 <pre>
     InputStream is ...
     OutputStream os ...
     GSSContext context ...

     // Loop while there is still a token to be processed

     while (!context.isEstablished()) {

         context.acceptSecContext(is, os);

         // send output token if generated
         os.flush();
     }
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inStream</CODE> - an InputStream that contains the token generated by
 the peer.<DD><CODE>outStream</CODE> - an OutputStream where the output token will be
 written. During the final stage of context establishment, there may be
 no bytes written.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#NO_CRED"><CODE>GSSException.NO_CRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CREDENTIALS_EXPIRED"><CODE>GSSException.CREDENTIALS_EXPIRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_BINDINGS"><CODE>GSSException.BAD_BINDINGS</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#OLD_TOKEN"><CODE>GSSException.OLD_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#DUPLICATE_TOKEN"><CODE>GSSException.DUPLICATE_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MECH"><CODE>GSSException.BAD_MECH</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isEstablished()"><!-- --></A><H3>
isEstablished</H3>
<PRE>
boolean <B>isEstablished</B>()</PRE>
<DL>
<DD>Used during context establishment to determine the state of the
 context.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if this is a fully established context on
 the caller's side and no more tokens are needed from the peer.</DL>
</DD>
</DL>
<HR>

<A NAME="dispose()"><!-- --></A><H3>
dispose</H3>
<PRE>
void <B>dispose</B>()
             throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Releases any system resources and cryptographic information stored in 
 the context object and invalidates the context.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getWrapSizeLimit(int, boolean, int)"><!-- --></A><H3>
getWrapSizeLimit</H3>
<PRE>
int <B>getWrapSizeLimit</B>(int&nbsp;qop,
                     boolean&nbsp;confReq,
                     int&nbsp;maxTokenSize)
                     throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Used to determine limits on the size of the message 
 that can be passed to <code>wrap</code>. Returns the maximum
 message size that, if presented to the <code>wrap</code> method with
 the same <code>confReq</code> and <code>qop</code> parameters, will
 result in an output token containing no more
 than <code>maxTokenSize</code> bytes.<p>

 This call is intended for use by applications that communicate over
 protocols that impose a maximum message size.  It enables the
 application to fragment messages prior to applying protection.<p>

 GSS-API implementations are recommended but not required to detect
 invalid QOP values when <code>getWrapSizeLimit</code> is called.
 This routine guarantees only a maximum message size, not the
 availability of specific QOP values for message protection.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>qop</CODE> - the level of protection wrap will be asked to provide.<DD><CODE>confReq</CODE> - <code>true</code> if wrap will be asked to provide
 privacy, <code>false</code>  otherwise.<DD><CODE>maxTokenSize</CODE> - the desired maximum size of the token emitted by
 wrap.
<DT><B>Returns:</B><DD>the maximum size of the input token for the given output
 token size
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="wrap(byte[], int, int, org.ietf.jgss.MessageProp)"><!-- --></A><H3>
wrap</H3>
<PRE>
byte[] <B>wrap</B>(byte[]&nbsp;inBuf,
            int&nbsp;offset,
            int&nbsp;len,
            <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)
            throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Applies per-message security services over the established security
 context. The method will return a token with the
 application supplied data and a cryptographic MIC over it.
 The data may be encrypted if confidentiality (privacy) was
 requested.<p>

 The MessageProp object is instantiated by the application and used
 to specify a QOP value which selects cryptographic algorithms, and a
 privacy service to optionally encrypt the message.  The underlying
 mechanism that is used in the call may not be able to provide the
 privacy service.  It sets the actual privacy service that it does
 provide in this MessageProp object which the caller should then
 query upon return.  If the mechanism is not able to provide the
 requested QOP, it throws a GSSException with the BAD_QOP code.<p>

 Since some application-level protocols may wish to use tokens
 emitted by wrap to provide "secure framing", implementations should
 support the wrapping of zero-length messages.<p>

 The application will be responsible for sending the token to the
 peer.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inBuf</CODE> - application data to be protected.<DD><CODE>offset</CODE> - the offset within the inBuf where the data begins.<DD><CODE>len</CODE> - the length of the data<DD><CODE>msgProp</CODE> - instance of MessageProp that is used by the
 application to set the desired QOP and privacy state. Set the
 desired QOP to 0 to request the default QOP. Upon return from this
 method, this object will contain the the actual privacy state that
 was applied to the message by the underlying mechanism.
<DT><B>Returns:</B><DD>a byte[] containing the token to be sent to the peer.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="wrap(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)"><!-- --></A><H3>
wrap</H3>
<PRE>
void <B>wrap</B>(<A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;inStream,
          <A HREF="../../../java/io/OutputStream.html" title="class in java.io">OutputStream</A>&nbsp;outStream,
          <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)
          throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Applies per-message security services over the established security
 context using streams. The method will return a
 token with the application supplied data and a cryptographic MIC over it.
 The data may be encrypted if confidentiality
 (privacy) was requested. This method is equivalent to the byte array
 based <A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>wrap</CODE></A> method.<p>

 The application will be responsible for sending the token to the
 peer.  Typically, the application would
 ensure this by calling the  <A HREF="../../../java/io/OutputStream.html#flush()"><CODE>flush</CODE></A>
 method on an <code>OutputStream</code> that encapsulates the
 connection between the two peers.<p>

 The MessageProp object is instantiated by the application and used
 to specify a QOP value which selects cryptographic algorithms, and a
 privacy service to optionally encrypt the message.  The underlying
 mechanism that is used in the call may not be able to provide the
 privacy service.  It sets the actual privacy service that it does
 provide in this MessageProp object which the caller should then
 query upon return.  If the mechanism is not able to provide the
 requested QOP, it throws a GSSException with the BAD_QOP code.<p>

 Since some application-level protocols may wish to use tokens
 emitted by wrap to provide "secure framing", implementations should
 support the wrapping of zero-length messages.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inStream</CODE> - an InputStream containing the application data to be
 protected. All of the data that is available in
 inStream is used.<DD><CODE>outStream</CODE> - an OutputStream to write the protected message
 to.<DD><CODE>msgProp</CODE> - instance of MessageProp that is used by the
 application to set the desired QOP and privacy state. Set the
 desired QOP to 0 to request the default QOP. Upon return from this
 method, this object will contain the the actual privacy state that
 was applied to the message by the underlying mechanism.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(byte[], int, int, org.ietf.jgss.MessageProp)"><!-- --></A><H3>
unwrap</H3>
<PRE>
byte[] <B>unwrap</B>(byte[]&nbsp;inBuf,
              int&nbsp;offset,
              int&nbsp;len,
              <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)
              throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Used to process tokens generated by the <code>wrap</code> method on
 the other side of the context. The method will return the message
 supplied by the peer application to its wrap call, while at the same
 time verifying the embedded MIC for that message.<p>

 The MessageProp object is instantiated by the application and is
 used by the underlying mechanism to return information to the caller
 such as the QOP, whether confidentiality was applied to the message,
 and other supplementary message state information.<p>

 Since some application-level protocols may wish to use tokens
 emitted by wrap to provide "secure framing", implementations should
 support the wrapping and unwrapping of zero-length messages.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inBuf</CODE> - a byte array containing the wrap token received from
 peer.<DD><CODE>offset</CODE> - the offset where the token begins.<DD><CODE>len</CODE> - the length of the token<DD><CODE>msgProp</CODE> - upon return from the method, this object will contain
 the applied QOP, the privacy state of the message, and supplementary
 information stating if the token was a duplicate, old, out of
 sequence or arriving after a gap.
<DT><B>Returns:</B><DD>a byte[] containing the message unwrapped from the input
 token.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)"><!-- --></A><H3>
unwrap</H3>
<PRE>
void <B>unwrap</B>(<A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;inStream,
            <A HREF="../../../java/io/OutputStream.html" title="class in java.io">OutputStream</A>&nbsp;outStream,
            <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)
            throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Uses streams to process tokens generated by the <code>wrap</code>
 method on the other side of the context. The method will return the
 message supplied by the peer application to its wrap call, while at
 the same time verifying the embedded MIC for that message.<p>
 
 The MessageProp object is instantiated by the application and is
 used by the underlying mechanism to return information to the caller
 such as the QOP, whether confidentiality was applied to the message,
 and other supplementary message state information.<p>

 Since some application-level protocols may wish to use tokens
 emitted by wrap to provide "secure framing", implementations should
 support the wrapping and unwrapping of zero-length messages.<p>

 The format of the input token that this method
 reads is defined in the specification for the underlying mechanism that
 will be used. This method will attempt to read one of these tokens per
 invocation. If the mechanism token contains a definitive start and
 end this method may block on the <code>InputStream</code> if only
 part of the token is available. If the start and end of the token
 are not definitive then the method will attempt to treat all
 available bytes as part of the token.<p>

 Other than the possible blocking behaviour described above, this
 method is equivalent to the byte array based <A HREF="../../../org/ietf/jgss/GSSContext.html#unwrap(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>unwrap</CODE></A> method.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inStream</CODE> - an InputStream that contains the wrap token generated
 by the peer.<DD><CODE>outStream</CODE> - an OutputStream to write the application message
 to.<DD><CODE>msgProp</CODE> - upon return from the method, this object will contain
 the applied QOP, the privacy state of the message, and supplementary
 information stating if the token was a duplicate, old, out of
 sequence or arriving after a gap.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMIC(byte[], int, int, org.ietf.jgss.MessageProp)"><!-- --></A><H3>
getMIC</H3>
<PRE>
byte[] <B>getMIC</B>(byte[]&nbsp;inMsg,
              int&nbsp;offset,
              int&nbsp;len,
              <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)
              throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Returns a token containing a cryptographic Message Integrity Code
 (MIC) for the supplied message,  for transfer to the peer
 application.  Unlike wrap, which encapsulates the user message in the
 returned token, only the message MIC is returned in the output
 token.<p> 

 Note that privacy can only be applied through the wrap call.<p>

 Since some application-level protocols may wish to use tokens emitted
 by getMIC to provide "secure framing", implementations should support
 derivation of MICs from zero-length messages.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inMsg</CODE> - the message to generate the MIC over.<DD><CODE>offset</CODE> - offset within the inMsg where the message begins.<DD><CODE>len</CODE> - the length of the message<DD><CODE>msgProp</CODE> - an instance of <code>MessageProp</code> that is used
 by the application to set the desired QOP.  Set the desired QOP to
 <code>0</code> in <code>msgProp</code> to request the default
 QOP. Alternatively pass in <code>null</code> for <code>msgProp</code>
 to request the default QOP.
<DT><B>Returns:</B><DD>a byte[] containing the token to be sent to the peer.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMIC(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)"><!-- --></A><H3>
getMIC</H3>
<PRE>
void <B>getMIC</B>(<A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;inStream,
            <A HREF="../../../java/io/OutputStream.html" title="class in java.io">OutputStream</A>&nbsp;outStream,
            <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)
            throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Uses streams to produce a token containing a cryptographic MIC for
 the supplied message, for transfer to the peer application.
 Unlike wrap, which encapsulates the user message in the returned
 token, only the message MIC is produced in the output token. This
 method is equivalent to the byte array based <A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>getMIC</CODE></A> method.

 Note that privacy can only be applied through the wrap call.<p>

 Since some application-level protocols may wish to use tokens emitted
 by getMIC to provide "secure framing", implementations should support
 derivation of MICs from zero-length messages.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inStream</CODE> - an InputStream containing the message to generate the 
 MIC over. All of the data that is available in
 inStream is used.<DD><CODE>outStream</CODE> - an OutputStream to write the output token to.<DD><CODE>msgProp</CODE> - an instance of <code>MessageProp</code> that is used
 by the application to set the desired QOP.  Set the desired QOP to
 <code>0</code> in <code>msgProp</code> to request the default
 QOP. Alternatively pass in <code>null</code> for <code>msgProp</code>
 to request the default QOP.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)"><!-- --></A><H3>
verifyMIC</H3>
<PRE>
void <B>verifyMIC</B>(byte[]&nbsp;inToken,
               int&nbsp;tokOffset,
               int&nbsp;tokLen,
               byte[]&nbsp;inMsg,
               int&nbsp;msgOffset,
               int&nbsp;msgLen,
               <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)
               throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Verifies the cryptographic MIC, contained in the token parameter,
 over the supplied message.<p>

 The MessageProp object is instantiated by the application and is used
 by the underlying mechanism to return information to the caller such
 as the QOP indicating the strength of protection that was applied to
 the message and other supplementary message state information.<p>

 Since some application-level protocols may wish to use tokens emitted
 by getMIC to provide "secure framing", implementations should support
 the calculation and verification of MICs over zero-length messages.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inToken</CODE> - the token generated by peer's getMIC method.<DD><CODE>tokOffset</CODE> - the offset within the inToken where the token
 begins.<DD><CODE>tokLen</CODE> - the length of the token.<DD><CODE>inMsg</CODE> - the application message to verify the cryptographic MIC
 over.<DD><CODE>msgOffset</CODE> - the offset in inMsg where the message begins.<DD><CODE>msgLen</CODE> - the length of the message.<DD><CODE>msgProp</CODE> - upon return from the method, this object will contain
 the applied QOP and supplementary information stating if the token
 was a duplicate, old, out of sequence or arriving after a gap.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="verifyMIC(java.io.InputStream, java.io.InputStream, org.ietf.jgss.MessageProp)"><!-- --></A><H3>
verifyMIC</H3>
<PRE>
void <B>verifyMIC</B>(<A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;tokStream,
               <A HREF="../../../java/io/InputStream.html" title="class in java.io">InputStream</A>&nbsp;msgStream,
               <A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss">MessageProp</A>&nbsp;msgProp)
               throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Uses streams to verify the cryptographic MIC, contained in the token
 parameter, over the supplied message.  This method is equivalent to
 the byte array based <A HREF="../../../org/ietf/jgss/GSSContext.html#verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>verifyMIC</CODE></A> method.

 The MessageProp object is instantiated by the application and is used
 by the underlying mechanism to return information to the caller such
 as the QOP indicating the strength of protection that was applied to
 the message and other supplementary message state information.<p>

 Since some application-level protocols may wish to use tokens emitted
 by getMIC to provide "secure framing", implementations should support
 the calculation and verification of MICs over zero-length messages.<p>

 The format of the input token that this method
 reads is defined in the specification for the underlying mechanism that
 will be used. This method will attempt to read one of these tokens per
 invocation. If the mechanism token contains a definitive start and
 end this method may block on the <code>InputStream</code> if only
 part of the token is available. If the start and end of the token
 are not definitive then the method will attempt to treat all
 available bytes as part of the token.<p>

 Other than the possible blocking behaviour described above, this
 method is equivalent to the byte array based <A HREF="../../../org/ietf/jgss/GSSContext.html#verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>verifyMIC</CODE></A> method.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tokStream</CODE> - an InputStream containing the token generated by the 
 peer's getMIC method.<DD><CODE>msgStream</CODE> - an InputStream containing the application message to
 verify the cryptographic MIC over. All of the data
 that is available in msgStream is used.<DD><CODE>msgProp</CODE> - upon return from the method, this object will contain
 the applied QOP and supplementary information stating if the token
 was a duplicate, old, out of sequence or arriving after a gap.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="export()"><!-- --></A><H3>
export</H3>
<PRE>
byte[] <B>export</B>()
              throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Exports this context so that another process may
 import it.. Provided to support the sharing of work between
 multiple processes. This routine will typically be used by the
 context-acceptor, in an application where a single process receives
 incoming connection requests and accepts security contexts over
 them, then passes the established context to one or more other
 processes for message exchange.<p>

 This method deactivates the security context and creates an
 interprocess token which, when passed to <A HREF="../../../org/ietf/jgss/GSSManager.html#createContext(byte[])"><CODE>GSSManager.createContext</CODE></A> in
 another process, will re-activate the context in the second process.
 Only a single instantiation of a given context may be active at any
 one time; a subsequent attempt by a context exporter to access the
 exported security context will fail.<p>

 The implementation may constrain the set of processes by which the
 interprocess token may be imported, either as a function of local
 security policy, or as a result of implementation decisions.  For
 example, some implementations may constrain contexts to be passed
 only between processes that run under the same account, or which are
 part of the same process group.<p>

 The interprocess token may contain security-sensitive information
 (for example cryptographic keys).  While mechanisms are encouraged
 to either avoid placing such sensitive information within
 interprocess tokens, or to encrypt the token before returning it to
 the application, in a typical GSS-API implementation this may not be
 possible.  Thus the application must take care to protect the
 interprocess token, and ensure that any process to which the token
 is transferred is trustworthy. <p>

 Implementations are not required to support the inter-process
 transfer of security contexts.  Calling the <A HREF="../../../org/ietf/jgss/GSSContext.html#isTransferable()"><CODE>isTransferable</CODE></A> method will indicate if the context object is
 transferable.<p>

 Calling this method on a context that 
 is not exportable will result in this exception being thrown with
 the error code <A HREF="../../../org/ietf/jgss/GSSException.html#UNAVAILABLE"><CODE>GSSException.UNAVAILABLE</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a byte[] containing the exported context
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#UNAVAILABLE"><CODE>GSSException.UNAVAILABLE</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#NO_CONTEXT"><CODE>GSSException.NO_CONTEXT</CODE></A>,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSManager.html#createContext(byte[])"><CODE>GSSManager.createContext(byte[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="requestMutualAuth(boolean)"><!-- --></A><H3>
requestMutualAuth</H3>
<PRE>
void <B>requestMutualAuth</B>(boolean&nbsp;state)
                       throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Requests that mutual authentication be done during
 context establishment. This request can only be made on the context
 initiator's side and it has to be done prior to the first call to
 <code>initSecContext</code>.<p>

 Not all mechanisms support mutual authentication and some mechanisms
 might require mutual authentication even if the application
 doesn't. Therefore, the application should check to see if the
 request was honored with the <A HREF="../../../org/ietf/jgss/GSSContext.html#getMutualAuthState()"><CODE>getMutualAuthState</CODE></A> method.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>state</CODE> - a boolean value indicating whether mutual
 authentication shouls be used or not.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getMutualAuthState()"><CODE>getMutualAuthState()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="requestReplayDet(boolean)"><!-- --></A><H3>
requestReplayDet</H3>
<PRE>
void <B>requestReplayDet</B>(boolean&nbsp;state)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Requests that replay detection be enabled for the
 per-message security services after context establishemnt. This
 request can only be made on the context initiator's side and it has
 to be done prior to the first call to
 <code>initSecContext</code>. During context establishment replay
 detection is not an option and is a function of the underlying
 mechanism's capabilities.<p>

 Not all mechanisms support replay detection and some mechanisms
 might require replay detection even if the application
 doesn't. Therefore, the application should check to see if the
 request was honored with the <A HREF="../../../org/ietf/jgss/GSSContext.html#getReplayDetState()"><CODE>getReplayDetState</CODE></A> method. If replay detection is enabled then the
 <A HREF="../../../org/ietf/jgss/MessageProp.html#isDuplicateToken()"><CODE>MessageProp.isDuplicateToken</CODE></A> and <A HREF="../../../org/ietf/jgss/MessageProp.html#isOldToken()"><CODE>MessageProp.isOldToken</CODE></A> methods will return 
 valid results for the <code>MessageProp</code> object that is passed
 in to the <code>unwrap</code> method or the <code>verifyMIC</code>
 method.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>state</CODE> - a boolean value indicating whether replay detection
 should be enabled over the established context or not.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getReplayDetState()"><CODE>getReplayDetState()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="requestSequenceDet(boolean)"><!-- --></A><H3>
requestSequenceDet</H3>
<PRE>
void <B>requestSequenceDet</B>(boolean&nbsp;state)
                        throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Requests that sequence checking be enabled for the
 per-message security services after context establishemnt. This
 request can only be made on the context initiator's side and it has
 to be done prior to the first call to
 <code>initSecContext</code>. During context establishment sequence
 checking is not an option and is a function of the underlying
 mechanism's capabilities.<p>

 Not all mechanisms support sequence checking and some mechanisms
 might require sequence checking even if the application
 doesn't. Therefore, the application should check to see if the
 request was honored with the <A HREF="../../../org/ietf/jgss/GSSContext.html#getSequenceDetState()"><CODE>getSequenceDetState</CODE></A> method. If sequence checking is enabled then the
 <A HREF="../../../org/ietf/jgss/MessageProp.html#isDuplicateToken()"><CODE>MessageProp.isDuplicateToken</CODE></A>, 
 <A HREF="../../../org/ietf/jgss/MessageProp.html#isOldToken()"><CODE>MessageProp.isOldToken</CODE></A>,
 <A HREF="../../../org/ietf/jgss/MessageProp.html#isUnseqToken()"><CODE>MessageProp.isUnseqToken</CODE></A>, and
 <A HREF="../../../org/ietf/jgss/MessageProp.html#isGapToken()"><CODE>MessageProp.isGapToken</CODE></A> methods will return
 valid results for the <code>MessageProp</code> object that is passed
 in to the <code>unwrap</code> method or the <code>verifyMIC</code>
 method.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>state</CODE> - a boolean value indicating whether sequence checking
 should be enabled over the established context or not.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getSequenceDetState()"><CODE>getSequenceDetState()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="requestCredDeleg(boolean)"><!-- --></A><H3>
requestCredDeleg</H3>
<PRE>
void <B>requestCredDeleg</B>(boolean&nbsp;state)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Requests that the initiator's credentials be
 delegated to the acceptor during context establishment. This
 request can only be made on the context initiator's side and it has
 to be done prior to the first call to
 <code>initSecContext</code>.

 Not all mechanisms support credential delegation. Therefore, an
 application that desires delegation should check to see if the
 request was honored with the <A HREF="../../../org/ietf/jgss/GSSContext.html#getCredDelegState()"><CODE>getCredDelegState</CODE></A> method. If the application indicates that
 delegation must not be used, then the mechanism will honor the
 request and delegation will not occur. This is an exception
 to the general rule that a mechanism may enable a service even if it 
 is not requested.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>state</CODE> - a boolean value indicating whether the credentials
 should be delegated or not.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getCredDelegState()"><CODE>getCredDelegState()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="requestAnonymity(boolean)"><!-- --></A><H3>
requestAnonymity</H3>
<PRE>
void <B>requestAnonymity</B>(boolean&nbsp;state)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Requests that the initiator's identity not be
 disclosed to the acceptor. This request can only be made on the
 context initiator's side and it has to be done prior to the first
 call to <code>initSecContext</code>.

 Not all mechanisms support anonymity for the initiator. Therefore, the
 application should check to see if the request was honored with the
 <A HREF="../../../org/ietf/jgss/GSSContext.html#getAnonymityState()"><CODE>getAnonymityState</CODE></A> method.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>state</CODE> - a boolean value indicating if the initiator should 
 be authenticated to the acceptor as an anonymous principal.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getAnonymityState()"><CODE>getAnonymityState()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="requestConf(boolean)"><!-- --></A><H3>
requestConf</H3>
<PRE>
void <B>requestConf</B>(boolean&nbsp;state)
                 throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Requests that data confidentiality be enabled
 for the <code>wrap</code> method. This request can only be made on
 the context initiator's side and it has to be done prior to the
 first call to <code>initSecContext</code>.

 Not all mechanisms support confidentiality and other mechanisms
 might enable it even if the application doesn't request
 it. The application may check to see if the request was honored with
 the <A HREF="../../../org/ietf/jgss/GSSContext.html#getConfState()"><CODE>getConfState</CODE></A> method. If confidentiality
 is enabled, only then will the mechanism honor a request for privacy 
 in the <A HREF="../../../org/ietf/jgss/MessageProp.html#MessageProp(int, boolean)"><CODE>MessageProp</CODE></A>
 object that is passed in to the <code>wrap</code> method.<p>

 Enabling confidentiality will also automatically enable
 integrity.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>state</CODE> - a boolean value indicating whether confidentiality
 should be enabled or not.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getConfState()"><CODE>getConfState()</CODE></A>, 
<A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()"><CODE>getIntegState()</CODE></A>, 
<A HREF="../../../org/ietf/jgss/GSSContext.html#requestInteg(boolean)"><CODE>requestInteg(boolean)</CODE></A>, 
<A HREF="../../../org/ietf/jgss/MessageProp.html" title="class in org.ietf.jgss"><CODE>MessageProp</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="requestInteg(boolean)"><!-- --></A><H3>
requestInteg</H3>
<PRE>
void <B>requestInteg</B>(boolean&nbsp;state)
                  throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Requests that data integrity be enabled
 for the <code>wrap</code> and <code>getMIC</code>methods. This
 request can only be made on the context initiator's side and it has
 to be done prior to the first call to <code>initSecContext</code>.

 Not all mechanisms support integrity and other mechanisms
 might enable it even if the application doesn't request
 it. The application may check to see if the request was honored with
 the <A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()"><CODE>getIntegState</CODE></A> method.<p>

 Disabling integrity will also automatically disable
 confidentiality.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>state</CODE> - a boolean value indicating whether integrity
 should be enabled or not.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()"><CODE>getIntegState()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="requestLifetime(int)"><!-- --></A><H3>
requestLifetime</H3>
<PRE>
void <B>requestLifetime</B>(int&nbsp;lifetime)
                     throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Requests a lifetime in seconds for the
 context. This method can only be called on the context initiator's
 side  and it has to be done prior to the first call to
 <code>initSecContext</code>.<p>

 The actual lifetime of the context will depend on the capabilites of 
 the underlying mechanism and the application should call the <A HREF="../../../org/ietf/jgss/GSSContext.html#getLifetime()"><CODE>getLifetime</CODE></A> method to determine this.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lifetime</CODE> - the desired context lifetime in seconds. Use
 <code>INDEFINITE_LIFETIME</code> to request an indefinite lifetime
 and <code>DEFAULT_LIFETIME</code> to request a default lifetime.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getLifetime()"><CODE>getLifetime()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setChannelBinding(org.ietf.jgss.ChannelBinding)"><!-- --></A><H3>
setChannelBinding</H3>
<PRE>
void <B>setChannelBinding</B>(<A HREF="../../../org/ietf/jgss/ChannelBinding.html" title="class in org.ietf.jgss">ChannelBinding</A>&nbsp;cb)
                       throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Sets the channel bindings to be used during context
 establishment. This method can be called on both
 the context initiator's and the context acceptor's side, but it must 
 be called before context establishment begins. This means that an
 initiator must call it before the first call to
 <code>initSecContext</code> and the acceptor must call it before the 
 first call to <code>acceptSecContext</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cb</CODE> - the channel bindings to use.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCredDelegState()"><!-- --></A><H3>
getCredDelegState</H3>
<PRE>
boolean <B>getCredDelegState</B>()</PRE>
<DL>
<DD>Determines if credential delegation is enabled on
 this context. It can be called by both the context initiator and the 
 context acceptor. For a definitive answer this method must be
 called only after context establishment is complete. Note that if an 
 initiator requests that delegation not be allowed the <A HREF="../../../org/ietf/jgss/GSSContext.html#requestCredDeleg(boolean)"><CODE>requestCredDeleg</CODE></A> method will honor that
 request and this method will return <code>false</code> on the 
 initiator's side from that point onwards. <p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if delegation is enabled, false otherwise.<DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestCredDeleg(boolean)"><CODE>requestCredDeleg(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMutualAuthState()"><!-- --></A><H3>
getMutualAuthState</H3>
<PRE>
boolean <B>getMutualAuthState</B>()</PRE>
<DL>
<DD>Determines if mutual authentication is enabled on
 this context. It can be called by both the context initiator and the 
 context acceptor. For a definitive answer this method must be
 called only after context establishment is complete. An initiator
 that requests mutual authentication can call this method after
 context completion and dispose the context if its request was not
 honored.<p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if mutual authentication is enabled, false otherwise.<DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestMutualAuth(boolean)"><CODE>requestMutualAuth(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getReplayDetState()"><!-- --></A><H3>
getReplayDetState</H3>
<PRE>
boolean <B>getReplayDetState</B>()</PRE>
<DL>
<DD>Determines if replay detection is enabled for the
 per-message security services from this context. It can be called by
 both the context initiator and the context acceptor. For a
 definitive answer this method must be called only after context
 establishment is complete. An initiator that requests replay
 detection can call this method after context completion and
 dispose the context if its request was not honored.<p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if replay detection is enabled, false otherwise.<DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestReplayDet(boolean)"><CODE>requestReplayDet(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getSequenceDetState()"><!-- --></A><H3>
getSequenceDetState</H3>
<PRE>
boolean <B>getSequenceDetState</B>()</PRE>
<DL>
<DD>Determines if sequence checking is enabled for the
 per-message security services from this context. It can be called by
 both the context initiator and the context acceptor. For a
 definitive answer this method must be called only after context
 establishment is complete. An initiator that requests sequence
 checking can call this method after context completion and
 dispose the context if its request was not honored.<p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if sequence checking is enabled, false otherwise.<DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestSequenceDet(boolean)"><CODE>requestSequenceDet(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAnonymityState()"><!-- --></A><H3>
getAnonymityState</H3>
<PRE>
boolean <B>getAnonymityState</B>()</PRE>
<DL>
<DD>Determines if the context initiator is
 anonymously authenticated to the context acceptor. It can be called by
 both the context initiator and the context acceptor, and at any
 time. <strong>On the initiator side, a call to this method determines
 if the identity of the initiator has been disclosed in any of the
 context establishment tokens that might have been generated thus far 
 by <code>initSecContext</code>. An initiator that absolutely must be
 authenticated anonymously should call this method after each call to 
 <code>initSecContext</code> to determine if the generated token
 should be sent to the peer or the context aborted.</strong> On the
 acceptor side, a call to this method determines if any of the tokens 
 processed by <code>acceptSecContext</code> thus far have divulged
 the identity of the initiator.<p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if the context initiator is still anonymous, false
 otherwise.<DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestAnonymity(boolean)"><CODE>requestAnonymity(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isTransferable()"><!-- --></A><H3>
isTransferable</H3>
<PRE>
boolean <B>isTransferable</B>()
                       throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Determines if the context is transferable to other processes
 through the use of the <A HREF="../../../org/ietf/jgss/GSSContext.html#export()"><CODE>export</CODE></A> method.  This call
 is only valid on fully established contexts.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if this context can be exported, false otherwise.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isProtReady()"><!-- --></A><H3>
isProtReady</H3>
<PRE>
boolean <B>isProtReady</B>()</PRE>
<DL>
<DD>Determines if the context is ready for per message operations to be
 used over it.  Some mechanisms may allow the usage of the
 per-message operations before the context is fully established.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if methods like <code>wrap</code>, <code>unwrap</code>, 
 <code>getMIC</code>, and <code>verifyMIC</code> can be used with
 this context at the current stage of context establishment, false
 otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="getConfState()"><!-- --></A><H3>
getConfState</H3>
<PRE>
boolean <B>getConfState</B>()</PRE>
<DL>
<DD>Determines if data confidentiality is available
 over the context. This method can be called by both the context
 initiator and the context acceptor, but only after one of <A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A> or <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> return <code>true</code>. If this method returns
 <code>true</code>, so will <A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()"><CODE>getIntegState</CODE></A><p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if confidentiality services are available, false
 otherwise.<DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestConf(boolean)"><CODE>requestConf(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getIntegState()"><!-- --></A><H3>
getIntegState</H3>
<PRE>
boolean <B>getIntegState</B>()</PRE>
<DL>
<DD>Determines if data integrity is available
 over the context. This method can be called by both the context
 initiator and the context acceptor, but only after one of <A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A> or <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> return <code>true</code>. This method will always
 return <code>true</code> if <A HREF="../../../org/ietf/jgss/GSSContext.html#getConfState()"><CODE>getConfState</CODE></A>
 returns true.<p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if integrity services are available, false otherwise.<DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestInteg(boolean)"><CODE>requestInteg(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLifetime()"><!-- --></A><H3>
getLifetime</H3>
<PRE>
int <B>getLifetime</B>()</PRE>
<DL>
<DD>Determines what the remaining lifetime for this
 context is. It can be called by both the context initiator and the
 context acceptor, but for a definitive answer it should be called
 only after <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> returns
 true.<p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the remaining lifetime in seconds<DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestLifetime(int)"><CODE>requestLifetime(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getSrcName()"><!-- --></A><H3>
getSrcName</H3>
<PRE>
<A HREF="../../../org/ietf/jgss/GSSName.html" title="interface in org.ietf.jgss">GSSName</A> <B>getSrcName</B>()
                   throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Returns the name of the context initiator. This call is valid only
 after one of <A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A> or <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> return <code>true</code>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a GSSName that is an MN containing the name of the context
 initiator.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../org/ietf/jgss/GSSName.html" title="interface in org.ietf.jgss"><CODE>GSSName</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTargName()"><!-- --></A><H3>
getTargName</H3>
<PRE>
<A HREF="../../../org/ietf/jgss/GSSName.html" title="interface in org.ietf.jgss">GSSName</A> <B>getTargName</B>()
                    throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Returns the name of the context acceptor. This call is valid only
 after one of <A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A> or <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> return <code>true</code>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a GSSName that is an MN containing the name of the context
 acceptor.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMech()"><!-- --></A><H3>
getMech</H3>
<PRE>
<A HREF="../../../org/ietf/jgss/Oid.html" title="class in org.ietf.jgss">Oid</A> <B>getMech</B>()
            throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Determines what mechanism is being used for this
 context. This method may be called before the context is fully
 established, but the mechanism returned may change on successive
 calls in the negotiated mechanism case.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the Oid of the mechanism being used
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDelegCred()"><!-- --></A><H3>
getDelegCred</H3>
<PRE>
<A HREF="../../../org/ietf/jgss/GSSCredential.html" title="interface in org.ietf.jgss">GSSCredential</A> <B>getDelegCred</B>()
                           throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Obtains the credentials delegated by the context
 initiator to the context acceptor. It should be called only on the
 context acceptor's side, and once the context is fully
 established. The caller can use the method <A HREF="../../../org/ietf/jgss/GSSContext.html#getCredDelegState()"><CODE>getCredDelegState</CODE></A> to determine if there are
 any delegated credentials.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a GSSCredential containing the initiator's delegated
 credentials, or <code>null</code> is no credentials
 were delegated.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isInitiator()"><!-- --></A><H3>
isInitiator</H3>
<PRE>
boolean <B>isInitiator</B>()
                    throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></PRE>
<DL>
<DD>Determines if this is the context initiator. This
 can be called on both the context initiator's and context acceptor's
 side.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if this is the context initiator, false if it is the
 context acceptor.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="class in org.ietf.jgss">GSSException</A></CODE> - containing the following 
 major error codes: 
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GSSContext.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/ietf/jgss/ChannelBinding.html" title="class in org.ietf.jgss"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/ietf/jgss/GSSCredential.html" title="interface in org.ietf.jgss"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/ietf/jgss/GSSContext.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GSSContext.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">Submit a bug or feature</a><br>For further API reference and developer documentation, see <a href="../../../../relnotes/devdocs-vs-specs.html">Java 2 SDK SE Developer Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples. <p>Copyright &#169; 2004, 2010 Oracle and/or its affiliates. All rights reserved. Use is subject to <a href="../../../../relnotes/license.html">license terms</a>. Also see the <a href="http://java.sun.com/docs/redist.html">documentation redistribution policy</a>.</font>
<!-- Start SiteCatalyst code   -->
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code_download.js"></script>
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code.js"></script>
 
<!-- ********** DO NOT ALTER ANYTHING BELOW THIS LINE ! *********** -->
<!--  Below code will send the info to Omniture server -->
<script language="javascript">var s_code=s.t();if(s_code)document.write(s_code)</script>
 
<!-- End SiteCatalyst code -->
</body>
</HTML>
