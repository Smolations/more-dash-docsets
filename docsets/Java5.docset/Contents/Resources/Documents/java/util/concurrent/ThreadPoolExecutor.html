<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<meta name="collection" content="api">
<!-- Generated by javadoc (build 1.5.0-rc) on Wed Aug 11 07:23:29 PDT 2004 -->
<TITLE>
ThreadPoolExecutor (Java 2 Platform SE 5.0)
</TITLE>

<META NAME="keywords" CONTENT="java.util.concurrent.ThreadPoolExecutor class">
<META NAME="keywords" CONTENT="execute()">
<META NAME="keywords" CONTENT="shutdown()">
<META NAME="keywords" CONTENT="shutdownNow()">
<META NAME="keywords" CONTENT="isShutdown()">
<META NAME="keywords" CONTENT="isTerminating()">
<META NAME="keywords" CONTENT="isTerminated()">
<META NAME="keywords" CONTENT="awaitTermination()">
<META NAME="keywords" CONTENT="finalize()">
<META NAME="keywords" CONTENT="setThreadFactory()">
<META NAME="keywords" CONTENT="getThreadFactory()">
<META NAME="keywords" CONTENT="setRejectedExecutionHandler()">
<META NAME="keywords" CONTENT="getRejectedExecutionHandler()">
<META NAME="keywords" CONTENT="getQueue()">
<META NAME="keywords" CONTENT="remove()">
<META NAME="keywords" CONTENT="purge()">
<META NAME="keywords" CONTENT="setCorePoolSize()">
<META NAME="keywords" CONTENT="getCorePoolSize()">
<META NAME="keywords" CONTENT="prestartCoreThread()">
<META NAME="keywords" CONTENT="prestartAllCoreThreads()">
<META NAME="keywords" CONTENT="setMaximumPoolSize()">
<META NAME="keywords" CONTENT="getMaximumPoolSize()">
<META NAME="keywords" CONTENT="setKeepAliveTime()">
<META NAME="keywords" CONTENT="getKeepAliveTime()">
<META NAME="keywords" CONTENT="getPoolSize()">
<META NAME="keywords" CONTENT="getActiveCount()">
<META NAME="keywords" CONTENT="getLargestPoolSize()">
<META NAME="keywords" CONTENT="getTaskCount()">
<META NAME="keywords" CONTENT="getCompletedTaskCount()">
<META NAME="keywords" CONTENT="beforeExecute()">
<META NAME="keywords" CONTENT="afterExecute()">
<META NAME="keywords" CONTENT="terminated()">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ThreadPoolExecutor (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ThreadPoolExecutor.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="class in java.util.concurrent"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/concurrent/ThreadPoolExecutor.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ThreadPoolExecutor.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent</FONT>
<BR>
Class ThreadPoolExecutor</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">java.util.concurrent.AbstractExecutorService</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>java.util.concurrent.ThreadPoolExecutor</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../java/util/concurrent/Executor.html" title="interface in java.util.concurrent">Executor</A>, <A HREF="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</A></DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="class in java.util.concurrent">ScheduledThreadPoolExecutor</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>ThreadPoolExecutor</B><DT>extends <A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</A></DL>
</PRE>

<P>
An <A HREF="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent"><CODE>ExecutorService</CODE></A> that executes each submitted task using
 one of possibly several pooled threads, normally configured
 using <A HREF="../../../java/util/concurrent/Executors.html" title="class in java.util.concurrent"><CODE>Executors</CODE></A> factory methods.

 <p>Thread pools address two different problems: they usually
 provide improved performance when executing large numbers of
 asynchronous tasks, due to reduced per-task invocation overhead,
 and they provide a means of bounding and managing the resources,
 including threads, consumed when executing a collection of tasks.
 Each <tt>ThreadPoolExecutor</tt> also maintains some basic
 statistics, such as the number of completed tasks.

 <p>To be useful across a wide range of contexts, this class
 provides many adjustable parameters and extensibility
 hooks. However, programmers are urged to use the more convenient
 <A HREF="../../../java/util/concurrent/Executors.html" title="class in java.util.concurrent"><CODE>Executors</CODE></A> factory methods <A HREF="../../../java/util/concurrent/Executors.html#newCachedThreadPool()"><CODE>Executors.newCachedThreadPool()</CODE></A> (unbounded thread pool, with
 automatic thread reclamation), <A HREF="../../../java/util/concurrent/Executors.html#newFixedThreadPool(int)"><CODE>Executors.newFixedThreadPool(int)</CODE></A>
 (fixed size thread pool) and <A HREF="../../../java/util/concurrent/Executors.html#newSingleThreadExecutor()"><CODE>Executors.newSingleThreadExecutor()</CODE></A> (single background thread), that
 preconfigure settings for the most common usage
 scenarios. Otherwise, use the following guide when manually
 configuring and tuning this class:

 <dl>

 <dt>Core and maximum pool sizes</dt>

 <dd>A <tt>ThreadPoolExecutor</tt> will automatically adjust the
 pool size 
 (see <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getPoolSize()"><CODE>getPoolSize()</CODE></A>)
 according to the bounds set by corePoolSize 
 (see <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()"><CODE>getCorePoolSize()</CODE></A>)
 and
 maximumPoolSize
 (see <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()"><CODE>getMaximumPoolSize()</CODE></A>).
 When a new task is submitted in method <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)"><CODE>execute(java.lang.Runnable)</CODE></A>, and fewer than corePoolSize threads
 are running, a new thread is created to handle the request, even if
 other worker threads are idle.  If there are more than
 corePoolSize but less than maximumPoolSize threads running, a new
 thread will be created only if the queue is full.  By setting
 corePoolSize and maximumPoolSize the same, you create a fixed-size
 thread pool. By setting maximumPoolSize to an essentially unbounded
 value such as <tt>Integer.MAX_VALUE</tt>, you allow the pool to
 accommodate an arbitrary number of concurrent tasks. Most typically,
 core and maximum pool sizes are set only upon construction, but they
 may also be changed dynamically using <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)"><CODE>setCorePoolSize(int)</CODE></A> and <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)"><CODE>setMaximumPoolSize(int)</CODE></A>. <dd>

 <dt> On-demand construction

 <dd> By default, even core threads are initially created and
 started only when needed by new tasks, but this can be overridden
 dynamically using method <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartCoreThread()"><CODE>prestartCoreThread()</CODE></A> or
 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartAllCoreThreads()"><CODE>prestartAllCoreThreads()</CODE></A>.  </dd>

 <dt>Creating new threads</dt>

 <dd>New threads are created using a <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent"><CODE>ThreadFactory</CODE></A>.  If not otherwise specified, a
 <A HREF="../../../java/util/concurrent/Executors.html#defaultThreadFactory()"><CODE>Executors.defaultThreadFactory()</CODE></A> is used, that creates threads to all
 be in the same <A HREF="../../../java/lang/ThreadGroup.html" title="class in java.lang"><CODE>ThreadGroup</CODE></A> and with the same
 <tt>NORM_PRIORITY</tt> priority and non-daemon status. By supplying
 a different ThreadFactory, you can alter the thread's name, thread
 group, priority, daemon status, etc. If a <tt>ThreadFactory</tt> fails to create
 a thread when asked by returning null from <tt>newThread</tt>, 
 the executor will continue, but might
 not be able to execute any tasks. </dd>

 <dt>Keep-alive times</dt>

 <dd>If the pool currently has more than corePoolSize threads,
 excess threads will be terminated if they have been idle for more
 than the keepAliveTime (see <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)"><CODE>getKeepAliveTime(java.util.concurrent.TimeUnit)</CODE></A>). This provides a means of
 reducing resource consumption when the pool is not being actively
 used. If the pool becomes more active later, new threads will be
 constructed. This parameter can also be changed dynamically
 using method <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)"><CODE>setKeepAliveTime(long, java.util.concurrent.TimeUnit)</CODE></A>. Using
 a value of <tt>Long.MAX_VALUE</tt> <A HREF="../../../java/util/concurrent/TimeUnit.html#NANOSECONDS"><CODE>TimeUnit.NANOSECONDS</CODE></A>
 effectively disables idle threads from ever terminating prior
 to shut down.
 </dd>

 <dt>Queuing</dt>

 <dd>Any <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent"><CODE>BlockingQueue</CODE></A> may be used to transfer and hold
 submitted tasks.  The use of this queue interacts with pool sizing:

 <ul>

 <li> If fewer than corePoolSize threads are running, the Executor
 always prefers adding a new thread
 rather than queuing.</li>

 <li> If corePoolSize or more threads are running, the Executor
 always prefers queuing a request rather than adding a new
 thread.</li>
 
 <li> If a request cannot be queued, a new thread is created unless
 this would exceed maximumPoolSize, in which case, the task will be
 rejected.</li>

 </ul>

 There are three general strategies for queuing:
 <ol>

 <li> <em> Direct handoffs.</em> A good default choice for a work
 queue is a <A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="class in java.util.concurrent"><CODE>SynchronousQueue</CODE></A> that hands off tasks to threads
 without otherwise holding them. Here, an attempt to queue a task
 will fail if no threads are immediately available to run it, so a
 new thread will be constructed. This policy avoids lockups when
 handling sets of requests that might have internal dependencies.
 Direct handoffs generally require unbounded maximumPoolSizes to
 avoid rejection of new submitted tasks. This in turn admits the
 possibility of unbounded thread growth when commands continue to
 arrive on average faster than they can be processed.  </li>

 <li><em> Unbounded queues.</em> Using an unbounded queue (for
 example a <A HREF="../../../java/util/concurrent/LinkedBlockingQueue.html" title="class in java.util.concurrent"><CODE>LinkedBlockingQueue</CODE></A> without a predefined
 capacity) will cause new tasks to be queued in cases where all
 corePoolSize threads are busy. Thus, no more than corePoolSize
 threads will ever be created. (And the value of the maximumPoolSize
 therefore doesn't have any effect.)  This may be appropriate when
 each task is completely independent of others, so tasks cannot
 affect each others execution; for example, in a web page server.
 While this style of queuing can be useful in smoothing out
 transient bursts of requests, it admits the possibility of
 unbounded work queue growth when commands continue to arrive on
 average faster than they can be processed.  </li>

 <li><em>Bounded queues.</em> A bounded queue (for example, an
 <A HREF="../../../java/util/concurrent/ArrayBlockingQueue.html" title="class in java.util.concurrent"><CODE>ArrayBlockingQueue</CODE></A>) helps prevent resource exhaustion when
 used with finite maximumPoolSizes, but can be more difficult to
 tune and control.  Queue sizes and maximum pool sizes may be traded
 off for each other: Using large queues and small pools minimizes
 CPU usage, OS resources, and context-switching overhead, but can
 lead to artificially low throughput.  If tasks frequently block (for
 example if they are I/O bound), a system may be able to schedule
 time for more threads than you otherwise allow. Use of small queues
 generally requires larger pool sizes, which keeps CPUs busier but
 may encounter unacceptable scheduling overhead, which also
 decreases throughput.  </li>

 </ol>

 </dd>

 <dt>Rejected tasks</dt>

 <dd> New tasks submitted in method <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)"><CODE>execute(java.lang.Runnable)</CODE></A> will be <em>rejected</em> when the
 Executor has been shut down, and also when the Executor uses finite
 bounds for both maximum threads and work queue capacity, and is
 saturated.  In either case, the <tt>execute</tt> method invokes the
 <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html#rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)"><CODE>RejectedExecutionHandler.rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)</CODE></A> method of its
 <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent"><CODE>RejectedExecutionHandler</CODE></A>.  Four predefined handler policies
 are provided:

 <ol>

 <li> In the
 default <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="class in java.util.concurrent"><CODE>ThreadPoolExecutor.AbortPolicy</CODE></A>, the handler throws a
 runtime <A HREF="../../../java/util/concurrent/RejectedExecutionException.html" title="class in java.util.concurrent"><CODE>RejectedExecutionException</CODE></A> upon rejection. </li>
 
 <li> In <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="class in java.util.concurrent"><CODE>ThreadPoolExecutor.CallerRunsPolicy</CODE></A>, the thread that invokes
 <tt>execute</tt> itself runs the task. This provides a simple
 feedback control mechanism that will slow down the rate that new
 tasks are submitted. </li>

 <li> In <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="class in java.util.concurrent"><CODE>ThreadPoolExecutor.DiscardPolicy</CODE></A>,
 a task that cannot be executed is simply dropped.  </li>

 <li>In <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="class in java.util.concurrent"><CODE>ThreadPoolExecutor.DiscardOldestPolicy</CODE></A>, if the executor is not
 shut down, the task at the head of the work queue is dropped, and
 then execution is retried (which can fail again, causing this to be
 repeated.) </li>

 </ol>

 It is possible to define and use other kinds of <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent"><CODE>RejectedExecutionHandler</CODE></A> classes. Doing so requires some care
 especially when policies are designed to work only under particular
 capacity or queuing policies. </dd>

 <dt>Hook methods</dt>

 <dd>This class provides <tt>protected</tt> overridable <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#beforeExecute(java.lang.Thread, java.lang.Runnable)"><CODE>beforeExecute(java.lang.Thread, java.lang.Runnable)</CODE></A> and <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable, java.lang.Throwable)"><CODE>afterExecute(java.lang.Runnable, java.lang.Throwable)</CODE></A> methods that are called before and
 after execution of each task.  These can be used to manipulate the
 execution environment; for example, reinitializing ThreadLocals,
 gathering statistics, or adding log entries. Additionally, method
 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#terminated()"><CODE>terminated()</CODE></A> can be overridden to perform
 any special processing that needs to be done once the Executor has
 fully terminated. 

 <p>If hook or callback methods throw 
 exceptions, internal worker threads may in turn fail and
 abruptly terminate.</dd> 

 <dt>Queue maintenance</dt>

 <dd> Method <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getQueue()"><CODE>getQueue()</CODE></A> allows access to
 the work queue for purposes of monitoring and debugging.  Use of
 this method for any other purpose is strongly discouraged.  Two
 supplied methods, <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#remove(java.lang.Runnable)"><CODE>remove(java.lang.Runnable)</CODE></A> and <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#purge()"><CODE>purge()</CODE></A> are available to assist in storage
 reclamation when large numbers of queued tasks become
 cancelled.</dd> </dl>

 <p> <b>Extension example</b>. Most extensions of this class
 override one or more of the protected hook methods. For example,
 here is a subclass that adds a simple pause/resume feature:

 <pre>
 class PausableThreadPoolExecutor extends ThreadPoolExecutor {
   private boolean isPaused;
   private ReentrantLock pauseLock = new ReentrantLock();
   private Condition unpaused = pauseLock.newCondition();

   public PausableThreadPoolExecutor(...) { super(...); }
 
   protected void beforeExecute(Thread t, Runnable r) {
     super.beforeExecute(t, r);
     pauseLock.lock();
     try {
       while (isPaused) unpaused.await();
     } catch(InterruptedException ie) {
       t.interrupt();
     } finally {
       pauseLock.unlock();
     }
   }
 
   public void pause() {
     pauseLock.lock();
     try {
       isPaused = true;
     } finally {
       pauseLock.unlock();
     }
   }
 
   public void resume() {
     pauseLock.lock();
     try {
       isPaused = false;
       unpaused.signalAll();
     } finally {
       pauseLock.unlock();
     }
   }
 }
 </pre>
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.5</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="class in java.util.concurrent">ThreadPoolExecutor.AbortPolicy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A handler for rejected tasks that throws a
 <tt>RejectedExecutionException</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="class in java.util.concurrent">ThreadPoolExecutor.CallerRunsPolicy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A handler for rejected tasks that runs the rejected task
 directly in the calling thread of the <tt>execute</tt> method,
 unless the executor has been shut down, in which case the task
 is discarded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="class in java.util.concurrent">ThreadPoolExecutor.DiscardOldestPolicy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A handler for rejected tasks that discards the oldest unhandled
 request and then retries <tt>execute</tt>, unless the executor
 is shut down, in which case the task is discarded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="class in java.util.concurrent">ThreadPoolExecutor.DiscardPolicy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A handler for rejected tasks that silently discards the
 rejected task.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue)">ThreadPoolExecutor</A></B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&gt;&nbsp;workQueue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <tt>ThreadPoolExecutor</tt> with the given
 initial parameters and default thread factory and handler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.RejectedExecutionHandler)">ThreadPoolExecutor</A></B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&gt;&nbsp;workQueue,
                   <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</A>&nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <tt>ThreadPoolExecutor</tt> with the given initial
 parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory)">ThreadPoolExecutor</A></B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&gt;&nbsp;workQueue,
                   <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</A>&nbsp;threadFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <tt>ThreadPoolExecutor</tt> with the given initial
 parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)">ThreadPoolExecutor</A></B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&gt;&nbsp;workQueue,
                   <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</A>&nbsp;threadFactory,
                   <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</A>&nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <tt>ThreadPoolExecutor</tt> with the given initial
 parameters.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable, java.lang.Throwable)">afterExecute</A></B>(<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&nbsp;r,
             <A HREF="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method invoked upon completion of execution of the given
 Runnable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#awaitTermination(long, java.util.concurrent.TimeUnit)">awaitTermination</A></B>(long&nbsp;timeout,
                 <A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blocks until all tasks have completed execution after a shutdown
 request, or the timeout occurs, or the current thread is
 interrupted, whichever happens first.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#beforeExecute(java.lang.Thread, java.lang.Runnable)">beforeExecute</A></B>(<A HREF="../../../java/lang/Thread.html" title="class in java.lang">Thread</A>&nbsp;t,
              <A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method invoked prior to executing the given Runnable in the
 given thread.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)">execute</A></B>(<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&nbsp;command)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes the given task sometime in the future.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#finalize()">finalize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invokes <tt>shutdown</tt> when this executor is no longer
 referenced.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getActiveCount()">getActiveCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the approximate number of threads that are actively
 executing tasks.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCompletedTaskCount()">getCompletedTaskCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the approximate total number of tasks that have
 completed execution.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()">getCorePoolSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the core number of threads.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)">getKeepAliveTime</A></B>(<A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the thread keep-alive time, which is the amount of time
 which threads in excess of the core pool size may remain
 idle before being terminated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getLargestPoolSize()">getLargestPoolSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the largest number of threads that have ever
 simultaneously been in the pool.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()">getMaximumPoolSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the maximum allowed number of threads.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getPoolSize()">getPoolSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current number of threads in the pool.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getQueue()">getQueue</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the task queue used by this executor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getRejectedExecutionHandler()">getRejectedExecutionHandler</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current handler for unexecutable tasks.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getTaskCount()">getTaskCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the approximate total number of tasks that have been
 scheduled for execution.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getThreadFactory()">getThreadFactory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the thread factory used to create new threads.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#isShutdown()">isShutdown</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this executor has been shut down.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#isTerminated()">isTerminated</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if all tasks have completed following shut down.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#isTerminating()">isTerminating</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if this executor is in the process of terminating
 after <tt>shutdown</tt> or <tt>shutdownNow</tt> but has not
 completely terminated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartAllCoreThreads()">prestartAllCoreThreads</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Starts all core threads, causing them to idly wait for work.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartCoreThread()">prestartCoreThread</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Starts a core thread, causing it to idly wait for work.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#purge()">purge</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tries to remove from the work queue all <A HREF="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent"><CODE>Future</CODE></A>
 tasks that have been cancelled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#remove(java.lang.Runnable)">remove</A></B>(<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&nbsp;task)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes this task from the executor's internal queue if it is
 present, thus causing it not to be run if it has not already
 started.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)">setCorePoolSize</A></B>(int&nbsp;corePoolSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the core number of threads.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)">setKeepAliveTime</A></B>(long&nbsp;time,
                 <A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the time limit for which threads may remain idle before
 being terminated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)">setMaximumPoolSize</A></B>(int&nbsp;maximumPoolSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the maximum allowed number of threads.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)">setRejectedExecutionHandler</A></B>(<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</A>&nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a new handler for unexecutable tasks.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setThreadFactory(java.util.concurrent.ThreadFactory)">setThreadFactory</A></B>(<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</A>&nbsp;threadFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the thread factory used to create new threads.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdown()">shutdown</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initiates an orderly shutdown in which previously submitted
 tasks are executed, but no new tasks will be
 accepted.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/List.html" title="interface in java.util">List</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdownNow()">shutdownNow</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to stop all actively executing tasks, halts the
 processing of waiting tasks, and returns a list of the tasks that were
 awaiting execution.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#terminated()">terminated</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method invoked when the Executor has terminated.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.concurrent.AbstractExecutorService"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.util.concurrent.<A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAll(java.util.Collection)">invokeAll</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAll(java.util.Collection, long, java.util.concurrent.TimeUnit)">invokeAll</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAny(java.util.Collection)">invokeAny</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAny(java.util.Collection, long, java.util.concurrent.TimeUnit)">invokeAny</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#submit(java.util.concurrent.Callable)">submit</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#submit(java.lang.Runnable)">submit</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#submit(java.lang.Runnable, T)">submit</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="../../../java/lang/Object.html" title="class in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue)"><!-- --></A><H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&gt;&nbsp;workQueue)</PRE>
<DL>
<DD>Creates a new <tt>ThreadPoolExecutor</tt> with the given
 initial parameters and default thread factory and handler.  It
 may be more convenient to use one of the <A HREF="../../../java/util/concurrent/Executors.html" title="class in java.util.concurrent"><CODE>Executors</CODE></A>
 factory methods instead of this general purpose constructor.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>corePoolSize</CODE> - the number of threads to keep in the
 pool, even if they are idle.<DD><CODE>maximumPoolSize</CODE> - the maximum number of threads to allow in the
 pool.<DD><CODE>keepAliveTime</CODE> - when the number of threads is greater than
 the core, this is the maximum time that excess idle threads
 will wait for new tasks before terminating.<DD><CODE>unit</CODE> - the time unit for the keepAliveTime
 argument.<DD><CODE>workQueue</CODE> - the queue to use for holding tasks before they
 are executed. This queue will hold only the <tt>Runnable</tt>
 tasks submitted by the <tt>execute</tt> method.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - if corePoolSize, or
 keepAliveTime less than zero, or if maximumPoolSize less than or
 equal to zero, or if corePoolSize greater than maximumPoolSize.
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</A></CODE> - if <tt>workQueue</tt> is null</DL>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory)"><!-- --></A><H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&gt;&nbsp;workQueue,
                          <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</A>&nbsp;threadFactory)</PRE>
<DL>
<DD>Creates a new <tt>ThreadPoolExecutor</tt> with the given initial
 parameters.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>corePoolSize</CODE> - the number of threads to keep in the
 pool, even if they are idle.<DD><CODE>maximumPoolSize</CODE> - the maximum number of threads to allow in the
 pool.<DD><CODE>keepAliveTime</CODE> - when the number of threads is greater than
 the core, this is the maximum time that excess idle threads
 will wait for new tasks before terminating.<DD><CODE>unit</CODE> - the time unit for the keepAliveTime
 argument.<DD><CODE>workQueue</CODE> - the queue to use for holding tasks before they
 are executed. This queue will hold only the <tt>Runnable</tt>
 tasks submitted by the <tt>execute</tt> method.<DD><CODE>threadFactory</CODE> - the factory to use when the executor
 creates a new thread.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - if corePoolSize, or
 keepAliveTime less than zero, or if maximumPoolSize less than or
 equal to zero, or if corePoolSize greater than maximumPoolSize.
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</A></CODE> - if <tt>workQueue</tt>
 or <tt>threadFactory</tt> are null.</DL>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.RejectedExecutionHandler)"><!-- --></A><H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&gt;&nbsp;workQueue,
                          <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</A>&nbsp;handler)</PRE>
<DL>
<DD>Creates a new <tt>ThreadPoolExecutor</tt> with the given initial
 parameters.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>corePoolSize</CODE> - the number of threads to keep in the
 pool, even if they are idle.<DD><CODE>maximumPoolSize</CODE> - the maximum number of threads to allow in the
 pool.<DD><CODE>keepAliveTime</CODE> - when the number of threads is greater than
 the core, this is the maximum time that excess idle threads
 will wait for new tasks before terminating.<DD><CODE>unit</CODE> - the time unit for the keepAliveTime
 argument.<DD><CODE>workQueue</CODE> - the queue to use for holding tasks before they
 are executed. This queue will hold only the <tt>Runnable</tt>
 tasks submitted by the <tt>execute</tt> method.<DD><CODE>handler</CODE> - the handler to use when execution is blocked
 because the thread bounds and queue capacities are reached.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - if corePoolSize, or
 keepAliveTime less than zero, or if maximumPoolSize less than or
 equal to zero, or if corePoolSize greater than maximumPoolSize.
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</A></CODE> - if <tt>workQueue</tt>
 or  <tt>handler</tt> are null.</DL>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)"><!-- --></A><H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&gt;&nbsp;workQueue,
                          <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</A>&nbsp;threadFactory,
                          <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</A>&nbsp;handler)</PRE>
<DL>
<DD>Creates a new <tt>ThreadPoolExecutor</tt> with the given initial
 parameters.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>corePoolSize</CODE> - the number of threads to keep in the
 pool, even if they are idle.<DD><CODE>maximumPoolSize</CODE> - the maximum number of threads to allow in the
 pool.<DD><CODE>keepAliveTime</CODE> - when the number of threads is greater than
 the core, this is the maximum time that excess idle threads
 will wait for new tasks before terminating.<DD><CODE>unit</CODE> - the time unit for the keepAliveTime
 argument.<DD><CODE>workQueue</CODE> - the queue to use for holding tasks before they
 are executed. This queue will hold only the <tt>Runnable</tt>
 tasks submitted by the <tt>execute</tt> method.<DD><CODE>threadFactory</CODE> - the factory to use when the executor
 creates a new thread.<DD><CODE>handler</CODE> - the handler to use when execution is blocked
 because the thread bounds and queue capacities are reached.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - if corePoolSize, or
 keepAliveTime less than zero, or if maximumPoolSize less than or
 equal to zero, or if corePoolSize greater than maximumPoolSize.
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</A></CODE> - if <tt>workQueue</tt>
 or <tt>threadFactory</tt> or <tt>handler</tt> are null.</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="execute(java.lang.Runnable)"><!-- --></A><H3>
execute</H3>
<PRE>
public void <B>execute</B>(<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&nbsp;command)</PRE>
<DL>
<DD>Executes the given task sometime in the future.  The task
 may execute in a new thread or in an existing pooled thread.

 If the task cannot be submitted for execution, either because this
 executor has been shutdown or because its capacity has been reached,
 the task is handled by the current <tt>RejectedExecutionHandler</tt>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>command</CODE> - the task to execute
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/util/concurrent/RejectedExecutionException.html" title="class in java.util.concurrent">RejectedExecutionException</A></CODE> - at discretion of
 <tt>RejectedExecutionHandler</tt>, if task cannot be accepted
 for execution
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</A></CODE> - if command is null</DL>
</DD>
</DL>
<HR>

<A NAME="shutdown()"><!-- --></A><H3>
shutdown</H3>
<PRE>
public void <B>shutdown</B>()</PRE>
<DL>
<DD>Initiates an orderly shutdown in which previously submitted
 tasks are executed, but no new tasks will be
 accepted. Invocation has no additional effect if already shut
 down.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</A></CODE> - if a security manager exists and
 shutting down this ExecutorService may manipulate threads that
 the caller is not permitted to modify because it does not hold
 <A HREF="../../../java/lang/RuntimePermission.html" title="class in java.lang"><CODE>RuntimePermission</CODE></A><tt>("modifyThread")</tt>,
 or the security manager's <tt>checkAccess</tt>  method denies access.</DL>
</DD>
</DL>
<HR>

<A NAME="shutdownNow()"><!-- --></A><H3>
shutdownNow</H3>
<PRE>
public <A HREF="../../../java/util/List.html" title="interface in java.util">List</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&gt; <B>shutdownNow</B>()</PRE>
<DL>
<DD>Attempts to stop all actively executing tasks, halts the
 processing of waiting tasks, and returns a list of the tasks that were
 awaiting execution. 
  
 <p>This implementation cancels tasks via <A HREF="../../../java/lang/Thread.html#interrupt()"><CODE>Thread.interrupt()</CODE></A>, so if any tasks mask or fail to respond to
 interrupts, they may never terminate.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>list of tasks that never commenced execution
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</A></CODE> - if a security manager exists and
 shutting down this ExecutorService may manipulate threads that
 the caller is not permitted to modify because it does not hold
 <A HREF="../../../java/lang/RuntimePermission.html" title="class in java.lang"><CODE>RuntimePermission</CODE></A><tt>("modifyThread")</tt>,
 or the security manager's <tt>checkAccess</tt> method denies access.</DL>
</DD>
</DL>
<HR>

<A NAME="isShutdown()"><!-- --></A><H3>
isShutdown</H3>
<PRE>
public boolean <B>isShutdown</B>()</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../java/util/concurrent/ExecutorService.html#isShutdown()">ExecutorService</A></CODE></B></DD>
<DD>Returns <tt>true</tt> if this executor has been shut down.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><tt>true</tt> if this executor has been shut down</DL>
</DD>
</DL>
<HR>

<A NAME="isTerminating()"><!-- --></A><H3>
isTerminating</H3>
<PRE>
public boolean <B>isTerminating</B>()</PRE>
<DL>
<DD>Returns true if this executor is in the process of terminating
 after <tt>shutdown</tt> or <tt>shutdownNow</tt> but has not
 completely terminated.  This method may be useful for
 debugging. A return of <tt>true</tt> reported a sufficient
 period after shutdown may indicate that submitted tasks have
 ignored or suppressed interruption, causing this executor not
 to properly terminate.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if terminating but not yet terminated.</DL>
</DD>
</DL>
<HR>

<A NAME="isTerminated()"><!-- --></A><H3>
isTerminated</H3>
<PRE>
public boolean <B>isTerminated</B>()</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../java/util/concurrent/ExecutorService.html#isTerminated()">ExecutorService</A></CODE></B></DD>
<DD>Returns <tt>true</tt> if all tasks have completed following shut down.
 Note that <tt>isTerminated</tt> is never <tt>true</tt> unless
 either <tt>shutdown</tt> or <tt>shutdownNow</tt> was called first.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><tt>true</tt> if all tasks have completed following shut down</DL>
</DD>
</DL>
<HR>

<A NAME="awaitTermination(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
awaitTermination</H3>
<PRE>
public boolean <B>awaitTermination</B>(long&nbsp;timeout,
                                <A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit)
                         throws <A HREF="../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</A></PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../java/util/concurrent/ExecutorService.html#awaitTermination(long, java.util.concurrent.TimeUnit)">ExecutorService</A></CODE></B></DD>
<DD>Blocks until all tasks have completed execution after a shutdown
 request, or the timeout occurs, or the current thread is
 interrupted, whichever happens first.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - the maximum time to wait<DD><CODE>unit</CODE> - the time unit of the timeout argument
<DT><B>Returns:</B><DD><tt>true</tt> if this executor terminated and <tt>false</tt>
 if the timeout elapsed before termination
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</A></CODE> - if interrupted while waiting</DL>
</DD>
</DL>
<HR>

<A NAME="finalize()"><!-- --></A><H3>
finalize</H3>
<PRE>
protected void <B>finalize</B>()</PRE>
<DL>
<DD>Invokes <tt>shutdown</tt> when this executor is no longer
 referenced.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../java/lang/Object.html#finalize()">finalize</A></CODE> in class <CODE><A HREF="../../../java/lang/Object.html" title="class in java.lang">Object</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setThreadFactory(java.util.concurrent.ThreadFactory)"><!-- --></A><H3>
setThreadFactory</H3>
<PRE>
public void <B>setThreadFactory</B>(<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</A>&nbsp;threadFactory)</PRE>
<DL>
<DD>Sets the thread factory used to create new threads.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>threadFactory</CODE> - the new thread factory
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</A></CODE> - if threadFactory is null<DT><B>See Also:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getThreadFactory()"><CODE>getThreadFactory()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getThreadFactory()"><!-- --></A><H3>
getThreadFactory</H3>
<PRE>
public <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</A> <B>getThreadFactory</B>()</PRE>
<DL>
<DD>Returns the thread factory used to create new threads.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current thread factory<DT><B>See Also:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setThreadFactory(java.util.concurrent.ThreadFactory)"><CODE>setThreadFactory(java.util.concurrent.ThreadFactory)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)"><!-- --></A><H3>
setRejectedExecutionHandler</H3>
<PRE>
public void <B>setRejectedExecutionHandler</B>(<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</A>&nbsp;handler)</PRE>
<DL>
<DD>Sets a new handler for unexecutable tasks.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>handler</CODE> - the new handler
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</A></CODE> - if handler is null<DT><B>See Also:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getRejectedExecutionHandler()"><CODE>getRejectedExecutionHandler()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getRejectedExecutionHandler()"><!-- --></A><H3>
getRejectedExecutionHandler</H3>
<PRE>
public <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</A> <B>getRejectedExecutionHandler</B>()</PRE>
<DL>
<DD>Returns the current handler for unexecutable tasks.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current handler<DT><B>See Also:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)"><CODE>setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getQueue()"><!-- --></A><H3>
getQueue</H3>
<PRE>
public <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&gt; <B>getQueue</B>()</PRE>
<DL>
<DD>Returns the task queue used by this executor. Access to the
 task queue is intended primarily for debugging and monitoring.
 This queue may be in active use.  Retrieving the task queue
 does not prevent queued tasks from executing.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the task queue</DL>
</DD>
</DL>
<HR>

<A NAME="remove(java.lang.Runnable)"><!-- --></A><H3>
remove</H3>
<PRE>
public boolean <B>remove</B>(<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&nbsp;task)</PRE>
<DL>
<DD>Removes this task from the executor's internal queue if it is
 present, thus causing it not to be run if it has not already
 started.
 
 <p> This method may be useful as one part of a cancellation
 scheme.  It may fail to remove tasks that have been converted
 into other forms before being placed on the internal queue. For
 example, a task entered using <tt>submit</tt> might be
 converted into a form that maintains <tt>Future</tt> status.
 However, in such cases, method <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#purge()"><CODE>purge()</CODE></A>
 may be used to remove those Futures that have been cancelled.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>task</CODE> - the task to remove
<DT><B>Returns:</B><DD>true if the task was removed</DL>
</DD>
</DL>
<HR>

<A NAME="purge()"><!-- --></A><H3>
purge</H3>
<PRE>
public void <B>purge</B>()</PRE>
<DL>
<DD>Tries to remove from the work queue all <A HREF="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent"><CODE>Future</CODE></A>
 tasks that have been cancelled. This method can be useful as a
 storage reclamation operation, that has no other impact on
 functionality. Cancelled tasks are never executed, but may
 accumulate in work queues until worker threads can actively
 remove them. Invoking this method instead tries to remove them now.
 However, this method may fail to remove tasks in
 the presence of interference by other threads.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCorePoolSize(int)"><!-- --></A><H3>
setCorePoolSize</H3>
<PRE>
public void <B>setCorePoolSize</B>(int&nbsp;corePoolSize)</PRE>
<DL>
<DD>Sets the core number of threads.  This overrides any value set
 in the constructor.  If the new value is smaller than the
 current value, excess existing threads will be terminated when
 they next become idle. If larger, new threads will, if needed,
 be started to execute any queued tasks.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>corePoolSize</CODE> - the new core size
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - if <tt>corePoolSize</tt>
 less than zero<DT><B>See Also:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()"><CODE>getCorePoolSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCorePoolSize()"><!-- --></A><H3>
getCorePoolSize</H3>
<PRE>
public int <B>getCorePoolSize</B>()</PRE>
<DL>
<DD>Returns the core number of threads.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the core number of threads<DT><B>See Also:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)"><CODE>setCorePoolSize(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="prestartCoreThread()"><!-- --></A><H3>
prestartCoreThread</H3>
<PRE>
public boolean <B>prestartCoreThread</B>()</PRE>
<DL>
<DD>Starts a core thread, causing it to idly wait for work. This
 overrides the default policy of starting core threads only when
 new tasks are executed. This method will return <tt>false</tt>
 if all core threads have already been started.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if a thread was started</DL>
</DD>
</DL>
<HR>

<A NAME="prestartAllCoreThreads()"><!-- --></A><H3>
prestartAllCoreThreads</H3>
<PRE>
public int <B>prestartAllCoreThreads</B>()</PRE>
<DL>
<DD>Starts all core threads, causing them to idly wait for work. This
 overrides the default policy of starting core threads only when
 new tasks are executed.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the number of threads started.</DL>
</DD>
</DL>
<HR>

<A NAME="setMaximumPoolSize(int)"><!-- --></A><H3>
setMaximumPoolSize</H3>
<PRE>
public void <B>setMaximumPoolSize</B>(int&nbsp;maximumPoolSize)</PRE>
<DL>
<DD>Sets the maximum allowed number of threads. This overrides any
 value set in the constructor. If the new value is smaller than
 the current value, excess existing threads will be
 terminated when they next become idle.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>maximumPoolSize</CODE> - the new maximum
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - if maximumPoolSize less than zero or
 the <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()"><CODE>core pool size</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()"><CODE>getMaximumPoolSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumPoolSize()"><!-- --></A><H3>
getMaximumPoolSize</H3>
<PRE>
public int <B>getMaximumPoolSize</B>()</PRE>
<DL>
<DD>Returns the maximum allowed number of threads.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the maximum allowed number of threads<DT><B>See Also:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)"><CODE>setMaximumPoolSize(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setKeepAliveTime(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
setKeepAliveTime</H3>
<PRE>
public void <B>setKeepAliveTime</B>(long&nbsp;time,
                             <A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit)</PRE>
<DL>
<DD>Sets the time limit for which threads may remain idle before
 being terminated.  If there are more than the core number of
 threads currently in the pool, after waiting this amount of
 time without processing a task, excess threads will be
 terminated.  This overrides any value set in the constructor.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the time to wait.  A time value of zero will cause
 excess threads to terminate immediately after executing tasks.<DD><CODE>unit</CODE> - the time unit of the time argument
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - if time less than zero<DT><B>See Also:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)"><CODE>getKeepAliveTime(java.util.concurrent.TimeUnit)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getKeepAliveTime(java.util.concurrent.TimeUnit)"><!-- --></A><H3>
getKeepAliveTime</H3>
<PRE>
public long <B>getKeepAliveTime</B>(<A HREF="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</A>&nbsp;unit)</PRE>
<DL>
<DD>Returns the thread keep-alive time, which is the amount of time
 which threads in excess of the core pool size may remain
 idle before being terminated.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>unit</CODE> - the desired time unit of the result
<DT><B>Returns:</B><DD>the time limit<DT><B>See Also:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)"><CODE>setKeepAliveTime(long, java.util.concurrent.TimeUnit)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPoolSize()"><!-- --></A><H3>
getPoolSize</H3>
<PRE>
public int <B>getPoolSize</B>()</PRE>
<DL>
<DD>Returns the current number of threads in the pool.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the number of threads</DL>
</DD>
</DL>
<HR>

<A NAME="getActiveCount()"><!-- --></A><H3>
getActiveCount</H3>
<PRE>
public int <B>getActiveCount</B>()</PRE>
<DL>
<DD>Returns the approximate number of threads that are actively
 executing tasks.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the number of threads</DL>
</DD>
</DL>
<HR>

<A NAME="getLargestPoolSize()"><!-- --></A><H3>
getLargestPoolSize</H3>
<PRE>
public int <B>getLargestPoolSize</B>()</PRE>
<DL>
<DD>Returns the largest number of threads that have ever
 simultaneously been in the pool.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the number of threads</DL>
</DD>
</DL>
<HR>

<A NAME="getTaskCount()"><!-- --></A><H3>
getTaskCount</H3>
<PRE>
public long <B>getTaskCount</B>()</PRE>
<DL>
<DD>Returns the approximate total number of tasks that have been
 scheduled for execution. Because the states of tasks and
 threads may change dynamically during computation, the returned
 value is only an approximation, but one that does not ever
 decrease across successive calls.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the number of tasks</DL>
</DD>
</DL>
<HR>

<A NAME="getCompletedTaskCount()"><!-- --></A><H3>
getCompletedTaskCount</H3>
<PRE>
public long <B>getCompletedTaskCount</B>()</PRE>
<DL>
<DD>Returns the approximate total number of tasks that have
 completed execution. Because the states of tasks and threads
 may change dynamically during computation, the returned value
 is only an approximation, but one that does not ever decrease
 across successive calls.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the number of tasks</DL>
</DD>
</DL>
<HR>

<A NAME="beforeExecute(java.lang.Thread, java.lang.Runnable)"><!-- --></A><H3>
beforeExecute</H3>
<PRE>
protected void <B>beforeExecute</B>(<A HREF="../../../java/lang/Thread.html" title="class in java.lang">Thread</A>&nbsp;t,
                             <A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&nbsp;r)</PRE>
<DL>
<DD>Method invoked prior to executing the given Runnable in the
 given thread.  This method is invoked by thread <tt>t</tt> that
 will execute task <tt>r</tt>, and may be used to re-initialize
 ThreadLocals, or to perform logging. Note: To properly nest
 multiple overridings, subclasses should generally invoke
 <tt>super.beforeExecute</tt> at the end of this method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t</CODE> - the thread that will run task r.<DD><CODE>r</CODE> - the task that will be executed.</DL>
</DD>
</DL>
<HR>

<A NAME="afterExecute(java.lang.Runnable, java.lang.Throwable)"><!-- --></A><H3>
afterExecute</H3>
<PRE>
protected void <B>afterExecute</B>(<A HREF="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</A>&nbsp;r,
                            <A HREF="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</A>&nbsp;t)</PRE>
<DL>
<DD>Method invoked upon completion of execution of the given
 Runnable.  This method is invoked by the thread that executed
 the task. If non-null, the Throwable is the uncaught exception
 that caused execution to terminate abruptly. Note: To properly
 nest multiple overridings, subclasses should generally invoke
 <tt>super.afterExecute</tt> at the beginning of this method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>r</CODE> - the runnable that has completed.<DD><CODE>t</CODE> - the exception that caused termination, or null if
 execution completed normally.</DL>
</DD>
</DL>
<HR>

<A NAME="terminated()"><!-- --></A><H3>
terminated</H3>
<PRE>
protected void <B>terminated</B>()</PRE>
<DL>
<DD>Method invoked when the Executor has terminated.  Default
 implementation does nothing. Note: To properly nest multiple
 overridings, subclasses should generally invoke
 <tt>super.terminated</tt> within this method.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ThreadPoolExecutor.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="class in java.util.concurrent"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/concurrent/ThreadPoolExecutor.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ThreadPoolExecutor.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">Submit a bug or feature</a><br>For further API reference and developer documentation, see <a href="../../../../relnotes/devdocs-vs-specs.html">Java 2 SDK SE Developer Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples. <p>Copyright &#169; 2004, 2010 Oracle and/or its affiliates. All rights reserved. Use is subject to <a href="../../../../relnotes/license.html">license terms</a>. Also see the <a href="http://java.sun.com/docs/redist.html">documentation redistribution policy</a>.</font>
<!-- Start SiteCatalyst code   -->
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code_download.js"></script>
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code.js"></script>
 
<!-- ********** DO NOT ALTER ANYTHING BELOW THIS LINE ! *********** -->
<!--  Below code will send the info to Omniture server -->
<script language="javascript">var s_code=s.t();if(s_code)document.write(s_code)</script>
 
<!-- End SiteCatalyst code -->
</body>
</HTML>
