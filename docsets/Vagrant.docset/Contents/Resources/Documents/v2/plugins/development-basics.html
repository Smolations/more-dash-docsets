<!DOCTYPE html><html><head><title> Plugin Development Basics - Plugins - Vagrant Documentation</title><meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link href="./../../stylesheets/bootstrap-2bdef9a2.css" media=screen rel=stylesheet /><link href="./../../stylesheets/vagrantup-d5d54c59.css" media=screen rel=stylesheet /><script src="./../../javascripts/jquery-08c11650.js"></script><script src="./../../javascripts/modernizr-84c0465a.js"></script><script src="./../../javascripts/bootstrap.min-98cc7a22.js"></script><script src="./../../javascripts/backstretch-3d1212ad.js"></script><script src="./../../javascripts/vagrantup-03aae2a8.js"></script><link href='//fonts.googleapis.com/css?family=Inconsolata' rel=stylesheet><script src="//use.typekit.net/xfs6zus.js"></script><script>try{Typekit.load();}catch(e){}</script></head><body><div class=wrapper><nav class=docs><a class=vagrant-docs-logo href="/">Vagrant Documentation</a><ul class="pull-right unstyled"><li><a href="//www.vagrantup.com/">Home</a></li></ul></nav><div class="page docs docs-home"><div class=container><div class=row><div class="sidebar span3"><aside class=sidebar-nav><div class="toggle hidden-desktop"><div class="open-close open"></div><a href="#">Contents</a></div><ul class=unstyled><li><a href="./../../v2/">Overview</a></li><li><a href="./../../v2/why-vagrant/index.html">Why Vagrant?</a></li><li><a href="./../../v2/installation/index.html">Installation</a></li><li><a href="./../../v2/getting-started/index.html">Getting Started</a></li><li><a href="./../../v2/cli/index.html">Command-Line Interface</a></li><li><a href="./../../v2/vagrantfile/index.html">Vagrantfile</a></li><li><a href="./../../v2/boxes.html">Boxes</a></li><li><a href="./../../v2/provisioning/index.html">Provisioning</a></li><li><a href="./../../v2/networking/index.html">Networking</a></li><li><a href="./../../v2/synced-folders/index.html">Synced Folders</a></li><li><a href="./../../v2/multi-machine/index.html">Multi-Machine</a></li><li><a href="./../../v2/providers/index.html">Providers</a></li><li><a href="./../../v2/virtualbox/index.html">VirtualBox</a></li><li><a href="./../../v2/vmware/index.html">VMware</a></li><li class=current><a href="./../../v2/plugins/index.html">Plugins</a></li><ul class="sub unstyled"><li><a href="./../../v2/plugins/usage.html">Usage</a></li><li class=current><a href="./../../v2/plugins/development-basics.html">Plugin Development Basics</a></li><li><a href="./../../v2/plugins/commands.html">Commands</a></li><li><a href="./../../v2/plugins/configuration.html">Configuration</a></li><li><a href="./../../v2/plugins/guests.html">Guests</a></li><li><a href="./../../v2/plugins/guest-capabilities.html">Guest Capabilities</a></li><li><a href="./../../v2/plugins/hosts.html">Hosts</a></li><li><a href="./../../v2/plugins/providers.html">Providers</a></li><li><a href="./../../v2/plugins/provisioners.html">Provisioners</a></li><li><a href="./../../v2/plugins/packaging.html">Packaging & Distribution</a></li></ul><li><a href="./../../v2/debugging.html">Debugging</a></li></ul></aside></div><div class="page-contents span9"><div class=page-background></div><div class=row><div class="span8 offset1"><h1>Plugin Development Basics</h1><p>Plugins are a great way to augment or change the behavior and functionality of Vagrant. Since plugins introduce additional external dependencies for users, they should be used as a last resort when attempting to do something with Vagrant.</p><p>But if you need to introduce custom behaviors into Vagrant, plugins are the best way, since they are safe against future upgrades and use a stable API.</p><div class="alert alert-warn"><p><strong>Warning: Advanced Topic!</strong> Developing plugins is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Ruby should approach. </p></div><p>Plugins are written using <a href="//www.ruby-lang.org/en/">Ruby</a> and are packaged using <a href="//rubygems.org/">RubyGems</a>. Familiarity with Ruby is required, but the <a href="#">packaging and distribution</a> section should help guide you to packaging your plugin into a RubyGem.</p><h2>Plugin Definition</h2><p>All plugins are required to have a definition. A definition contains details about the plugin such as the name of it and what components it contains.</p><p>A definition at the bare minimum looks like the following:</p><pre><code class="ruby">class MyPlugin &lt; Vagrant.plugin(&quot;2&quot;)
  name &quot;My Plugin&quot;
end
</code></pre><p>A definition is a class that inherits from <code>Vagrant.plugin(&quot;2&quot;)</code>. The &quot;2&quot; there is the version that the plugin is valid for. API stability is only promised for each major version of Vagrant, so this is important. (The 1.x series is working towards 2.0, so the API version is &quot;2&quot;)</p><p><strong>The most critical feature of a plugin definition</strong> is that it must <em>always</em> load, no matter what version of Vagrant is running. Theoretically, Vagrant version 87 (doesn&#39;t actually exist) would be able to load a version 2 plugin definition. This is achieved through clever lazy loading of individual components of the plugin, and is covered shortly.</p><h2>Plugin Components</h2><p>Within the definition, a plugin advertises what components it adds to Vagrant. An example is shown below where a command and provisioner are added:</p><pre><code>class MyPlugin &lt; Vagrant.plugin(&quot;2&quot;)
  name &quot;My Plugin&quot;

  command &quot;run-my-plugin&quot; do
    require_relative &quot;command&quot;
    Command
  end

  provisioner &quot;my-provisioner&quot; do
    require_relative &quot;provisioner&quot;
    Provisioner
  end
end
</code></pre><p>Let&#39;s go over the major pieces of what is going on here. Note from a general Ruby language perspective the above <em>should</em> be familiar. The syntax should not scare you. If it does, then please familiarize with Ruby further before attempting to write a plugin.</p><p>The first thing to note is that individual components are defined by making a method call with the component name, such as <code>command</code> or <code>provisioner</code>. These in turn take some parameters. In the case of our example it is just the name of the command and the name of the provisioner. All component definitions then take a block argument (a callback) that must return the actual component implementation class.</p><p>The block argument is where the &quot;clever lazy loading&quot; (mentioned above) comes into play. The component blocks should lazy load the actual file that contains the implementation of the component, and then return that component.</p><p>This is done because the actual dependencies and APIs used when defining components are not stable across major Vagrant versions. A command implementation written for Vagrant 2.0 will not be compatible with Vagrant 3.0 and so on. But the <em>definition</em> is just plain Ruby that must always be forward compatible to future Vagrant versions.</p><p>To repeat, <strong>the lazy loading aspect of plugin components is critical</strong> to the way Vagrant plugins work. All components must be lazily loaded and returned within their definition blocks.</p><p>Now, each component has a different API. Please visit the relevant section using the navigation to the left under &quot;Plugins&quot; to learn more about developing each type of component.</p><h2>Error Handling</h2><p>One of Vagrant&#39;s biggest strength is gracefully handling errors and reporting them in human-readable ways. Vagrant has always strongly believed that if a user sees a stack trace, it is a bug. It is expected that plugins will behave the same way, and Vagrant provides strong error handling mechanisms to assist with this.</p><p>Error handling in Vagrant is done entirely by raising Ruby exceptions. But Vagrant treats certain errors differently than others. If an error is raised that inherits from <code>Vagrant::Errors::VagrantError</code>, then the <code>vagrant</code> command will output the message of the error in nice red text to the console and exit with an exit status of 1.</p><p>Otherwise, Vagrant reports an &quot;unexpected error&quot; that should be reported as a bug, and shows a full stack trace and other ugliness. Any stack traces should be considered bugs.</p><p>Therefore, to fit into Vagrant&#39;s error handling mechanisms, subclass <code>VagrantError</code> and set a proper message on your exception. To see examples of this, look at Vagrant&#39;s <a href="https://github.com/mitchellh/vagrant/blob/master/lib/vagrant/errors.rb">built-in errors</a>.</p><h2>Console Input and Output</h2><p>Most plugins are likely going to want to do some sort of input/output. Plugins should <em>never</em> use Ruby&#39;s built-in <code>puts</code> or <code>gets</code> style methods. Instead, all input/output should go through some sort of Vagrant UI object. The Vagrant UI object properly handles cases where there is no TTY, output pipes are closed, there is no input pipe, etc.</p><p>A UI object is available on every <code>Vagrant::Environment</code> via the <code>ui</code> property and is exposed within every middleware environment via the <code>:ui</code> key. UI objects have <a href="https://github.com/mitchellh/vagrant/blob/master/lib/vagrant/ui.rb">decent documentation</a> within the comments of their source.</p></div></div></div></div></div></div><footer><div class=container><div class=row><div class=span12><ul class="unstyled footer-nav"><li><a href="//docs.vagrantup.com/">Documentation</a></li><li><a href="//www.vagrantup.com/about">About</a></li><li><a href="//www.vagrantup.com/support">Support</a></li><a href="//downloads.vagrantup.com/"><li class="button inline-button">Download</li></a></ul><ul class="unstyled logos"><a href="//www.vagrantup.com"><li class=vagrant-logo-monochrome></li></a><li><span>by</span></li><a href="//www.hashicorp.com"><li class="hashi-logo-monochrome "></li></a></ul></div></div><div class=row><h6 class=legal> &#169; 2013 HashiCorp </h6></div></div></footer></div><script>
			$(".big-background").backstretch("assets/photos/full_width.jpg");
		</script></body></html>
