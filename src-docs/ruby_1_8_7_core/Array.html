<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.24.6  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <meta content="2013-08-24 23:19:56 -0700" http-equiv="change-date" />
  <!-- rel_prefix  = ''  ENV['RDOC_FOR_WEBSITE']   = false-->
    
    <!-- WHY? -->
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = ''  --> 
  <title>Class: Array (Ruby 1.8.7) </title>
  <!-- link rel="stylesheet" href=".css/obf.css"  -->
  <link rel="stylesheet" href="css/inuit.css" >
  <link rel="stylesheet" href="css/grid.inuit.css" >
  <link rel="stylesheet" href="css/2011.css" type="text/css" >
  <link rel="stylesheet" href="css/rdoc.css" type="text/css" >

  <script src="/js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="/js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

</head>

<body id="top" class="class rdocstar">
<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'></ul>
</div>
<span id='vulns-alert'></span>
</div> <!-- end action bar -->
 <div class='wrapper'>
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>array.c</li>      
            
          
          <li class='in-file'>pack.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-5B-5D">::[]</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-i-26">#&</a></li>
          
          <li><a href="#method-i-2A">#*</a></li>
          
          <li><a href="#method-i-2B">#+</a></li>
          
          <li><a href="#method-i-2D">#-</a></li>
          
          <li><a href="#method-i-3C-3C">#<<</a></li>
          
          <li><a href="#method-i-3C-3D-3E">#<=></a></li>
          
          <li><a href="#method-i-3D-3D">#==</a></li>
          
          <li><a href="#method-i-5B-5D">#[]</a></li>
          
          <li><a href="#method-i-5B-5D-3D">#[]=</a></li>
          
          <li><a href="#method-i-assoc">#assoc</a></li>
          
          <li><a href="#method-i-at">#at</a></li>
          
          <li><a href="#method-i-choice">#choice</a></li>
          
          <li><a href="#method-i-clear">#clear</a></li>
          
          <li><a href="#method-i-collect">#collect</a></li>
          
          <li><a href="#method-i-collect-21">#collect!</a></li>
          
          <li><a href="#method-i-combination">#combination</a></li>
          
          <li><a href="#method-i-compact">#compact</a></li>
          
          <li><a href="#method-i-compact-21">#compact!</a></li>
          
          <li><a href="#method-i-concat">#concat</a></li>
          
          <li><a href="#method-i-count">#count</a></li>
          
          <li><a href="#method-i-cycle">#cycle</a></li>
          
          <li><a href="#method-i-delete">#delete</a></li>
          
          <li><a href="#method-i-delete_at">#delete_at</a></li>
          
          <li><a href="#method-i-delete_if">#delete_if</a></li>
          
          <li><a href="#method-i-drop">#drop</a></li>
          
          <li><a href="#method-i-drop_while">#drop_while</a></li>
          
          <li><a href="#method-i-each">#each</a></li>
          
          <li><a href="#method-i-each_index">#each_index</a></li>
          
          <li><a href="#method-i-empty-3F">#empty?</a></li>
          
          <li><a href="#method-i-eql-3F">#eql?</a></li>
          
          <li><a href="#method-i-fetch">#fetch</a></li>
          
          <li><a href="#method-i-fill">#fill</a></li>
          
          <li><a href="#method-i-find_index">#find_index</a></li>
          
          <li><a href="#method-i-first">#first</a></li>
          
          <li><a href="#method-i-flatten">#flatten</a></li>
          
          <li><a href="#method-i-flatten-21">#flatten!</a></li>
          
          <li><a href="#method-i-frozen-3F">#frozen?</a></li>
          
          <li><a href="#method-i-hash">#hash</a></li>
          
          <li><a href="#method-i-include-3F">#include?</a></li>
          
          <li><a href="#method-i-index">#index</a></li>
          
          <li><a href="#method-i-indexes">#indexes</a></li>
          
          <li><a href="#method-i-indices">#indices</a></li>
          
          <li><a href="#method-i-initialize_copy">#initialize_copy</a></li>
          
          <li><a href="#method-i-insert">#insert</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-join">#join</a></li>
          
          <li><a href="#method-i-last">#last</a></li>
          
          <li><a href="#method-i-length">#length</a></li>
          
          <li><a href="#method-i-map">#map</a></li>
          
          <li><a href="#method-i-map-21">#map!</a></li>
          
          <li><a href="#method-i-nitems">#nitems</a></li>
          
          <li><a href="#method-i-pack">#pack</a></li>
          
          <li><a href="#method-i-permutation">#permutation</a></li>
          
          <li><a href="#method-i-pop">#pop</a></li>
          
          <li><a href="#method-i-product">#product</a></li>
          
          <li><a href="#method-i-push">#push</a></li>
          
          <li><a href="#method-i-rassoc">#rassoc</a></li>
          
          <li><a href="#method-i-reject">#reject</a></li>
          
          <li><a href="#method-i-reject-21">#reject!</a></li>
          
          <li><a href="#method-i-replace">#replace</a></li>
          
          <li><a href="#method-i-reverse">#reverse</a></li>
          
          <li><a href="#method-i-reverse-21">#reverse!</a></li>
          
          <li><a href="#method-i-reverse_each">#reverse_each</a></li>
          
          <li><a href="#method-i-rindex">#rindex</a></li>
          
          <li><a href="#method-i-select">#select</a></li>
          
          <li><a href="#method-i-shift">#shift</a></li>
          
          <li><a href="#method-i-shuffle">#shuffle</a></li>
          
          <li><a href="#method-i-shuffle-21">#shuffle!</a></li>
          
          <li><a href="#method-i-size">#size</a></li>
          
          <li><a href="#method-i-slice">#slice</a></li>
          
          <li><a href="#method-i-slice-21">#slice!</a></li>
          
          <li><a href="#method-i-sort">#sort</a></li>
          
          <li><a href="#method-i-sort-21">#sort!</a></li>
          
          <li><a href="#method-i-take">#take</a></li>
          
          <li><a href="#method-i-take_while">#take_while</a></li>
          
          <li><a href="#method-i-to_a">#to_a</a></li>
          
          <li><a href="#method-i-to_ary">#to_ary</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-transpose">#transpose</a></li>
          
          <li><a href="#method-i-uniq">#uniq</a></li>
          
          <li><a href="#method-i-uniq-21">#uniq!</a></li>
          
          <li><a href="#method-i-unshift">#unshift</a></li>
          
          <li><a href="#method-i-values_at">#values_at</a></li>
          
          <li><a href="#method-i-zip">#zip</a></li>
          
          <li><a href="#method-i-7C">#|</a></li>
          
        </ul>
      </div>
      

      
      <!-- Included Modules -->
      <div id="includes-section" class="section">
        <h3 class="section-header">Included Modules</h3>
        <ul class="link-list">
        
        
          <li><a class="include" href="Enumerable.html">Enumerable</a></li>
        
        
        </ul>
      </div>
      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="./ArgumentError.html">ArgumentError</a></li>
        
          
          
          <li><a href="./Array.html">Array</a></li>
        
          
          
          <li><a href="./Bignum.html">Bignum</a></li>
        
          
          
          <li><a href="./Binding.html">Binding</a></li>
        
          
          
          <li><a href="./Class.html">Class</a></li>
        
          
          
          <li><a href="./Comparable.html">Comparable</a></li>
        
          
          
          <li><a href="./Continuation.html">Continuation</a></li>
        
          
          
          <li><a href="./Data.html">Data</a></li>
        
          
          
          <li><a href="./Dir.html">Dir</a></li>
        
          
          
          <li><a href="./EOFError.html">EOFError</a></li>
        
          
          
          <li><a href="./Enumerable.html">Enumerable</a></li>
        
          
          
          <li><a href="./Enumerable/Enumerator.html">Enumerable::Enumerator</a></li>
        
          
          
          <li><a href="./Errno.html">Errno</a></li>
        
          
          
          <li><a href="./Exception.html">Exception</a></li>
        
          
          
          <li><a href="./FalseClass.html">FalseClass</a></li>
        
          
          
          <li><a href="./File.html">File</a></li>
        
          
          
          <li><a href="./File/Constants.html">File::Constants</a></li>
        
          
          
          <li><a href="./File/Stat.html">File::Stat</a></li>
        
          
          
          <li><a href="./FileTest.html">FileTest</a></li>
        
          
          
          <li><a href="./Fixnum.html">Fixnum</a></li>
        
          
          
          <li><a href="./Float.html">Float</a></li>
        
          
          
          <li><a href="./FloatDomainError.html">FloatDomainError</a></li>
        
          
          
          <li><a href="./GC.html">GC</a></li>
        
          
          
          <li><a href="./Hash.html">Hash</a></li>
        
          
          
          <li><a href="./IO.html">IO</a></li>
        
          
          
          <li><a href="./IOError.html">IOError</a></li>
        
          
          
          <li><a href="./IndexError.html">IndexError</a></li>
        
          
          
          <li><a href="./Integer.html">Integer</a></li>
        
          
          
          <li><a href="./Interrupt.html">Interrupt</a></li>
        
          
          
          <li><a href="./Kernel.html">Kernel</a></li>
        
          
          
          <li><a href="./LoadError.html">LoadError</a></li>
        
          
          
          <li><a href="./LocalJumpError.html">LocalJumpError</a></li>
        
          
          
          <li><a href="./Marshal.html">Marshal</a></li>
        
          
          
          <li><a href="./MatchData.html">MatchData</a></li>
        
          
          
          <li><a href="./Math.html">Math</a></li>
        
          
          
          <li><a href="./Method.html">Method</a></li>
        
          
          
          <li><a href="./Module.html">Module</a></li>
        
          
          
          <li><a href="./NameError.html">NameError</a></li>
        
          
          
          <li><a href="./NameError/message.html">NameError::message</a></li>
        
          
          
          <li><a href="./NilClass.html">NilClass</a></li>
        
          
          
          <li><a href="./NoMemoryError.html">NoMemoryError</a></li>
        
          
          
          <li><a href="./NoMethodError.html">NoMethodError</a></li>
        
          
          
          <li><a href="./NotImplementedError.html">NotImplementedError</a></li>
        
          
          
          <li><a href="./Numeric.html">Numeric</a></li>
        
          
          
          <li><a href="./Object.html">Object</a></li>
        
          
          
          <li><a href="./ObjectSpace.html">ObjectSpace</a></li>
        
          
          
          <li><a href="./Precision.html">Precision</a></li>
        
          
          
          <li><a href="./Proc.html">Proc</a></li>
        
          
          
          <li><a href="./Process.html">Process</a></li>
        
          
          
          <li><a href="./Process/GID.html">Process::GID</a></li>
        
          
          
          <li><a href="./Process/Status.html">Process::Status</a></li>
        
          
          
          <li><a href="./Process/Sys.html">Process::Sys</a></li>
        
          
          
          <li><a href="./Process/UID.html">Process::UID</a></li>
        
          
          
          <li><a href="./Range.html">Range</a></li>
        
          
          
          <li><a href="./RangeError.html">RangeError</a></li>
        
          
          
          <li><a href="./Regexp.html">Regexp</a></li>
        
          
          
          <li><a href="./RegexpError.html">RegexpError</a></li>
        
          
          
          <li><a href="./RuntimeError.html">RuntimeError</a></li>
        
          
          
          <li><a href="./ScriptError.html">ScriptError</a></li>
        
          
          
          <li><a href="./SecurityError.html">SecurityError</a></li>
        
          
          
          <li><a href="./Signal.html">Signal</a></li>
        
          
          
          <li><a href="./SignalException.html">SignalException</a></li>
        
          
          
          <li><a href="./StandardError.html">StandardError</a></li>
        
          
          
          <li><a href="./StopIteration.html">StopIteration</a></li>
        
          
          
          <li><a href="./String.html">String</a></li>
        
          
          
          <li><a href="./Struct.html">Struct</a></li>
        
          
          
          <li><a href="./Symbol.html">Symbol</a></li>
        
          
          
          <li><a href="./SyntaxError.html">SyntaxError</a></li>
        
          
          
          <li><a href="./SystemCallError.html">SystemCallError</a></li>
        
          
          
          <li><a href="./SystemExit.html">SystemExit</a></li>
        
          
          
          <li><a href="./SystemStackError.html">SystemStackError</a></li>
        
          
          
          <li><a href="./Thread.html">Thread</a></li>
        
          
          
          <li><a href="./ThreadError.html">ThreadError</a></li>
        
          
          
          <li><a href="./ThreadGroup.html">ThreadGroup</a></li>
        
          
          
          <li><a href="./Time.html">Time</a></li>
        
          
          
          <li><a href="./TrueClass.html">TrueClass</a></li>
        
          
          
          <li><a href="./TypeError.html">TypeError</a></li>
        
          
          
          <li><a href="./UnboundMethod.html">UnboundMethod</a></li>
        
          
          
          <li><a href="./ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          
          
          <li><a href="./fatal.html">fatal</a></li>
        
          
          
          <li><a href="./unknown.html">unknown</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
    
  </div> 
  <div id="documentation">
    <h1 class="class">Array</h1>

    <div id="description" class="description">
      
<p>Arrays are ordered, integer-indexed collections of any object.  <a
href="Array.html">Array</a> indexing starts at 0, as in C or Java.  A
negative index is  assumed to be relative to the end of the array—that is,
an index of -1  indicates the last element of the array, -2 is the next to
last  element in the array, and so on.</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-c-5B-5D"></a>

          
          <div class="method-heading">
            <span class="method-name">[]</span><span
              class="method-args">(*args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns a new array populated with the given objects.</p>

<pre>Array.[]( 1, 'a', /^A/ )
Array[ 1, 'a', /^A/ ]
[ 1, 'a', /^A/ ]</pre>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_s_create(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE ary = ary_alloc(klass);

    if (argc &gt; 0) {
        RARRAY(ary)-&gt;ptr = ALLOC_N(VALUE, argc);
        MEMCPY(RARRAY(ary)-&gt;ptr, argv, VALUE, argc);
    }
    RARRAY(ary)-&gt;len = RARRAY(ary)-&gt;aux.capa = argc;

    return ary;
}
            </pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->
      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new(size=0, obj=nil)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new(array)</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new(size) {|index| block }</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array. In the first form, the new array is empty. In the
second it is created with <em>size</em> copies of <em>obj</em> (that is,
<em>size</em> references to the same <em>obj</em>). The third form creates
a copy of the array passed as a parameter (the array is generated by
calling <a href="Array.html#method-i-to_ary">#to_ary</a>  on the
parameter). In the last form, an array of the given size is created. Each
element in this array is calculated by passing the element’s index to the
given block and storing the return value.</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>)
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">5</span>, <span class="ruby-string">&quot;A&quot;</span>)

<span class="ruby-comment"># only one copy of the object is created</span>
<span class="ruby-identifier">a</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>, <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>)
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>][<span class="ruby-string">'cat'</span>] = <span class="ruby-string">'feline'</span>
<span class="ruby-identifier">a</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>][<span class="ruby-string">'cat'</span>] = <span class="ruby-string">'Felix'</span>
<span class="ruby-identifier">a</span>

<span class="ruby-comment"># here multiple copies are created</span>
<span class="ruby-identifier">a</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>) { <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> }
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>][<span class="ruby-string">'cat'</span>] = <span class="ruby-string">'feline'</span>
<span class="ruby-identifier">a</span>

<span class="ruby-identifier">squares</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">5</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span>}
<span class="ruby-identifier">squares</span>

<span class="ruby-identifier">copy</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">squares</span>)
</pre>
            

            
            <div class="method-source-code" id="new-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_initialize(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long len;
    VALUE size, val;

    rb_ary_modify(ary);
    if (rb_scan_args(argc, argv, &quot;02&quot;, &amp;size, &amp;val) == 0) {
        RARRAY(ary)-&gt;len = 0;
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        return ary;
    }

    if (argc == 1 &amp;&amp; !FIXNUM_P(size)) {
        val = rb_check_array_type(size);
        if (!NIL_P(val)) {
            rb_ary_replace(ary, val);
            return ary;
        }
    }

    len = NUM2LONG(size);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative array size&quot;);
    }
    if (len &gt; ARY_MAX_SIZE) {
        rb_raise(rb_eArgError, &quot;array size too big&quot;);
    }
    if (len &gt; RARRAY(ary)-&gt;aux.capa) {
        REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, len);
        RARRAY(ary)-&gt;aux.capa = len;
    }
    if (rb_block_given_p()) {
        long i;

        if (argc == 2) {
            rb_warn(&quot;block supersedes default value argument&quot;);
        }
        for (i=0; i&lt;len; i++) {
            rb_ary_store(ary, i, rb_yield(LONG2NUM(i)));
            RARRAY(ary)-&gt;len = i + 1;
        }
    }
    else {
        memfill(RARRAY(ary)-&gt;ptr, len, val);
        RARRAY(ary)-&gt;len = len;
    }

    return ary;
}
            </pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="26-method" class="method-detail ">
          <a name="method-i-26"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">array & other_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Set Intersection—Returns a new array containing elements common to the two
arrays, with no duplicates.</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>, <span class="ruby-value">5</span> ] <span class="ruby-operator">&amp;</span> [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ]   <span class="ruby-comment">#=&gt; [ 1, 3 ]</span>
</pre>
            

            
            <div class="method-source-code" id="26-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_and(ary1, ary2)
    VALUE ary1, ary2;
{
    VALUE hash, ary3, v, vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new2(RARRAY(ary1)-&gt;len &lt; RARRAY(ary2)-&gt;len ?
            RARRAY(ary1)-&gt;len : RARRAY(ary2)-&gt;len);
    hash = ary_make_hash(ary2, 0);

    for (i=0; i&lt;RARRAY(ary1)-&gt;len; i++) {
        v = vv = rb_ary_elt(ary1, i);
        if (st_delete(RHASH(hash)-&gt;tbl, (st_data_t*)&amp;vv, 0)) {
            rb_ary_push(ary3, v);
        }
    }

    return ary3;
}
            </pre> 
            </div><!-- 26-source -->
            
          </div>

          

          
        </div><!-- 26-method -->
      
        <div id="2A-method" class="method-detail ">
          <a name="method-i-2A"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">array * int     &rarr;    an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">array * str     &rarr;    a_string</span>
            
          </div>
          
          
          <div>
  
            
            <p>Repetition—With a <a href="String.html">String</a> argument, equivalent to
self.join(str). Otherwise, returns a new array built by concatenating the
<em>int</em> copies of <em>self</em>.</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ] <span class="ruby-operator">*</span> <span class="ruby-value">3</span>    <span class="ruby-comment">#=&gt; [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]</span>
[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ] <span class="ruby-operator">*</span> <span class="ruby-string">&quot;,&quot;</span>  <span class="ruby-comment">#=&gt; &quot;1,2,3&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="2A-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_times(ary, times)
    VALUE ary, times;
{
    VALUE ary2, tmp;
    long i, len;

    tmp = rb_check_string_type(times);
    if (!NIL_P(tmp)) {
        return rb_ary_join(ary, tmp);
    }

    len = NUM2LONG(times);
    if (len == 0) return ary_new(rb_obj_class(ary), 0);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative argument&quot;);
    }
    if (ARY_MAX_SIZE/len &lt; RARRAY(ary)-&gt;len) {
        rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    len *= RARRAY(ary)-&gt;len;

    ary2 = ary_new(rb_obj_class(ary), len);
    RARRAY(ary2)-&gt;len = len;

    for (i=0; i&lt;len; i+=RARRAY(ary)-&gt;len) {
        MEMCPY(RARRAY(ary2)-&gt;ptr+i, RARRAY(ary)-&gt;ptr, VALUE, RARRAY(ary)-&gt;len);
    }
    OBJ_INFECT(ary2, ary);

    return ary2;
}
            </pre> 
            </div><!-- 2A-source -->
            
          </div>

          

          
        </div><!-- 2A-method -->
      
        <div id="2B-method" class="method-detail ">
          <a name="method-i-2B"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">array + other_array   &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Concatenation—Returns a new array built by concatenating the two arrays
together to produce a third array.</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ] <span class="ruby-operator">+</span> [ <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]    <span class="ruby-comment">#=&gt; [ 1, 2, 3, 4, 5 ]</span>
</pre>
            

            
            <div class="method-source-code" id="2B-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_plus(x, y)
    VALUE x, y;
{
    VALUE z;
    long len;

    y = to_ary(y);
    len = RARRAY(x)-&gt;len + RARRAY(y)-&gt;len;
    z = rb_ary_new2(len);
    MEMCPY(RARRAY(z)-&gt;ptr, RARRAY(x)-&gt;ptr, VALUE, RARRAY(x)-&gt;len);
    MEMCPY(RARRAY(z)-&gt;ptr + RARRAY(x)-&gt;len, RARRAY(y)-&gt;ptr, VALUE, RARRAY(y)-&gt;len);
    RARRAY(z)-&gt;len = len;
    return z;
}
            </pre> 
            </div><!-- 2B-source -->
            
          </div>

          

          
        </div><!-- 2B-method -->
      
        <div id="2D-method" class="method-detail ">
          <a name="method-i-2D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">array - other_array    &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Array.html">Array</a> Difference---Returns a new array that is a
copy of the original array, removing any items that also appear in
other_array. (If you need set-like behavior, see the library class Set.)</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ] <span class="ruby-operator">-</span> [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">4</span> ]  <span class="ruby-comment">#=&gt;  [ 3, 3, 5 ]</span>
</pre>
            

            
            <div class="method-source-code" id="2D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_diff(ary1, ary2)
    VALUE ary1, ary2;
{
    VALUE ary3;
    volatile VALUE hash;
    long i;

    hash = ary_make_hash(to_ary(ary2), 0);
    ary3 = rb_ary_new();

    for (i=0; i&lt;RARRAY(ary1)-&gt;len; i++) {
        if (st_lookup(RHASH(hash)-&gt;tbl, RARRAY(ary1)-&gt;ptr[i], 0)) continue;
        rb_ary_push(ary3, rb_ary_elt(ary1, i));
    }
    return ary3;
}
            </pre> 
            </div><!-- 2D-source -->
            
          </div>

          

          
        </div><!-- 2D-method -->
      
        <div id="3C-3C-method" class="method-detail ">
          <a name="method-i-3C-3C"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">array << obj            &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Append—Pushes the given object on to the end of this array. This expression
returns the array itself, so several appends may be chained together.</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span> ] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;c&quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;d&quot;</span> <span class="ruby-operator">&lt;&lt;</span> [ <span class="ruby-value">3</span>, <span class="ruby-value">4</span> ]
        <span class="ruby-comment">#=&gt;  [ 1, 2, &quot;c&quot;, &quot;d&quot;, [ 3, 4 ] ]</span>
</pre>
            

            
            <div class="method-source-code" id="3C-3C-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_push(ary, item)
    VALUE ary;
    VALUE item;
{
    rb_ary_store(ary, RARRAY(ary)-&gt;len, item);
    return ary;
}
            </pre> 
            </div><!-- 3C-3C-source -->
            
          </div>

          

          
        </div><!-- 3C-3C-method -->
      
        <div id="3C-3D-3E-method" class="method-detail ">
          <a name="method-i-3C-3D-3E"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">array <=> other_array   &rarr;  -1, 0, +1</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Comparison—Returns an integer (-1, 0, or +1) if this array is less than,
equal to, or greater than other_array.  Each object in each array is
compared (using &lt;=&gt;). If any value isn’t equal, then that inequality
is the return value. If all the values found are equal, then the return is
based on a comparison of the array lengths.  Thus, two arrays are “equal”
according to <code>Array#&lt;=&gt;</code> if and only if they have the same
length and the value of each element is equal to the value of the
corresponding element in the other array.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]    <span class="ruby-operator">&lt;=&gt;</span> [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]   <span class="ruby-comment">#=&gt; -1</span>
[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span> ] <span class="ruby-operator">&lt;=&gt;</span> [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span> ]            <span class="ruby-comment">#=&gt; +1</span>
</pre>
            

            
            <div class="method-source-code" id="3C-3D-3E-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_cmp(ary1, ary2)
    VALUE ary1, ary2;
{
    long len;
    VALUE v;

    ary2 = to_ary(ary2);
    if (ary1 == ary2) return INT2FIX(0);
    v = rb_exec_recursive(recursive_cmp, ary1, ary2);
    if (v != Qundef) return v;
    len = RARRAY(ary1)-&gt;len - RARRAY(ary2)-&gt;len;
    if (len == 0) return INT2FIX(0);
    if (len &gt; 0) return INT2FIX(1);
    return INT2FIX(-1);
}
            </pre> 
            </div><!-- 3C-3D-3E-source -->
            
          </div>

          

          
        </div><!-- 3C-3D-3E-method -->
      
        <div id="3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">array == other_array   &rarr;   bool</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Equality—Two arrays are equal if they contain the same number of elements
and if each element is equal to (according to <a
href="Object.html">Object</a>.==) the corresponding element in the other
array.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]    <span class="ruby-operator">==</span> [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-value">7</span> ]     <span class="ruby-comment">#=&gt; false</span>
[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-value">7</span> ] <span class="ruby-operator">==</span> [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-value">7</span> ]     <span class="ruby-comment">#=&gt; true</span>
[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-value">7</span> ] <span class="ruby-operator">==</span> [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;f&quot;</span> ]   <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="3D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_equal(ary1, ary2)
    VALUE ary1, ary2;
{
    if (ary1 == ary2) return Qtrue;
    if (TYPE(ary2) != T_ARRAY) {
        if (!rb_respond_to(ary2, rb_intern(&quot;to_ary&quot;))) {
            return Qfalse;
        }
        return rb_equal(ary2, ary1);
    }
    if (RARRAY(ary1)-&gt;len != RARRAY(ary2)-&gt;len) return Qfalse;
    return rb_exec_recursive(recursive_equal, ary1, ary2);
}
            </pre> 
            </div><!-- 3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-method -->
      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-i-5B-5D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">array[index]                &rarr; obj      or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">array[start, length]        &rarr; an_array or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">array[range]                &rarr; an_array or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(index)          &rarr; obj      or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(start, length)  &rarr; an_array or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(range)          &rarr; an_array or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Element Reference—Returns the element at <em>index</em>, or returns a
subarray starting at <em>start</em> and continuing for <em>length</em>
elements, or returns a subarray specified by <em>range</em>. Negative
indices count backward from the end of the array (-1 is the last element).
Returns nil if the index (or starting index) are out of range.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span> ]
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">+</span>  <span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>]    <span class="ruby-comment">#=&gt; &quot;cab&quot;</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span>]                   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]                <span class="ruby-comment">#=&gt; [ &quot;b&quot;, &quot;c&quot; ]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>]                <span class="ruby-comment">#=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">7</span>]                <span class="ruby-comment">#=&gt; [ &quot;e&quot; ]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]               <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-3</span>, <span class="ruby-value">3</span>]               <span class="ruby-comment">#=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]</span>
<span class="ruby-comment"># special cases</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">5</span>]                   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">5</span>, <span class="ruby-value">1</span>]                <span class="ruby-comment">#=&gt; []</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]               <span class="ruby-comment">#=&gt; []</span>
</pre>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_aref(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE arg;
    long beg, len;

    if (argc == 2) {
        if (SYMBOL_P(argv[0])) {
            rb_raise(rb_eTypeError, &quot;Symbol as array index&quot;);
        }
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        if (beg &lt; 0) {
            beg += RARRAY(ary)-&gt;len;
        }
        return rb_ary_subseq(ary, beg, len);
    }
    if (argc != 1) {
        rb_scan_args(argc, argv, &quot;11&quot;, 0, 0);
    }
    arg = argv[0];
    /* special case - speeding up */
    if (FIXNUM_P(arg)) {
        return rb_ary_entry(ary, FIX2LONG(arg));
    }
    if (SYMBOL_P(arg)) {
        rb_raise(rb_eTypeError, &quot;Symbol as array index&quot;);
    }
    /* check if idx is Range */
    switch (rb_range_beg_len(arg, &amp;beg, &amp;len, RARRAY(ary)-&gt;len, 0)) {
      case Qfalse:
        break;
      case Qnil:
        return Qnil;
      default:
        return rb_ary_subseq(ary, beg, len);
    }
    return rb_ary_entry(ary, NUM2LONG(arg));
}
            </pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->
      
        <div id="5B-5D-3D-method" class="method-detail ">
          <a name="method-i-5B-5D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">array[index]         = obj                     &rarr;  obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">array[start, length] = obj or an_array or nil  &rarr;  obj or an_array or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">array[range]         = obj or an_array or nil  &rarr;  obj or an_array or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Element Assignment—Sets the element at <em>index</em>, or replaces a
subarray starting at <em>start</em> and continuing for <em>length</em>
elements, or replaces a subarray specified by <em>range</em>.  If indices
are greater than the current capacity of the array, the array grows
automatically. A negative indices will count backward from the end of the
array. Inserts elements if <em>length</em> is zero. If <code>nil</code> is
used in the second and third form, deletes elements from <em>self</em>. An
<code>IndexError</code> is raised if a negative index points past the
beginning of the array. See also <code>Array#push</code>, and
<code>Array#unshift</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span>] = <span class="ruby-string">&quot;4&quot;</span>;                 <span class="ruby-comment">#=&gt; [nil, nil, nil, nil, &quot;4&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">3</span>] = [ <span class="ruby-string">'a'</span>, <span class="ruby-string">'b'</span>, <span class="ruby-string">'c'</span> ] <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, nil, &quot;4&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span> ]          <span class="ruby-comment">#=&gt; [&quot;a&quot;, 1, 2, nil, &quot;4&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>] = <span class="ruby-string">&quot;?&quot;</span>               <span class="ruby-comment">#=&gt; [&quot;?&quot;, 2, nil, &quot;4&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] = <span class="ruby-string">&quot;A&quot;</span>               <span class="ruby-comment">#=&gt; [&quot;A&quot;, &quot;4&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span>]   = <span class="ruby-string">&quot;Z&quot;</span>               <span class="ruby-comment">#=&gt; [&quot;A&quot;, &quot;Z&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] = <span class="ruby-keyword">nil</span>              <span class="ruby-comment">#=&gt; [&quot;A&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="5B-5D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_aset(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long offset, beg, len;

    if (argc == 3) {
        if (SYMBOL_P(argv[0])) {
            rb_raise(rb_eTypeError, &quot;Symbol as array index&quot;);
        }
        if (SYMBOL_P(argv[1])) {
            rb_raise(rb_eTypeError, &quot;Symbol as subarray length&quot;);
        }
        rb_ary_splice(ary, NUM2LONG(argv[0]), NUM2LONG(argv[1]), argv[2]);
        return argv[2];
    }
    if (argc != 2) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 2)&quot;, argc);
    }
    if (FIXNUM_P(argv[0])) {
        offset = FIX2LONG(argv[0]);
        goto fixnum;
    }
    if (SYMBOL_P(argv[0])) {
        rb_raise(rb_eTypeError, &quot;Symbol as array index&quot;);
    }
    if (rb_range_beg_len(argv[0], &amp;beg, &amp;len, RARRAY(ary)-&gt;len, 1)) {
        /* check if idx is Range */
        rb_ary_splice(ary, beg, len, argv[1]);
        return argv[1];
    }

    offset = NUM2LONG(argv[0]);
fixnum:
    rb_ary_store(ary, offset, argv[1]);
    return argv[1];
}
            </pre> 
            </div><!-- 5B-5D-3D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-3D-method -->
      
        <div id="assoc-method" class="method-detail ">
          <a name="method-i-assoc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">assoc(obj)   &rarr;  an_array  or  nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Searches through an array whose elements are also arrays comparing
<em>obj</em> with the first element of each contained array using obj.==.
Returns the first contained array that matches (that is, the first
associated array), or <code>nil</code> if no match is found. See also
<code>Array#rassoc</code>.</p>

<pre class="ruby"><span class="ruby-identifier">s1</span> = [ <span class="ruby-string">&quot;colors&quot;</span>, <span class="ruby-string">&quot;red&quot;</span>, <span class="ruby-string">&quot;blue&quot;</span>, <span class="ruby-string">&quot;green&quot;</span> ]
<span class="ruby-identifier">s2</span> = [ <span class="ruby-string">&quot;letters&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">s3</span> = <span class="ruby-string">&quot;foo&quot;</span>
<span class="ruby-identifier">a</span>  = [ <span class="ruby-identifier">s1</span>, <span class="ruby-identifier">s2</span>, <span class="ruby-identifier">s3</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">assoc</span>(<span class="ruby-string">&quot;letters&quot;</span>)  <span class="ruby-comment">#=&gt; [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">assoc</span>(<span class="ruby-string">&quot;foo&quot;</span>)      <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="assoc-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_assoc(ary, key)
    VALUE ary, key;
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY(ary)-&gt;len; ++i) {
        v = rb_check_array_type(RARRAY(ary)-&gt;ptr[i]);
        if (!NIL_P(v) &amp;&amp; RARRAY(v)-&gt;len &gt; 0 &amp;&amp;
            rb_equal(RARRAY(v)-&gt;ptr[0], key))
            return v;
    }
    return Qnil;
}
            </pre> 
            </div><!-- assoc-source -->
            
          </div>

          

          
        </div><!-- assoc-method -->
      
        <div id="at-method" class="method-detail ">
          <a name="method-i-at"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">at(index)   &rarr;   obj  or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the element at <em>index</em>. A negative index counts from the end
of <em>self</em>.  Returns <code>nil</code> if the index is out of range.
See also <code>Array#[]</code>. (<code>Array#at</code> is slightly faster
than <code>Array#[]</code>, as it does not accept ranges and so on.)</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>)     <span class="ruby-comment">#=&gt; &quot;a&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">-1</span>)    <span class="ruby-comment">#=&gt; &quot;e&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="at-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_at(ary, pos)
    VALUE ary, pos;
{
    return rb_ary_entry(ary, NUM2LONG(pos));
}
            </pre> 
            </div><!-- at-source -->
            
          </div>

          

          
        </div><!-- at-method -->
      
        <div id="choice-method" class="method-detail ">
          <a name="method-i-choice"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">choice        &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Choose a random element from an array.</p>
            

            
            <div class="method-source-code" id="choice-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_choice(ary)
    VALUE ary;
{
    long i, j;

    i = RARRAY(ary)-&gt;len;
    if (i == 0) return Qnil;
    j = rb_genrand_real()*i;
    return RARRAY(ary)-&gt;ptr[j];
}
            </pre> 
            </div><!-- choice-source -->
            
          </div>

          

          
        </div><!-- choice-method -->
      
        <div id="clear-method" class="method-detail ">
          <a name="method-i-clear"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">clear    &rarr;  array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes all elements from <em>self</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">clear</span>    <span class="ruby-comment">#=&gt; [ ]</span>
</pre>
            

            
            <div class="method-source-code" id="clear-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_clear(ary)
    VALUE ary;
{
    rb_ary_modify(ary);
    RARRAY(ary)-&gt;len = 0;
    if (ARY_DEFAULT_SIZE * 2 &lt; RARRAY(ary)-&gt;aux.capa) {
        REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, ARY_DEFAULT_SIZE * 2);
        RARRAY(ary)-&gt;aux.capa = ARY_DEFAULT_SIZE * 2;
    }
    return ary;
}
            </pre> 
            </div><!-- clear-source -->
            
          </div>

          

          
        </div><!-- clear-method -->
      
        <div id="collect-method" class="method-detail ">
          <a name="method-i-collect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">collect {|item| block }  &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes <em>block</em> once for each element of <em>self</em>. Creates a 
new array containing the values returned by the block. See also
<code>Enumerable#collect</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;!&quot;</span> }   <span class="ruby-comment">#=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]</span>
<span class="ruby-identifier">a</span>                          <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="collect-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_collect(ary)
    VALUE ary;
{
    long i;
    VALUE collect;

    if (!rb_block_given_p()) {
        return rb_ary_new4(RARRAY(ary)-&gt;len, RARRAY(ary)-&gt;ptr);
    }

    collect = rb_ary_new2(RARRAY(ary)-&gt;len);
    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
        rb_ary_push(collect, rb_yield(RARRAY(ary)-&gt;ptr[i]));
    }
    return collect;
}
            </pre> 
            </div><!-- collect-source -->
            
          </div>

          

          
        </div><!-- collect-method -->
      
        <div id="collect-21-method" class="method-detail ">
          <a name="method-i-collect-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">collect! {|item| block }   &rarr;   array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes the block once for each element of <em>self</em>, replacing the
element with the value returned by <em>block</em>. See also
<code>Enumerable#collect</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">collect!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;!&quot;</span> }
<span class="ruby-identifier">a</span>             <span class="ruby-comment">#=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]</span>
</pre>
            

            
            <div class="method-source-code" id="collect-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_collect_bang(ary)
    VALUE ary;
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
        rb_ary_store(ary, i, rb_yield(RARRAY(ary)-&gt;ptr[i]));
    }
    return ary;
}
            </pre> 
            </div><!-- collect-21-source -->
            
          </div>

          

          
        </div><!-- collect-21-method -->
      
        <div id="combination-method" class="method-detail ">
          <a name="method-i-combination"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">combination(n) { |c| block }    &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">combination(n)                  &rarr; enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>When invoked with a block, yields all combinations of length <em>n</em>  of
elements from <em>ary</em> and then returns <em>ary</em> itself. The
implementation makes no guarantees about the order in which  the
combinations are yielded.</p>

<p>When invoked without a block, returns an enumerator object instead.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">1</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1],[2],[3],[4]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">2</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">3</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">4</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,2,3,4]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">0</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[]] # one combination of length 0</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">5</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; []   # no combinations of length 5</span>
</pre>
            

            
            <div class="method-source-code" id="combination-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_combination(ary, num)
    VALUE ary;
    VALUE num;
{
    long n, i, len;

    n = NUM2LONG(num);
    RETURN_ENUMERATOR(ary, 1, &amp;num);
    len = RARRAY(ary)-&gt;len;
    if (n &lt; 0 || len &lt; n) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; len; i++) {
            rb_yield(rb_ary_new3(1, RARRAY(ary)-&gt;ptr[i]));
        }
    }
    else {
        volatile VALUE t0 = tmpbuf(n+1, sizeof(long));
        long *stack = (long*)RSTRING(t0)-&gt;ptr;
        long nlen = combi_len(len, n);
        volatile VALUE cc = rb_ary_new2(n);
        VALUE *chosen = RARRAY(cc)-&gt;ptr;
        long lev = 0;

        RBASIC(cc)-&gt;klass = 0;
        MEMZERO(stack, long, n);
        stack[0] = -1;
        for (i = 0; i &lt; nlen; i++) {
            chosen[lev] = RARRAY(ary)-&gt;ptr[stack[lev+1]];
            for (lev++; lev &lt; n; lev++) {
                chosen[lev] = RARRAY(ary)-&gt;ptr[stack[lev+1] = stack[lev]+1];
            }
            rb_yield(rb_ary_new4(n, chosen));
            do {
                stack[lev--]++;
            } while (lev &amp;&amp; (stack[lev+1]+n == len+lev+1));
        }
    }
    return ary;
}
            </pre> 
            </div><!-- combination-source -->
            
          </div>

          

          
        </div><!-- combination-method -->
      
        <div id="compact-method" class="method-detail ">
          <a name="method-i-compact"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">compact     &rarr;  an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a copy of <em>self</em> with all <code>nil</code> elements removed.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-keyword">nil</span> ].<span class="ruby-identifier">compact</span>
                  <span class="ruby-comment">#=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</span>
</pre>
            

            
            <div class="method-source-code" id="compact-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_compact(ary)
    VALUE ary;
{
    ary = rb_ary_dup(ary);
    rb_ary_compact_bang(ary);
    return ary;
}
            </pre> 
            </div><!-- compact-source -->
            
          </div>

          

          
        </div><!-- compact-method -->
      
        <div id="compact-21-method" class="method-detail ">
          <a name="method-i-compact-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">compact!    &rarr;   array  or  nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes <code>nil</code> elements from array. Returns <code>nil</code> if
no changes were made.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&quot;c&quot;</span> ].<span class="ruby-identifier">compact!</span> <span class="ruby-comment">#=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</span>
[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ].<span class="ruby-identifier">compact!</span>           <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="compact-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_compact_bang(ary)
    VALUE ary;
{
    VALUE *p, *t, *end;

    rb_ary_modify(ary);
    p = t = RARRAY(ary)-&gt;ptr;
    end = p + RARRAY(ary)-&gt;len;
    
    while (t &lt; end) {
        if (NIL_P(*t)) t++;
        else *p++ = *t++;
    }
    if (RARRAY(ary)-&gt;len == (p - RARRAY(ary)-&gt;ptr)) {
        return Qnil;
    }
    RARRAY(ary)-&gt;len = RARRAY(ary)-&gt;aux.capa = (p - RARRAY(ary)-&gt;ptr);
    REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, RARRAY(ary)-&gt;len);

    return ary;
}
            </pre> 
            </div><!-- compact-21-source -->
            
          </div>

          

          
        </div><!-- compact-21-method -->
      
        <div id="concat-method" class="method-detail ">
          <a name="method-i-concat"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">concat(other_array)   &rarr;  array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Appends the elements in other_array to <em>self</em>.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span> ].<span class="ruby-identifier">concat</span>( [<span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>] ) <span class="ruby-comment">#=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</span>
</pre>
            

            
            <div class="method-source-code" id="concat-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_concat(x, y)
    VALUE x, y;
{
    y = to_ary(y);
    if (RARRAY(y)-&gt;len &gt; 0) {
        rb_ary_splice(x, RARRAY(x)-&gt;len, 0, y);
    }
    return x;
}
            </pre> 
            </div><!-- concat-source -->
            
          </div>

          

          
        </div><!-- concat-method -->
      
        <div id="count-method" class="method-detail ">
          <a name="method-i-count"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">count      &rarr; int</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">count(obj) &rarr; int</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">count { |item| block }  &rarr; int</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the number of elements.  If an argument is given, counts the number
of elements which equals to <em>obj</em>.  If a block is given, counts the
number of elements yielding a true value.</p>

<pre class="ruby"><span class="ruby-identifier">ary</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">4</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>             <span class="ruby-comment"># =&gt; 4</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>(<span class="ruby-value">2</span>)          <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">%</span><span class="ruby-value">2</span><span class="ruby-operator">==</span><span class="ruby-value">0</span>}  <span class="ruby-comment"># =&gt; 3</span>
</pre>
            

            
            <div class="method-source-code" id="count-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_count(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long n = 0;

    if (argc == 0) {
        VALUE *p, *pend;

        if (!rb_block_given_p())
            return LONG2NUM(RARRAY_LEN(ary));

        for (p = RARRAY_PTR(ary), pend = p + RARRAY_LEN(ary); p &lt; pend; p++) {
            if (RTEST(rb_yield(*p))) n++;
        }
    }
    else {
        VALUE obj, *p, *pend;

        rb_scan_args(argc, argv, &quot;1&quot;, &amp;obj);
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (p = RARRAY_PTR(ary), pend = p + RARRAY_LEN(ary); p &lt; pend; p++) {
            if (rb_equal(*p, obj)) n++;
        }
    }

    return LONG2NUM(n);
}
            </pre> 
            </div><!-- count-source -->
            
          </div>

          

          
        </div><!-- count-method -->
      
        <div id="cycle-method" class="method-detail ">
          <a name="method-i-cycle"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">cycle {|obj| block }</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">cycle(n) {|obj| block }</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls <em>block</em> for each element repeatedly <em>n</em> times or
forever if none or nil is given.  If a non-positive number is given or the
array is empty, does nothing.  Returns nil if the loop has finished without
getting interrupted.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">cycle</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">x</span> }  <span class="ruby-comment"># print, a, b, c, a, b, c,.. forever.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">cycle</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">x</span> }  <span class="ruby-comment"># print, a, b, c, a, b, c.</span>
</pre>
            

            
            <div class="method-source-code" id="cycle-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_cycle(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long n, i;
    VALUE nv = Qnil;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;nv);

    RETURN_ENUMERATOR(ary, argc, argv);
    if (NIL_P(nv)) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }

    while (RARRAY(ary)-&gt;len &gt; 0 &amp;&amp; (n &lt; 0 || 0 &lt; n--)) {
        for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
            rb_yield(RARRAY(ary)-&gt;ptr[i]);
        }
    }
    return Qnil;
}
            </pre> 
            </div><!-- cycle-source -->
            
          </div>

          

          
        </div><!-- cycle-method -->
      
        <div id="delete-method" class="method-detail ">
          <a name="method-i-delete"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete(obj)            &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">delete(obj) { block }  &rarr; obj or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deletes items from <em>self</em> that are equal to <em>obj</em>. If the
item is not found, returns <code>nil</code>. If the optional code block is
given, returns the result of <em>block</em> if the item is not found.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&quot;b&quot;</span>)                   <span class="ruby-comment">#=&gt; &quot;b&quot;</span>
<span class="ruby-identifier">a</span>                               <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&quot;z&quot;</span>)                   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&quot;z&quot;</span>) { <span class="ruby-string">&quot;not found&quot;</span> }   <span class="ruby-comment">#=&gt; &quot;not found&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="delete-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_delete(ary, item)
    VALUE ary;
    VALUE item;
{
    long i1, i2;

    for (i1 = i2 = 0; i1 &lt; RARRAY(ary)-&gt;len; i1++) {
        VALUE e = RARRAY(ary)-&gt;ptr[i1];

        if (rb_equal(e, item)) continue;
        if (i1 != i2) {
            rb_ary_store(ary, i2, e);
        }
        i2++;
    }
    if (RARRAY(ary)-&gt;len == i2) {
        if (rb_block_given_p()) {
            return rb_yield(item);
        }
        return Qnil;
    }

    rb_ary_modify(ary);
    if (RARRAY(ary)-&gt;len &gt; i2) {
        RARRAY(ary)-&gt;len = i2;
        if (i2 * 2 &lt; RARRAY(ary)-&gt;aux.capa &amp;&amp;
            RARRAY(ary)-&gt;aux.capa &gt; ARY_DEFAULT_SIZE) {
            REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, i2 * 2);
            RARRAY(ary)-&gt;aux.capa = i2 * 2;
        }
    }

    return item;
}
            </pre> 
            </div><!-- delete-source -->
            
          </div>

          

          
        </div><!-- delete-method -->
      
        <div id="delete_at-method" class="method-detail ">
          <a name="method-i-delete_at"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete_at(index)  &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deletes the element at the specified index, returning that element, or
<code>nil</code> if the index is out of range. See also
<code>Array#slice!</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w( ant bat cat dog )</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">2</span>)    <span class="ruby-comment">#=&gt; &quot;cat&quot;</span>
<span class="ruby-identifier">a</span>                 <span class="ruby-comment">#=&gt; [&quot;ant&quot;, &quot;bat&quot;, &quot;dog&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">99</span>)   <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="delete_at-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_delete_at_m(ary, pos)
    VALUE ary, pos;
{
    return rb_ary_delete_at(ary, NUM2LONG(pos));
}
            </pre> 
            </div><!-- delete_at-source -->
            
          </div>

          

          
        </div><!-- delete_at-method -->
      
        <div id="delete_if-method" class="method-detail ">
          <a name="method-i-delete_if"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete_if {|item| block }  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deletes every element of <em>self</em> for which <em>block</em> evaluates
to <code>true</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-string">&quot;b&quot;</span> }   <span class="ruby-comment">#=&gt; [&quot;a&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="delete_if-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_delete_if(ary)
    VALUE ary;
{
    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_reject_bang(ary);
    return ary;
}
            </pre> 
            </div><!-- delete_if-source -->
            
          </div>

          

          
        </div><!-- delete_if-method -->
      
        <div id="drop-method" class="method-detail ">
          <a name="method-i-drop"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">drop(n)               => array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Drops first n elements from <em>ary</em>, and returns rest elements in an
array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">3</span>)             <span class="ruby-comment"># =&gt; [4, 5, 0]</span>
</pre>
            

            
            <div class="method-source-code" id="drop-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_drop(ary, n)
    VALUE ary;
    VALUE n;
{
    VALUE result;
    long pos = NUM2LONG(n);
    if (pos &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    result = rb_ary_subseq(ary, pos, RARRAY(ary)-&gt;len);
    if (result == Qnil) result = rb_ary_new();
    return result;
}
            </pre> 
            </div><!-- drop-source -->
            
          </div>

          

          
        </div><!-- drop-method -->
      
        <div id="drop_while-method" class="method-detail ">
          <a name="method-i-drop_while"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">drop_while {|arr| block }   => array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Drops elements up to, but not including, the first element for which the
block returns nil or false and returns an array containing the remaining
elements.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> }   <span class="ruby-comment"># =&gt; [3, 4, 5, 0]</span>
</pre>
            

            
            <div class="method-source-code" id="drop_while-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_drop_while(ary)
    VALUE ary;
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
        if (!RTEST(rb_yield(RARRAY(ary)-&gt;ptr[i]))) break;
    }
    return rb_ary_drop(ary, LONG2FIX(i));
}
            </pre> 
            </div><!-- drop_while-source -->
            
          </div>

          

          
        </div><!-- drop_while-method -->
      
        <div id="each-method" class="method-detail ">
          <a name="method-i-each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each {|item| block }   &rarr;   array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls <em>block</em> once for each element in <em>self</em>, passing that
element as a parameter.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">x</span>, <span class="ruby-string">&quot; -- &quot;</span> }
</pre>

<p>produces:</p>

<pre>a -- b -- c --</pre>
            

            
            <div class="method-source-code" id="each-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_each(ary)
    VALUE ary;
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
        rb_yield(RARRAY(ary)-&gt;ptr[i]);
    }
    return ary;
}
            </pre> 
            </div><!-- each-source -->
            
          </div>

          

          
        </div><!-- each-method -->
      
        <div id="each_index-method" class="method-detail ">
          <a name="method-i-each_index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_index {|index| block }  &rarr;  array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Same as <code>Array#each</code>, but passes the index of the element
instead of the element itself.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">x</span>, <span class="ruby-string">&quot; -- &quot;</span> }
</pre>

<p>produces:</p>

<pre>0 -- 1 -- 2 --</pre>
            

            
            <div class="method-source-code" id="each_index-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_each_index(ary)
    VALUE ary;
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
        rb_yield(LONG2NUM(i));
    }
    return ary;
}
            </pre> 
            </div><!-- each_index-source -->
            
          </div>

          

          
        </div><!-- each_index-method -->
      
        <div id="empty-3F-method" class="method-detail ">
          <a name="method-i-empty-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">empty?   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <em>self</em> array contains no elements.</p>

<pre class="ruby">[].<span class="ruby-identifier">empty?</span>   <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="empty-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_empty_p(ary)
    VALUE ary;
{
    if (RARRAY(ary)-&gt;len == 0)
        return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- empty-3F-source -->
            
          </div>

          

          
        </div><!-- empty-3F-method -->
      
        <div id="eql-3F-method" class="method-detail ">
          <a name="method-i-eql-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">eql?(other)  &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <em>array</em> and <em>other</em> are the same
object, or are both arrays with the same content.</p>
            

            
            <div class="method-source-code" id="eql-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_eql(ary1, ary2)
    VALUE ary1, ary2;
{
    if (ary1 == ary2) return Qtrue;
    if (TYPE(ary2) != T_ARRAY) return Qfalse;
    if (RARRAY(ary1)-&gt;len != RARRAY(ary2)-&gt;len) return Qfalse;
    return rb_exec_recursive(recursive_eql, ary1, ary2);
}
            </pre> 
            </div><!-- eql-3F-source -->
            
          </div>

          

          
        </div><!-- eql-3F-method -->
      
        <div id="fetch-method" class="method-detail ">
          <a name="method-i-fetch"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fetch(index)                    &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fetch(index, default )          &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fetch(index) {|index| block }   &rarr; obj</span>
            
          </div>
          
          
          <div>
  
            
            <p>Tries to return the element at position <em>index</em>. If the index lies
outside the array, the first form throws an <code>IndexError</code>
exception, the second form returns <em>default</em>, and the third form
returns the value of invoking the block, passing in the index. Negative
values of <em>index</em> count from the end of the array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">11</span>, <span class="ruby-value">22</span>, <span class="ruby-value">33</span>, <span class="ruby-value">44</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">1</span>)               <span class="ruby-comment">#=&gt; 22</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">-1</span>)              <span class="ruby-comment">#=&gt; 44</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">4</span>, <span class="ruby-string">'cat'</span>)        <span class="ruby-comment">#=&gt; &quot;cat&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">4</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span> }   <span class="ruby-comment">#=&gt; 16</span>
</pre>
            

            
            <div class="method-source-code" id="fetch-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_fetch(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE pos, ifnone;
    long block_given;
    long idx;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;pos, &amp;ifnone);
    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
        rb_warn(&quot;block supersedes default value argument&quot;);
    }
    idx = NUM2LONG(pos);

    if (idx &lt; 0) {
        idx +=  RARRAY(ary)-&gt;len;
    }
    if (idx &lt; 0 || RARRAY(ary)-&gt;len &lt;= idx) {
        if (block_given) return rb_yield(pos);
        if (argc == 1) {
            rb_raise(rb_eIndexError, &quot;index %ld out of array&quot;, idx);
        }
        return ifnone;
    }
    return RARRAY(ary)-&gt;ptr[idx];
}
            </pre> 
            </div><!-- fetch-source -->
            
          </div>

          

          
        </div><!-- fetch-method -->
      
        <div id="fill-method" class="method-detail ">
          <a name="method-i-fill"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fill(obj)                                &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill(obj, start [, length])              &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill(obj, range )                        &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill {|index| block }                    &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill(start [, length] ) {|index| block } &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill(range) {|index| block }             &rarr; array</span>
            
          </div>
          
          
          <div>
  
            
            <p>The first three forms set the selected elements of <em>self</em> (which may
be the entire array) to <em>obj</em>. A <em>start</em> of <code>nil</code>
is equivalent to zero. A <em>length</em> of <code>nil</code> is equivalent
to <em>self.length</em>. The last three forms fill the array with the value
of the block. The block is passed the absolute index of each element to be
filled.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-string">&quot;x&quot;</span>)              <span class="ruby-comment">#=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-string">&quot;z&quot;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>)        <span class="ruby-comment">#=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;z&quot;, &quot;z&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-string">&quot;y&quot;</span>, <span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>)        <span class="ruby-comment">#=&gt; [&quot;y&quot;, &quot;y&quot;, &quot;z&quot;, &quot;z&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span>}         <span class="ruby-comment">#=&gt; [0, 1, 4, 9]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">-2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span>}   <span class="ruby-comment">#=&gt; [0, 1, 8, 27]</span>
</pre>
            

            
            <div class="method-source-code" id="fill-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_fill(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE item, arg1, arg2;
    long beg = 0, end = 0, len = 0;
    VALUE *p, *pend;
    int block_p = Qfalse;

    if (rb_block_given_p()) {
        block_p = Qtrue;
        rb_scan_args(argc, argv, &quot;02&quot;, &amp;arg1, &amp;arg2);
        argc += 1;             /* hackish */
    }
    else {
        rb_scan_args(argc, argv, &quot;12&quot;, &amp;item, &amp;arg1, &amp;arg2);
    }
    switch (argc) {
      case 1:
        beg = 0;
        len = RARRAY(ary)-&gt;len;
        break;
      case 2:
        if (rb_range_beg_len(arg1, &amp;beg, &amp;len, RARRAY(ary)-&gt;len, 1)) {
            break;
        }
        /* fall through */
      case 3:
        beg = NIL_P(arg1) ? 0 : NUM2LONG(arg1);
        if (beg &lt; 0) {
            beg = RARRAY(ary)-&gt;len + beg;
            if (beg &lt; 0) beg = 0;
        }
        len = NIL_P(arg2) ? RARRAY(ary)-&gt;len - beg : NUM2LONG(arg2);
        break;
    }
    rb_ary_modify(ary);
    if (len &lt; 0) {
        return ary;
    }
    if (beg &gt;= ARY_MAX_SIZE || len &gt; ARY_MAX_SIZE - beg) {
        rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    end = beg + len;
    if (end &gt; RARRAY(ary)-&gt;len) {
        if (end &gt;= RARRAY(ary)-&gt;aux.capa) {
            REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, end);
            RARRAY(ary)-&gt;aux.capa = end;
        }
        rb_mem_clear(RARRAY(ary)-&gt;ptr + RARRAY(ary)-&gt;len, end - RARRAY(ary)-&gt;len);
        RARRAY(ary)-&gt;len = end;
    }

    if (block_p) {
        VALUE v;
        long i;

        for (i=beg; i&lt;end; i++) {
            v = rb_yield(LONG2NUM(i));
            if (i&gt;=RARRAY(ary)-&gt;len) break;
            RARRAY(ary)-&gt;ptr[i] = v;
        }
    }
    else {
        p = RARRAY(ary)-&gt;ptr + beg;
        pend = p + len;
        while (p &lt; pend) {
            *p++ = item;
        }
    }
    return ary;
}
            </pre> 
            </div><!-- fill-source -->
            
          </div>

          

          
        </div><!-- fill-method -->
      
        <div id="find_index-method" class="method-detail ">
          <a name="method-i-find_index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">index(obj)           &rarr;  int or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">index {|item| block} &rarr;  int or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the index of the first object in <em>self</em> such that is
<code>==</code> to <em>obj</em>. If a block is given instead of an
argument, returns first object for which <em>block</em> is true. Returns
<code>nil</code> if no match is found.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&quot;b&quot;</span>)        <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&quot;z&quot;</span>)        <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">==</span><span class="ruby-string">&quot;b&quot;</span>}  <span class="ruby-comment">#=&gt; 1</span>
</pre>

<p>This is an alias of <code>#find_index</code>.</p>
            

            
            <div class="method-source-code" id="find_index-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_index(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE val;
    long i;

    if (argc  == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
            if (RTEST(rb_yield(RARRAY(ary)-&gt;ptr[i]))) {
                return LONG2NUM(i);
            }
        }
        return Qnil;
    }
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;val);
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
        if (rb_equal(RARRAY(ary)-&gt;ptr[i], val))
            return LONG2NUM(i);
    }
    return Qnil;
}
            </pre> 
            </div><!-- find_index-source -->
            
          </div>

          

          
        </div><!-- find_index-method -->
      
        <div id="first-method" class="method-detail ">
          <a name="method-i-first"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">first   &rarr;   obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">first(n) &rarr; an_array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the first element, or the first <code>n</code> elements, of the
array. If the array is empty, the first form returns <code>nil</code>, and
the second form returns an empty array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;q&quot;</span>, <span class="ruby-string">&quot;r&quot;</span>, <span class="ruby-string">&quot;s&quot;</span>, <span class="ruby-string">&quot;t&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span>    <span class="ruby-comment">#=&gt; &quot;q&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">1</span>) <span class="ruby-comment">#=&gt; [&quot;q&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; [&quot;q&quot;, &quot;r&quot;, &quot;s&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="first-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_first(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    if (argc == 0) {
        if (RARRAY(ary)-&gt;len == 0) return Qnil;
        return RARRAY(ary)-&gt;ptr[0];
    }
    else {
        return ary_shared_first(argc, argv, ary, Qfalse);
    }
}
            </pre> 
            </div><!-- first-source -->
            
          </div>

          

          
        </div><!-- first-method -->
      
        <div id="flatten-method" class="method-detail ">
          <a name="method-i-flatten"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">flatten &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">flatten(level) &rarr; an_array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array that is a one-dimensional flattening of this array
(recursively). That is, for every element that is an array, extract its
elements into the new array.  If the optional <em>level</em> argument
determines the level of recursion to flatten.</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ]           <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
<span class="ruby-identifier">t</span> = [ <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>, [<span class="ruby-value">7</span>, <span class="ruby-value">8</span>] ]   <span class="ruby-comment">#=&gt; [4, 5, 6, [7, 8]]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-identifier">s</span>, <span class="ruby-identifier">t</span>, <span class="ruby-value">9</span>, <span class="ruby-value">10</span> ]       <span class="ruby-comment">#=&gt; [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>                 <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, [<span class="ruby-value">3</span>, [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>] ] ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">1</span>)              <span class="ruby-comment">#=&gt; [1, 2, 3, [4, 5]]</span>
</pre>
            

            
            <div class="method-source-code" id="flatten-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_flatten(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    int mod = 0, level = -1;
    VALUE result, lv;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;lv);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return ary;

    result = flatten(ary, level, &amp;mod);
    if (OBJ_TAINTED(ary)) OBJ_TAINT(result);

    return result;
}
            </pre> 
            </div><!-- flatten-source -->
            
          </div>

          

          
        </div><!-- flatten-method -->
      
        <div id="flatten-21-method" class="method-detail ">
          <a name="method-i-flatten-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">flatten! &rarr; array or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">flatten!(level) &rarr; array or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Flattens <em>self</em> in place. Returns <code>nil</code> if no
modifications were made (i.e., <em>array</em> contains no subarrays.)  If
the optional <em>level</em> argument determines the level of recursion to
flatten.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, [<span class="ruby-value">3</span>, [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>] ] ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten!</span>   <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten!</span>   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>            <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, [<span class="ruby-value">3</span>, [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>] ] ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">1</span>) <span class="ruby-comment">#=&gt; [1, 2, 3, [4, 5]]</span>
</pre>
            

            
            <div class="method-source-code" id="flatten-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_flatten_bang(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    int mod = 0, level = -1;
    VALUE result, lv;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;lv);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return ary;

    result = flatten(ary, level, &amp;mod);
    if (mod == 0) return Qnil;
    rb_ary_replace(ary, result);

    return ary;
}
            </pre> 
            </div><!-- flatten-21-source -->
            
          </div>

          

          
        </div><!-- flatten-21-method -->
      
        <div id="frozen-3F-method" class="method-detail ">
          <a name="method-i-frozen-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">frozen?  &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Return <code>true</code> if this array is frozen (or temporarily frozen
while being sorted).</p>
            

            
            <div class="method-source-code" id="frozen-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_frozen_p(ary)
    VALUE ary;
{
    if (OBJ_FROZEN(ary)) return Qtrue;
    if (FL_TEST(ary, ARY_TMPLOCK)) return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- frozen-3F-source -->
            
          </div>

          

          
        </div><!-- frozen-3F-method -->
      
        <div id="hash-method" class="method-detail ">
          <a name="method-i-hash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash   &rarr; fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Compute a hash-code for this array. Two arrays with the same content will
have the same hash code (and will compare using <code>eql?</code>).</p>
            

            
            <div class="method-source-code" id="hash-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_hash(ary)
    VALUE ary;
{
    return rb_exec_recursive(recursive_hash, ary, 0);
}
            </pre> 
            </div><!-- hash-source -->
            
          </div>

          

          
        </div><!-- hash-method -->
      
        <div id="include-3F-method" class="method-detail ">
          <a name="method-i-include-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">include?(obj)   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if the given object is present in <em>self</em>
(that is, if any object <code>==</code> <em>anObject</em>),
<code>false</code> otherwise.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&quot;b&quot;</span>)   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&quot;z&quot;</span>)   <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="include-3F-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_includes(ary, item)
    VALUE ary;
    VALUE item;
{
    long i;
    
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
        if (rb_equal(RARRAY(ary)-&gt;ptr[i], item)) {
            return Qtrue;
        }
    }
    return Qfalse;
}
            </pre> 
            </div><!-- include-3F-source -->
            
          </div>

          

          
        </div><!-- include-3F-method -->
      
        <div id="index-method" class="method-detail ">
          <a name="method-i-index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">index(obj)           &rarr;  int or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">index {|item| block} &rarr;  int or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the index of the first object in <em>self</em> such that is
<code>==</code> to <em>obj</em>. If a block is given instead of an
argument, returns first object for which <em>block</em> is true. Returns
<code>nil</code> if no match is found.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&quot;b&quot;</span>)        <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&quot;z&quot;</span>)        <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">==</span><span class="ruby-string">&quot;b&quot;</span>}  <span class="ruby-comment">#=&gt; 1</span>
</pre>

<p>This is an alias of <code>#find_index</code>.</p>
            

            
            <div class="method-source-code" id="index-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_index(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE val;
    long i;

    if (argc  == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
            if (RTEST(rb_yield(RARRAY(ary)-&gt;ptr[i]))) {
                return LONG2NUM(i);
            }
        }
        return Qnil;
    }
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;val);
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
        if (rb_equal(RARRAY(ary)-&gt;ptr[i], val))
            return LONG2NUM(i);
    }
    return Qnil;
}
            </pre> 
            </div><!-- index-source -->
            
          </div>

          

          
        </div><!-- index-method -->
      
        <div id="indexes-method" class="method-detail ">
          <a name="method-i-indexes"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">indexes( i1, i2, ... iN )   &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deprecated; use <code>Array#values_at</code>.</p>
            

            
            <div class="method-source-code" id="indexes-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_indexes(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE new_ary;
    long i;

    rb_warn(&quot;Array#%s is deprecated; use Array#values_at&quot;, rb_id2name(rb_frame_last_func()));
    new_ary = rb_ary_new2(argc);
    for (i=0; i&lt;argc; i++) {
        rb_ary_push(new_ary, rb_ary_aref(1, argv+i, ary));
    }

    return new_ary;
}
            </pre> 
            </div><!-- indexes-source -->
            
          </div>

          

          
        </div><!-- indexes-method -->
      
        <div id="indices-method" class="method-detail ">
          <a name="method-i-indices"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">indices( i1, i2, ... iN )   &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deprecated; use <code>Array#values_at</code>.</p>
            

            
            <div class="method-source-code" id="indices-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_indexes(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE new_ary;
    long i;

    rb_warn(&quot;Array#%s is deprecated; use Array#values_at&quot;, rb_id2name(rb_frame_last_func()));
    new_ary = rb_ary_new2(argc);
    for (i=0; i&lt;argc; i++) {
        rb_ary_push(new_ary, rb_ary_aref(1, argv+i, ary));
    }

    return new_ary;
}
            </pre> 
            </div><!-- indices-source -->
            
          </div>

          

          
        </div><!-- indices-method -->
      
        <div id="initialize_copy-method" class="method-detail ">
          <a name="method-i-initialize_copy"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replace(other_array)  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Replaces the contents of <em>self</em> with the contents of
<em>other_array</em>, truncating or expanding if necessary.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">replace</span>([ <span class="ruby-string">&quot;x&quot;</span>, <span class="ruby-string">&quot;y&quot;</span>, <span class="ruby-string">&quot;z&quot;</span> ])   <span class="ruby-comment">#=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span>
<span class="ruby-identifier">a</span>                              <span class="ruby-comment">#=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="initialize_copy-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_replace(copy, orig)
    VALUE copy, orig;
{
    VALUE shared;

    rb_ary_modify(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;
    shared = ary_make_shared(orig);
    if (RARRAY(copy)-&gt;ptr &amp;&amp; !FL_TEST(copy, ELTS_SHARED))
        free(RARRAY(copy)-&gt;ptr);
    RARRAY(copy)-&gt;ptr = RARRAY(orig)-&gt;ptr;
    RARRAY(copy)-&gt;len = RARRAY(orig)-&gt;len;
    RARRAY(copy)-&gt;aux.shared = shared;
    FL_SET(copy, ELTS_SHARED);

    return copy;
}
            </pre> 
            </div><!-- initialize_copy-source -->
            
          </div>

          

          
        </div><!-- initialize_copy-method -->
      
        <div id="insert-method" class="method-detail ">
          <a name="method-i-insert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">insert(index, obj...)  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Inserts the given values before the element with the given index (which may
be negative).</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w{ a b c d }</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">2</span>, <span class="ruby-value">99</span>)         <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">-2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)   <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, 1, 2, 3, &quot;d&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="insert-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_insert(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long pos;

    if (argc == 1) return ary;
    if (argc &lt; 1) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (at least 1)&quot;);
    }
    pos = NUM2LONG(argv[0]);
    if (pos == -1) {
        pos = RARRAY(ary)-&gt;len;
    }
    if (pos &lt; 0) {
        pos++;
    }
    rb_ary_splice(ary, pos, 0, rb_ary_new4(argc - 1, argv + 1));
    return ary;
}
            </pre> 
            </div><!-- insert-source -->
            
          </div>

          

          
        </div><!-- insert-method -->
      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inspect  &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Create a printable version of <em>array</em>.</p>
            

            
            <div class="method-source-code" id="inspect-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_inspect(ary)
    VALUE ary;
{
    if (RARRAY(ary)-&gt;len == 0) return rb_str_new2(&quot;[]&quot;);
    if (rb_inspecting_p(ary)) return rb_str_new2(&quot;[...]&quot;);
    return rb_protect_inspect(inspect_ary, ary, 0);
}
            </pre> 
            </div><!-- inspect-source -->
            
          </div>

          

          
        </div><!-- inspect-method -->
      
        <div id="join-method" class="method-detail ">
          <a name="method-i-join"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">join(sep=$,)    &rarr; str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a string created by converting each element of the array to a
string, separated by <em>sep</em>.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ].<span class="ruby-identifier">join</span>        <span class="ruby-comment">#=&gt; &quot;abc&quot;</span>
[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ].<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;-&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;a-b-c&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="join-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_join_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE sep;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;sep);
    if (NIL_P(sep)) sep = rb_output_fs;
    
    return rb_ary_join(ary, sep);
}
            </pre> 
            </div><!-- join-source -->
            
          </div>

          

          
        </div><!-- join-method -->
      
        <div id="last-method" class="method-detail ">
          <a name="method-i-last"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">last     &rarr;  obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">last(n)  &rarr;  an_array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the last element(s) of <em>self</em>. If the array is empty, the
first form returns <code>nil</code>.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;w&quot;</span>, <span class="ruby-string">&quot;x&quot;</span>, <span class="ruby-string">&quot;y&quot;</span>, <span class="ruby-string">&quot;z&quot;</span> ].<span class="ruby-identifier">last</span>   <span class="ruby-comment">#=&gt; &quot;z&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="last-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_last(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    if (argc == 0) {
        if (RARRAY(ary)-&gt;len == 0) return Qnil;
        return RARRAY(ary)-&gt;ptr[RARRAY(ary)-&gt;len-1];
    }
    else {
        return ary_shared_first(argc, argv, ary, Qtrue);
    }
}
            </pre> 
            </div><!-- last-source -->
            
          </div>

          

          
        </div><!-- last-method -->
      
        <div id="length-method" class="method-detail ">
          <a name="method-i-length"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">length &rarr; int</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the number of elements in <em>self</em>. May be zero.</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ].<span class="ruby-identifier">length</span>   <span class="ruby-comment">#=&gt; 5</span>
</pre>
            

            
            <div class="method-source-code" id="length-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_length(ary)
    VALUE ary;
{
    return LONG2NUM(RARRAY(ary)-&gt;len);
}
            </pre> 
            </div><!-- length-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="Array.html#method-i-size">size</a>
          </div>
          

          
        </div><!-- length-method -->
      
        <div id="map-method" class="method-detail ">
          <a name="method-i-map"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">map     {|item| block }  &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes <em>block</em> once for each element of <em>self</em>. Creates a 
new array containing the values returned by the block. See also
<code>Enumerable#collect</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;!&quot;</span> }   <span class="ruby-comment">#=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]</span>
<span class="ruby-identifier">a</span>                          <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="map-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_collect(ary)
    VALUE ary;
{
    long i;
    VALUE collect;

    if (!rb_block_given_p()) {
        return rb_ary_new4(RARRAY(ary)-&gt;len, RARRAY(ary)-&gt;ptr);
    }

    collect = rb_ary_new2(RARRAY(ary)-&gt;len);
    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
        rb_ary_push(collect, rb_yield(RARRAY(ary)-&gt;ptr[i]));
    }
    return collect;
}
            </pre> 
            </div><!-- map-source -->
            
          </div>

          

          
        </div><!-- map-method -->
      
        <div id="map-21-method" class="method-detail ">
          <a name="method-i-map-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">map!     {|item| block }   &rarr;   array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes the block once for each element of <em>self</em>, replacing the
element with the value returned by <em>block</em>. See also
<code>Enumerable#collect</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">collect!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;!&quot;</span> }
<span class="ruby-identifier">a</span>             <span class="ruby-comment">#=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]</span>
</pre>
            

            
            <div class="method-source-code" id="map-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_collect_bang(ary)
    VALUE ary;
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
        rb_ary_store(ary, i, rb_yield(RARRAY(ary)-&gt;ptr[i]));
    }
    return ary;
}
            </pre> 
            </div><!-- map-21-source -->
            
          </div>

          

          
        </div><!-- map-21-method -->
      
        <div id="nitems-method" class="method-detail ">
          <a name="method-i-nitems"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">nitems &rarr; int</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the number of non-<code>nil</code> elements in <em>self</em>.</p>

<p>May be zero.</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">3</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">5</span> ].<span class="ruby-identifier">nitems</span>   <span class="ruby-comment">#=&gt; 3</span>
</pre>
            

            
            <div class="method-source-code" id="nitems-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_nitems(ary)
    VALUE ary;
{
    long n = 0;
    VALUE *p, *pend;

    for (p = RARRAY(ary)-&gt;ptr, pend = p + RARRAY(ary)-&gt;len; p &lt; pend; p++) {
        if (!NIL_P(*p)) n++;
    }
    return LONG2NUM(n);
}
            </pre> 
            </div><!-- nitems-source -->
            
          </div>

          

          
        </div><!-- nitems-method -->
      
        <div id="pack-method" class="method-detail ">
          <a name="method-i-pack"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pack ( aTemplateString ) &rarr; aBinaryString</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Packs the contents of <em>arr</em> into a binary sequence according to the
directives in <em>aTemplateString</em> (see the table below) Directives
“A,” “a,” and “Z” may be followed by a count, which gives the width of the
resulting field. The remaining directives also may take a count, indicating
the number of array elements to convert. If the count is an asterisk
(“<code>*</code>”), all remaining array elements will be converted. Any of
the directives “<code>sSiIlL</code>” may be followed by an underscore
(“<code>_</code>”) to use the underlying platform’s native size for the
specified type; otherwise, they use a platform-independent size. Spaces are
ignored in the template string. See also <code>String#unpack</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">n</span> = [ <span class="ruby-value">65</span>, <span class="ruby-value">66</span>, <span class="ruby-value">67</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pack</span>(<span class="ruby-string">&quot;A3A3A3&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;a  b  c  &quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pack</span>(<span class="ruby-string">&quot;a3a3a3&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;a\000\000b\000\000c\000\000&quot;</span>
<span class="ruby-identifier">n</span>.<span class="ruby-identifier">pack</span>(<span class="ruby-string">&quot;ccc&quot;</span>)      <span class="ruby-comment">#=&gt; &quot;ABC&quot;</span>
</pre>

<p>Directives for <code>pack</code>.</p>

<pre>Integer   | Array   |
Directive | Element | Meaning
------------------------------------------------------------------------
   C      | Integer | 8-bit unsigned integer (unsigned char)
   S      | Integer | 16-bit unsigned integer, native endian (uint16_t)
   L      | Integer | 32-bit unsigned integer, native endian (uint32_t)
   Q      | Integer | 64-bit unsigned integer, native endian (uint64_t)
          |         |
   c      | Integer | 8-bit signed integer (char)
   s      | Integer | 16-bit signed integer, native endian (int16_t)
   l      | Integer | 32-bit signed integer, native endian (int32_t)
   q      | Integer | 64-bit signed integer, native endian (int64_t)
          |         | 
   S_     | Integer | unsigned short, native endian
   I, I_  | Integer | unsigned int, native endian
   L_     | Integer | unsigned long, native endian
          |         |
   s_     | Integer | signed short, native endian
   i, i_  | Integer | signed int, native endian
   l_     | Integer | signed long, native endian
          |         |
   n      | Integer | 16-bit unsigned integer, network (big-endian) byte order
   N      | Integer | 32-bit unsigned integer, network (big-endian) byte order
   v      | Integer | 16-bit unsigned integer, VAX (little-endian) byte order
   V      | Integer | 32-bit unsigned integer, VAX (little-endian) byte order
          |         |
   U      | Integer | UTF-8 character
   w      | Integer | BER-compressed integer

Float     |         |
Directive |         | Meaning
------------------------------------------------------------------------
   D, d   | Float   | double-precision float, native format
   F, f   | Float   | single-precision float, native format
   E      | Float   | double-precision float, little-endian byte order
   e      | Float   | single-precision float, little-endian byte order
   G      | Float   | double-precision float, network (big-endian) byte order
   g      | Float   | single-precision float, network (big-endian) byte order

String    |         |
Directive |         | Meaning
------------------------------------------------------------------------
   A      | String  | arbitrary binary string (space padded, count is width)
   a      | String  | arbitrary binary string (null padded, count is width)
   Z      | String  | same as ``a'', except that null is added with *
   B      | String  | bit string (MSB first)
   b      | String  | bit string (LSB first)
   H      | String  | hex string (high nibble first)
   h      | String  | hex string (low nibble first)
   u      | String  | UU-encoded string
   M      | String  | quoted printable, MIME encoding (see RFC2045)
   m      | String  | base64 encoded string (see RFC 2045, count is width)
   P      | String  | pointer to a structure (fixed-length string)
   p      | String  | pointer to a null-terminated string

Misc.     |         |
Directive |         | Meaning
------------------------------------------------------------------------
   @      | ---     | moves to absolute position
   X      | ---     | back up a byte
   x      | ---     | null byte</pre>
            

            
            <div class="method-source-code" id="pack-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
pack_pack(ary, fmt)
    VALUE ary, fmt;
{
    static const char nul10[] = &quot;\0\0\0\0\0\0\0\0\0\0&quot;;
    static const char spc10[] = &quot;          &quot;;
    char *p, *pend;
    VALUE res, from, associates = 0;
    char type;
    long items, len, idx, plen;
    const char *ptr;
#ifdef NATINT_PACK
    int natint;         /* native integer */
#endif
    int signed_p, integer_size, bigendian_p;

    StringValue(fmt);
    p = RSTRING(fmt)-&gt;ptr;
    pend = p + RSTRING(fmt)-&gt;len;
    res = rb_str_buf_new(0);

    items = RARRAY(ary)-&gt;len;
    idx = 0;

#define TOO_FEW (rb_raise(rb_eArgError, toofew), 0)
#define THISFROM (items &gt; 0 ? RARRAY(ary)-&gt;ptr[idx] : TOO_FEW)
#define NEXTFROM (items-- &gt; 0 ? RARRAY(ary)-&gt;ptr[idx++] : TOO_FEW)

    while (p &lt; pend) {
        if (RSTRING(fmt)-&gt;ptr + RSTRING(fmt)-&gt;len != pend) {
            rb_raise(rb_eRuntimeError, &quot;format string modified&quot;);
        }
        type = *p++;           /* get data type */
#ifdef NATINT_PACK
        natint = 0;
#endif

        if (ISSPACE(type)) continue;
        if (type == '#') {
            while ((p &lt; pend) &amp;&amp; (*p != '\n')) {
                p++;
            }
            continue;
        }
        if (*p == '_' || *p == '!') {
            const char *natstr = &quot;sSiIlL&quot;;

            if (strchr(natstr, type)) {
#ifdef NATINT_PACK
                natint = 1;
#endif
                p++;
            }
            else {
                rb_raise(rb_eArgError, &quot;'%c' allowed only after types %s&quot;, *p, natstr);
            }
        }
        if (*p == '*') {       /* set data length */
            len = strchr(&quot;@Xxu&quot;, type) ? 0
                : strchr(&quot;PMm&quot;, type) ? 1
                : items;
            p++;
        }
        else if (ISDIGIT(*p)) {
            len = strtoul(p, (char**)&amp;p, 10);
        }
        else {
            len = 1;
        }

        switch (type) {
          case 'A': case 'a': case 'Z':
          case 'B': case 'b':
          case 'H': case 'h':
            from = NEXTFROM;
            if (NIL_P(from)) {
                ptr = &quot;&quot;;
                plen = 0;
            }
            else {
                StringValue(from);
                ptr = RSTRING(from)-&gt;ptr;
                plen = RSTRING(from)-&gt;len;
                OBJ_INFECT(res, from);
            }

            if (p[-1] == '*')
                len = plen;

            switch (type) {
              case 'a':                /* arbitrary binary string (null padded)  */
              case 'A':                /* ASCII string (space padded) */
              case 'Z':                /* null terminated ASCII string  */
                if (plen &gt;= len) {
                    rb_str_buf_cat(res, ptr, len);
                    if (p[-1] == '*' &amp;&amp; type == 'Z')
                        rb_str_buf_cat(res, nul10, 1);
                }
                else {
                    rb_str_buf_cat(res, ptr, plen);
                    len -= plen;
                    while (len &gt;= 10) {
                        rb_str_buf_cat(res, (type == 'A')?spc10:nul10, 10);
                        len -= 10;
                    }
                    rb_str_buf_cat(res, (type == 'A')?spc10:nul10, len);
                }
                break;

              case 'b':                /* bit string (ascending) */
                {
                    int byte = 0;
                    long i, j = 0;

                    if (len &gt; plen) {
                        j = (len - plen + 1)/2;
                        len = plen;
                    }
                    for (i=0; i++ &lt; len; ptr++) {
                        if (*ptr &amp; 1)
                            byte |= 128;
                        if (i &amp; 7)
                            byte &gt;&gt;= 1;
                        else {
                            char c = byte &amp; 0xff;
                            rb_str_buf_cat(res, &amp;c, 1);
                            byte = 0;
                        }
                    }
                    if (len &amp; 7) {
                        char c;
                        byte &gt;&gt;= 7 - (len &amp; 7);
                        c = byte &amp; 0xff;
                        rb_str_buf_cat(res, &amp;c, 1);
                    }
                    len = j;
                    goto grow;
                }
                break;

              case 'B':                /* bit string (descending) */
                {
                    int byte = 0;
                    long i, j = 0;

                    if (len &gt; plen) {
                        j = (len - plen + 1)/2;
                        len = plen;
                    }
                    for (i=0; i++ &lt; len; ptr++) {
                        byte |= *ptr &amp; 1;
                        if (i &amp; 7)
                            byte &lt;&lt;= 1;
                        else {
                            char c = byte &amp; 0xff;
                            rb_str_buf_cat(res, &amp;c, 1);
                            byte = 0;
                        }
                    }
                    if (len &amp; 7) {
                        char c;
                        byte &lt;&lt;= 7 - (len &amp; 7);
                        c = byte &amp; 0xff;
                        rb_str_buf_cat(res, &amp;c, 1);
                    }
                    len = j;
                    goto grow;
                }
                break;

              case 'h':                /* hex string (low nibble first) */
                {
                    int byte = 0;
                    long i, j = 0;

                    if (len &gt; plen) {
                        j = (len + 1) / 2 - (plen + 1) / 2;
                        len = plen;
                    }
                    for (i=0; i++ &lt; len; ptr++) {
                        if (ISALPHA(*ptr))
                            byte |= (((*ptr &amp; 15) + 9) &amp; 15) &lt;&lt; 4;
                        else
                            byte |= (*ptr &amp; 15) &lt;&lt; 4;
                        if (i &amp; 1)
                            byte &gt;&gt;= 4;
                        else {
                            char c = byte &amp; 0xff;
                            rb_str_buf_cat(res, &amp;c, 1);
                            byte = 0;
                        }
                    }
                    if (len &amp; 1) {
                        char c = byte &amp; 0xff;
                        rb_str_buf_cat(res, &amp;c, 1);
                    }
                    len = j;
                    goto grow;
                }
                break;

              case 'H':                /* hex string (high nibble first) */
                {
                    int byte = 0;
                    long i, j = 0;

                    if (len &gt; plen) {
                        j = (len + 1) / 2 - (plen + 1) / 2;
                        len = plen;
                    }
                    for (i=0; i++ &lt; len; ptr++) {
                        if (ISALPHA(*ptr))
                            byte |= ((*ptr &amp; 15) + 9) &amp; 15;
                        else
                            byte |= *ptr &amp; 15;
                        if (i &amp; 1)
                            byte &lt;&lt;= 4;
                        else {
                            char c = byte &amp; 0xff;
                            rb_str_buf_cat(res, &amp;c, 1);
                            byte = 0;
                        }
                    }
                    if (len &amp; 1) {
                        char c = byte &amp; 0xff;
                        rb_str_buf_cat(res, &amp;c, 1);
                    }
                    len = j;
                    goto grow;
                }
                break;
            }
            break;

          case 'c':            /* signed char */
          case 'C':            /* unsigned char */
            while (len-- &gt; 0) {
                char c;

                from = NEXTFROM;
                c = num2i32(from);
                rb_str_buf_cat(res, &amp;c, sizeof(char));
            }
            break;

          case 's':            /* signed short */
            signed_p = 1;
            integer_size = NATINT_LEN(short, 2);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'S':            /* unsigned short */
            signed_p = 0;
            integer_size = NATINT_LEN(short, 2);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'i':            /* signed int */
            signed_p = 1;
            integer_size = (int)sizeof(int);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'I':            /* unsigned int */
            signed_p = 0;
            integer_size = (int)sizeof(int);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'l':            /* signed long */
            signed_p = 1;
            integer_size = NATINT_LEN(long, 4);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'L':            /* unsigned long */
            signed_p = 0;
            integer_size = NATINT_LEN(long, 4);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'q':            /* signed quad (64bit) int */
            signed_p = 1;
            integer_size = 8;
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'Q':            /* unsigned quad (64bit) int */
            signed_p = 0;
            integer_size = 8;
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'n':            /* unsigned short (network byte-order)  */
            signed_p = 0;
            integer_size = 2;
            bigendian_p = 1;
            goto pack_integer;

          case 'N':            /* unsigned long (network byte-order) */
            signed_p = 0;
            integer_size = 4;
            bigendian_p = 1;
            goto pack_integer;

          case 'v':            /* unsigned short (VAX byte-order) */
            signed_p = 0;
            integer_size = 2;
            bigendian_p = 0;
            goto pack_integer;

          case 'V':            /* unsigned long (VAX byte-order) */
            signed_p = 0;
            integer_size = 4;
            bigendian_p = 0;
            goto pack_integer;

          pack_integer:
            switch (integer_size) {
#if defined(HAVE_INT16_T) &amp;&amp; !defined(FORCE_BIG_PACK)
              case SIZEOF_INT16_T:
                while (len-- &gt; 0) {
                    union {
                        int16_t i;
                        char a[sizeof(int16_t)];
                    } v;

                    from = NEXTFROM;
                    v.i = (int16_t)num2i32(from);
                    if (bigendian_p != BIGENDIAN_P()) v.i = swap16(v.i);
                    rb_str_buf_cat(res, v.a, sizeof(int16_t));
                }
                break;
#endif

#if defined(HAVE_INT32_T) &amp;&amp; !defined(FORCE_BIG_PACK)
              case SIZEOF_INT32_T:
                while (len-- &gt; 0) {
                    union {
                        int32_t i;
                        char a[sizeof(int32_t)];
                    } v;

                    from = NEXTFROM;
                    v.i = (int32_t)num2i32(from);
                    if (bigendian_p != BIGENDIAN_P()) v.i = swap32(v.i);
                    rb_str_buf_cat(res, v.a, sizeof(int32_t));
                }
                break;
#endif

#if defined(HAVE_INT64_T) &amp;&amp; SIZEOF_LONG == SIZEOF_INT64_T &amp;&amp; !defined(FORCE_BIG_PACK)
              case SIZEOF_INT64_T:
                while (len-- &gt; 0) {
                    union {
                        int64_t i;
                        char a[sizeof(int64_t)];
                    } v;

                    from = NEXTFROM;
                    v.i = num2i32(from); /* can return 64bit value if SIZEOF_LONG == SIZEOF_INT64_T */
                    if (bigendian_p != BIGENDIAN_P()) v.i = swap64(v.i);
                    rb_str_buf_cat(res, v.a, sizeof(int64_t));
                }
                break;
#endif

              default:
                if (integer_size &gt; MAX_INTEGER_PACK_SIZE)
                    rb_bug(&quot;unexpected intger size for pack: %d&quot;, integer_size);
                while (len-- &gt; 0) {
                    union {
                        unsigned long i[(MAX_INTEGER_PACK_SIZE+SIZEOF_LONG-1)/SIZEOF_LONG];
                        char a[(MAX_INTEGER_PACK_SIZE+SIZEOF_LONG-1)/SIZEOF_LONG*SIZEOF_LONG];
                    } v;
                    int num_longs = (integer_size+SIZEOF_LONG-1)/SIZEOF_LONG;
                    int i;

                    from = NEXTFROM;
                    from = rb_to_int(from);
                    if (integer_size == QUAD_SIZE)
                        rb_quad_pack(v.a, from); /* RangeError compatibility for Ruby 1.8. */
                    rb_big_pack(from, v.i, num_longs);
                    if (bigendian_p) {
                        for (i = 0; i &lt; num_longs/2; i++) {
                            unsigned long t = v.i[i];
                            v.i[i] = v.i[num_longs-1-i];
                            v.i[num_longs-1-i] = t;
                        }
                    }
                    if (bigendian_p != BIGENDIAN_P()) {
                        for (i = 0; i &lt; num_longs; i++)
                            v.i[i] = swapl(v.i[i]);
                    }
                    rb_str_buf_cat(res,
                                   bigendian_p ?
                                     v.a + sizeof(long)*num_longs - integer_size :
                                     v.a,
                                   integer_size);
                }
                break;
            }
            break;

          case 'f':            /* single precision float in native format */
          case 'F':            /* ditto */
            while (len-- &gt; 0) {
                float f;

                from = NEXTFROM;
                f = RFLOAT(rb_Float(from))-&gt;value;
                rb_str_buf_cat(res, (char*)&amp;f, sizeof(float));
            }
            break;

          case 'e':            /* single precision float in VAX byte-order */
            while (len-- &gt; 0) {
                float f;
                FLOAT_CONVWITH(ftmp);

                from = NEXTFROM;
                f = RFLOAT(rb_Float(from))-&gt;value;
                f = HTOVF(f,ftmp);
                rb_str_buf_cat(res, (char*)&amp;f, sizeof(float));
            }
            break;

          case 'E':            /* double precision float in VAX byte-order */
            while (len-- &gt; 0) {
                double d;
                DOUBLE_CONVWITH(dtmp);

                from = NEXTFROM;
                d = RFLOAT(rb_Float(from))-&gt;value;
                d = HTOVD(d,dtmp);
                rb_str_buf_cat(res, (char*)&amp;d, sizeof(double));
            }
            break;

          case 'd':            /* double precision float in native format */
          case 'D':            /* ditto */
            while (len-- &gt; 0) {
                double d;

                from = NEXTFROM;
                d = RFLOAT(rb_Float(from))-&gt;value;
                rb_str_buf_cat(res, (char*)&amp;d, sizeof(double));
            }
            break;

          case 'g':            /* single precision float in network byte-order */
            while (len-- &gt; 0) {
                float f;
                FLOAT_CONVWITH(ftmp);

                from = NEXTFROM;
                f = RFLOAT(rb_Float(from))-&gt;value;
                f = HTONF(f,ftmp);
                rb_str_buf_cat(res, (char*)&amp;f, sizeof(float));
            }
            break;

          case 'G':            /* double precision float in network byte-order */
            while (len-- &gt; 0) {
                double d;
                DOUBLE_CONVWITH(dtmp);

                from = NEXTFROM;
                d = RFLOAT(rb_Float(from))-&gt;value;
                d = HTOND(d,dtmp);
                rb_str_buf_cat(res, (char*)&amp;d, sizeof(double));
            }
            break;

          case 'x':            /* null byte */
          grow:
            while (len &gt;= 10) {
                rb_str_buf_cat(res, nul10, 10);
                len -= 10;
            }
            rb_str_buf_cat(res, nul10, len);
            break;

          case 'X':            /* back up byte */
          shrink:
            plen = RSTRING(res)-&gt;len;
            if (plen &lt; len)
                rb_raise(rb_eArgError, &quot;X outside of string&quot;);
            RSTRING(res)-&gt;len = plen - len;
            RSTRING(res)-&gt;ptr[plen - len] = '\0';
            break;

          case '@':            /* null fill to absolute position */
            len -= RSTRING(res)-&gt;len;
            if (len &gt; 0) goto grow;
            len = -len;
            if (len &gt; 0) goto shrink;
            break;

          case '%':
            rb_raise(rb_eArgError, &quot;%% is not supported&quot;);
            break;

          case 'U':            /* Unicode character */
            while (len-- &gt; 0) {
                long l;
                char buf[8];
                int le;

                from = NEXTFROM;
                from = rb_to_int(from);
                l = NUM2INT(from);
                if (l &lt; 0) {
                    rb_raise(rb_eRangeError, &quot;pack(U): value out of range&quot;);
                }
                le = uv_to_utf8(buf, l);
                rb_str_buf_cat(res, (char*)buf, le);
            }
            break;

          case 'u':            /* uuencoded string */
          case 'm':            /* base64 encoded string */
            from = NEXTFROM;
            StringValue(from);
            ptr = RSTRING(from)-&gt;ptr;
            plen = RSTRING(from)-&gt;len;

            if (len &lt;= 2)
                len = 45;
            else
                len = len / 3 * 3;
            while (plen &gt; 0) {
                long todo;

                if (plen &gt; len)
                    todo = len;
                else
                    todo = plen;
                encodes(res, ptr, todo, type);
                plen -= todo;
                ptr += todo;
            }
            break;

          case 'M':            /* quoted-printable encoded string */
            from = rb_obj_as_string(NEXTFROM);
            if (len &lt;= 1)
                len = 72;
            qpencode(res, from, len);
            break;

          case 'P':            /* pointer to packed byte string */
            from = THISFROM;
            if (!NIL_P(from)) {
                StringValue(from);
                if (RSTRING(from)-&gt;len &lt; len) {
                    rb_raise(rb_eArgError, &quot;too short buffer for P(%ld for %ld)&quot;,
                             RSTRING(from)-&gt;len, len);
                }
            }
            len = 1;
            /* FALL THROUGH */
          case 'p':            /* pointer to string */
            while (len-- &gt; 0) {
                char *t;
                from = NEXTFROM;
                if (NIL_P(from)) {
                    t = 0;
                }
                else {
                    t = StringValuePtr(from);
                }
                if (!associates) {
                    associates = rb_ary_new();
                }
                rb_ary_push(associates, from);
                rb_obj_taint(from);
                rb_str_buf_cat(res, (char*)&amp;t, sizeof(char*));
            }
            break;

          case 'w':            /* BER compressed integer  */
            while (len-- &gt; 0) {
                unsigned long ul;
                VALUE buf = rb_str_new(0, 0);
                char c, *bufs, *bufe;

                from = NEXTFROM;
                if (TYPE(from) == T_BIGNUM) {
                    VALUE big128 = rb_uint2big(128);
                    while (TYPE(from) == T_BIGNUM) {
                        from = rb_big_divmod(from, big128);
                        c = NUM2INT(RARRAY(from)-&gt;ptr[1]) | 0x80; /* mod */
                        rb_str_buf_cat(buf, &amp;c, sizeof(char));
                        from = RARRAY(from)-&gt;ptr[0]; /* div */
                    }
                }

                {
                    long l = NUM2LONG(from);
                    if (l &lt; 0) {
                        rb_raise(rb_eArgError, &quot;can't compress negative numbers&quot;);
                    }
                    ul = l;
                }

                while (ul) {
                    c = ((ul &amp; 0x7f) | 0x80);
                    rb_str_buf_cat(buf, &amp;c, sizeof(char));
                    ul &gt;&gt;=  7;
                }

                if (RSTRING(buf)-&gt;len) {
                    bufs = RSTRING(buf)-&gt;ptr;
                    bufe = bufs + RSTRING(buf)-&gt;len - 1;
                    *bufs &amp;= 0x7f; /* clear continue bit */
                    while (bufs &lt; bufe) { /* reverse */
                        c = *bufs;
                        *bufs++ = *bufe;
                        *bufe-- = c;
                    }
                    rb_str_buf_cat(res, RSTRING(buf)-&gt;ptr, RSTRING(buf)-&gt;len);
                }
                else {
                    c = 0;
                    rb_str_buf_cat(res, &amp;c, sizeof(char));
                }
            }
            break;

          default:
            break;
        }
    }

    if (associates) {
        rb_str_associate(res, associates);
    }
    OBJ_INFECT(res, fmt);
    return res;
}
            </pre> 
            </div><!-- pack-source -->
            
          </div>

          

          
        </div><!-- pack-method -->
      
        <div id="permutation-method" class="method-detail ">
          <a name="method-i-permutation"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">permutation { |p| block }          &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">permutation                        &rarr; enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">permutation(n) { |p| block }       &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">permutation(n)                     &rarr; enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>When invoked with a block, yield all permutations of length <em>n</em> of
the elements of <em>ary</em>, then return the array itself. If <em>n</em>
is not specified, yield all permutations of all elements. The
implementation makes no guarantees about the order in which  the
permutations are yielded.</p>

<p>When invoked without a block, return an enumerator object instead.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>.<span class="ruby-identifier">to_a</span>     <span class="ruby-comment">#=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">1</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1],[2],[3]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">2</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">3</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">0</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[]] # one permutation of length 0</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">4</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; []   # no permutations of length 4</span>
</pre>
            

            
            <div class="method-source-code" id="permutation-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_permutation(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE num;
    long r, n, i;

    n = RARRAY(ary)-&gt;len;                  /* Array length */
    RETURN_ENUMERATOR(ary, argc, argv);   /* Return enumerator if no block */
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;num);
    r = NIL_P(num) ? n : NUM2LONG(num);   /* Permutation size from argument */

    if (r &lt; 0 || n &lt; r) { 
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
            rb_yield(rb_ary_new3(1, RARRAY(ary)-&gt;ptr[i]));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0 = tmpbuf(n,sizeof(long));
        long *p = (long*)RSTRING(t0)-&gt;ptr;
        volatile VALUE t1 = tmpbuf(n,sizeof(int));
        int *used = (int*)RSTRING(t1)-&gt;ptr;
        VALUE ary0 = ary_make_shared(ary); /* private defensive copy of ary */

        for (i = 0; i &lt; n; i++) used[i] = 0; /* initialize array */

        permute0(n, r, p, 0, used, ary0); /* compute and yield permutations */
        RB_GC_GUARD(t0);
        RB_GC_GUARD(t1);
    }
    return ary;
}
            </pre> 
            </div><!-- permutation-source -->
            
          </div>

          

          
        </div><!-- permutation-method -->
      
        <div id="pop-method" class="method-detail ">
          <a name="method-i-pop"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pop    &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">pop(n) &rarr; array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes the last element from <em>self</em> and returns it, or
<code>nil</code> if the array is empty.</p>

<p>If a number <em>n</em> is given, returns an array of the last n elements
(or less) just like <code>array.slice!(-n, n)</code> does.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pop</span>     <span class="ruby-comment">#=&gt; &quot;d&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pop</span>(<span class="ruby-value">2</span>)  <span class="ruby-comment">#=&gt; [&quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>         <span class="ruby-comment">#=&gt; [&quot;a&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="pop-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_pop_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE result;

    if (argc == 0) {
        return rb_ary_pop(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_shared_first(argc, argv, ary, Qtrue);
    RARRAY(ary)-&gt;len -= RARRAY(result)-&gt;len;
    return result;
}
            </pre> 
            </div><!-- pop-source -->
            
          </div>

          

          
        </div><!-- pop-method -->
      
        <div id="product-method" class="method-detail ">
          <a name="method-i-product"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">product(other_ary, ...)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of all combinations of elements from all arrays. The
length of the returned array is the product of the length of ary and the
argument arrays</p>

<pre class="ruby">[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>].<span class="ruby-identifier">product</span>([<span class="ruby-value">4</span>,<span class="ruby-value">5</span>])     <span class="ruby-comment"># =&gt; [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]</span>
[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>].<span class="ruby-identifier">product</span>([<span class="ruby-value">1</span>,<span class="ruby-value">2</span>])       <span class="ruby-comment"># =&gt; [[1,1],[1,2],[2,1],[2,2]]</span>
[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>].<span class="ruby-identifier">product</span>([<span class="ruby-value">3</span>,<span class="ruby-value">4</span>],[<span class="ruby-value">5</span>,<span class="ruby-value">6</span>]) <span class="ruby-comment"># =&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6],</span>
                           <span class="ruby-comment">#     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]</span>
[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>].<span class="ruby-identifier">product</span>()            <span class="ruby-comment"># =&gt; [[1],[2]]</span>
[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>].<span class="ruby-identifier">product</span>([])          <span class="ruby-comment"># =&gt; []</span>
</pre>
            

            
            <div class="method-source-code" id="product-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_product(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    int n = argc+1;    /* How many arrays we're operating on */
    volatile VALUE t0 = tmpbuf(n, sizeof(VALUE));
    volatile VALUE t1 = tmpbuf(n, sizeof(int));
    VALUE *arrays = (VALUE*)RSTRING(t0)-&gt;ptr; /* The arrays we're computing the product of */
    int *counters = (int*)RSTRING(t1)-&gt;ptr; /* The current position in each one */
    VALUE result;      /* The array we'll be returning */
    long i,j;
    long resultlen = 1;

    RBASIC(t0)-&gt;klass = 0;
    RBASIC(t1)-&gt;klass = 0;

    /* initialize the arrays of arrays */
    arrays[0] = ary;
    for (i = 1; i &lt; n; i++) arrays[i] = to_ary(argv[i-1]);
    
    /* initialize the counters for the arrays */
    for (i = 0; i &lt; n; i++) counters[i] = 0;

    /* Compute the length of the result array; return [] if any is empty */
    for (i = 0; i &lt; n; i++) {
        long k = RARRAY(arrays[i])-&gt;len, l = resultlen;
        if (k == 0) return rb_ary_new2(0);
        resultlen *= k;
        if (resultlen &lt; k || resultlen &lt; l || resultlen / k != l) {
            rb_raise(rb_eRangeError, &quot;too big to product&quot;);
        }
    }

    /* Otherwise, allocate and fill in an array of results */
    result = rb_ary_new2(resultlen);
    for (i = 0; i &lt; resultlen; i++) {
        int m;
        /* fill in one subarray */
        VALUE subarray = rb_ary_new2(n);
        for (j = 0; j &lt; n; j++) {
            rb_ary_push(subarray, rb_ary_entry(arrays[j], counters[j]));
        }

        /* put it on the result array */
        rb_ary_push(result, subarray);

        /*
         * Increment the last counter.  If it overflows, reset to 0
         * and increment the one before it.
         */
        m = n-1;
        counters[m]++;
        while (m &gt; 0 &amp;&amp; counters[m] == RARRAY(arrays[m])-&gt;len) {
            counters[m] = 0;
            m--;
            counters[m]++;
        }
    }

    return result;
}
            </pre> 
            </div><!-- product-source -->
            
          </div>

          

          
        </div><!-- product-method -->
      
        <div id="push-method" class="method-detail ">
          <a name="method-i-push"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">push(obj, ... )   &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Append—Pushes the given object(s) on to the end of this array. This
expression returns the array itself, so several appends may be chained
together.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">push</span>(<span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span>, <span class="ruby-string">&quot;f&quot;</span>)  
        <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="push-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_push_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    while (argc--) {
        rb_ary_push(ary, *argv++);
    }
    return ary;
}
            </pre> 
            </div><!-- push-source -->
            
          </div>

          

          
        </div><!-- push-method -->
      
        <div id="rassoc-method" class="method-detail ">
          <a name="method-i-rassoc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rassoc(key) &rarr; an_array or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Searches through the array whose elements are also arrays. Compares
<em>key</em> with the second element of each contained array using
<code>==</code>. Returns the first contained array that matches. See also
<code>Array#assoc</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ [ <span class="ruby-value">1</span>, <span class="ruby-string">&quot;one&quot;</span>], [<span class="ruby-value">2</span>, <span class="ruby-string">&quot;two&quot;</span>], [<span class="ruby-value">3</span>, <span class="ruby-string">&quot;three&quot;</span>], [<span class="ruby-string">&quot;ii&quot;</span>, <span class="ruby-string">&quot;two&quot;</span>] ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rassoc</span>(<span class="ruby-string">&quot;two&quot;</span>)    <span class="ruby-comment">#=&gt; [2, &quot;two&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rassoc</span>(<span class="ruby-string">&quot;four&quot;</span>)   <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="rassoc-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_rassoc(ary, value)
    VALUE ary, value;
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY(ary)-&gt;len; ++i) {
        v = RARRAY(ary)-&gt;ptr[i];
        if (TYPE(v) == T_ARRAY &amp;&amp;
            RARRAY(v)-&gt;len &gt; 1 &amp;&amp;
            rb_equal(RARRAY(v)-&gt;ptr[1], value))
            return v;
    }
    return Qnil;
}
            </pre> 
            </div><!-- rassoc-source -->
            
          </div>

          

          
        </div><!-- rassoc-method -->
      
        <div id="reject-method" class="method-detail ">
          <a name="method-i-reject"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reject {|item| block }  &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array containing the items in <em>self</em> for which the
block is not true.</p>
            

            
            <div class="method-source-code" id="reject-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_reject(ary)
    VALUE ary;
{
    RETURN_ENUMERATOR(ary, 0, 0);
    ary = rb_ary_dup(ary);
    rb_ary_reject_bang(ary);
    return ary;
}
            </pre> 
            </div><!-- reject-source -->
            
          </div>

          

          
        </div><!-- reject-method -->
      
        <div id="reject-21-method" class="method-detail ">
          <a name="method-i-reject-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reject! {|item| block }  &rarr; array or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Equivalent to <code>Array#delete_if</code>, deleting elements from
<em>self</em> for which the block evaluates to true, but returns
<code>nil</code> if no changes were made. Also see
<code>Enumerable#reject</code>.</p>
            

            
            <div class="method-source-code" id="reject-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_reject_bang(ary)
    VALUE ary;
{
    long i1, i2;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i1 = i2 = 0; i1 &lt; RARRAY(ary)-&gt;len; i1++) {
        VALUE v = RARRAY(ary)-&gt;ptr[i1];
        if (RTEST(rb_yield(v))) continue;
        if (i1 != i2) {
            rb_ary_store(ary, i2, v);
        }
        i2++;
    }
    if (RARRAY(ary)-&gt;len == i2) return Qnil;
    if (i2 &lt; RARRAY(ary)-&gt;len)
        RARRAY(ary)-&gt;len = i2;

    return ary;
}
            </pre> 
            </div><!-- reject-21-source -->
            
          </div>

          

          
        </div><!-- reject-21-method -->
      
        <div id="replace-method" class="method-detail ">
          <a name="method-i-replace"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replace(other_array)  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Replaces the contents of <em>self</em> with the contents of
<em>other_array</em>, truncating or expanding if necessary.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">replace</span>([ <span class="ruby-string">&quot;x&quot;</span>, <span class="ruby-string">&quot;y&quot;</span>, <span class="ruby-string">&quot;z&quot;</span> ])   <span class="ruby-comment">#=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span>
<span class="ruby-identifier">a</span>                              <span class="ruby-comment">#=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="replace-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_replace(copy, orig)
    VALUE copy, orig;
{
    VALUE shared;

    rb_ary_modify(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;
    shared = ary_make_shared(orig);
    if (RARRAY(copy)-&gt;ptr &amp;&amp; !FL_TEST(copy, ELTS_SHARED))
        free(RARRAY(copy)-&gt;ptr);
    RARRAY(copy)-&gt;ptr = RARRAY(orig)-&gt;ptr;
    RARRAY(copy)-&gt;len = RARRAY(orig)-&gt;len;
    RARRAY(copy)-&gt;aux.shared = shared;
    FL_SET(copy, ELTS_SHARED);

    return copy;
}
            </pre> 
            </div><!-- replace-source -->
            
          </div>

          

          
        </div><!-- replace-method -->
      
        <div id="reverse-method" class="method-detail ">
          <a name="method-i-reverse"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array containing <em>self</em>’s elements in reverse order.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ].<span class="ruby-identifier">reverse</span>   <span class="ruby-comment">#=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
[ <span class="ruby-value">1</span> ].<span class="ruby-identifier">reverse</span>               <span class="ruby-comment">#=&gt; [1]</span>
</pre>
            

            
            <div class="method-source-code" id="reverse-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_reverse_m(ary)
    VALUE ary;
{
    return rb_ary_reverse(rb_ary_dup(ary));
}
            </pre> 
            </div><!-- reverse-source -->
            
          </div>

          

          
        </div><!-- reverse-method -->
      
        <div id="reverse-21-method" class="method-detail ">
          <a name="method-i-reverse-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse!   &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reverses <em>self</em> in place.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse!</span>       <span class="ruby-comment">#=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
<span class="ruby-identifier">a</span>                <span class="ruby-comment">#=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="reverse-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_reverse_bang(ary)
    VALUE ary;
{
    return rb_ary_reverse(ary);
}
            </pre> 
            </div><!-- reverse-21-source -->
            
          </div>

          

          
        </div><!-- reverse-21-method -->
      
        <div id="reverse_each-method" class="method-detail ">
          <a name="method-i-reverse_each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse_each {|item| block }</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Same as <code>Array#each</code>, but traverses <em>self</em> in reverse
order.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse_each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">x</span>, <span class="ruby-string">&quot; &quot;</span> }
</pre>

<p>produces:</p>

<pre>c b a</pre>
            

            
            <div class="method-source-code" id="reverse_each-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_reverse_each(ary)
    VALUE ary;
{
    long len;

    RETURN_ENUMERATOR(ary, 0, 0);
    len = RARRAY(ary)-&gt;len;
    while (len--) {
        rb_yield(RARRAY(ary)-&gt;ptr[len]);
        if (RARRAY(ary)-&gt;len &lt; len) {
            len = RARRAY(ary)-&gt;len;
        }
    }
    return ary;
}
            </pre> 
            </div><!-- reverse_each-source -->
            
          </div>

          

          
        </div><!-- reverse_each-method -->
      
        <div id="rindex-method" class="method-detail ">
          <a name="method-i-rindex"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rindex(obj)    &rarr;  int or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the index of the last object in <em>array</em> <code>==</code> to
<em>obj</em>. If a block is given instead of an argument, returns first
object for which <em>block</em> is true. Returns <code>nil</code> if no
match is found.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&quot;b&quot;</span>)        <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&quot;z&quot;</span>)        <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rindex</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">==</span><span class="ruby-string">&quot;b&quot;</span>}  <span class="ruby-comment">#=&gt; 3</span>
</pre>
            

            
            <div class="method-source-code" id="rindex-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_rindex(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE val;
    long i = RARRAY(ary)-&gt;len;

    if (argc == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        while (i--) {
            if (RTEST(rb_yield(RARRAY(ary)-&gt;ptr[i])))
                return LONG2NUM(i);
            if (i &gt; RARRAY(ary)-&gt;len) {
                i = RARRAY(ary)-&gt;len;
            }
        }
        return Qnil;
    }
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;val);
    while (i--) {
        if (rb_equal(RARRAY(ary)-&gt;ptr[i], val))
            return LONG2NUM(i);
        if (i &gt; RARRAY(ary)-&gt;len) {
            i = RARRAY(ary)-&gt;len;
        }
    }
    return Qnil;
}
            </pre> 
            </div><!-- rindex-source -->
            
          </div>

          

          
        </div><!-- rindex-method -->
      
        <div id="select-method" class="method-detail ">
          <a name="method-i-select"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select {|item| block } &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes the block passing in successive elements from <em>array</em>,
returning an array containing those elements for which the block returns a
true value (equivalent to <code>Enumerable#select</code>).</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w{ a b c d e f }</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/[aeiou]/</span>}   <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;e&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="select-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_select(ary)
    VALUE ary;
{
    VALUE result;
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    result = rb_ary_new2(RARRAY(ary)-&gt;len);
    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
        if (RTEST(rb_yield(RARRAY(ary)-&gt;ptr[i]))) {
            rb_ary_push(result, rb_ary_elt(ary, i));
        }
    }
    return result;
}
            </pre> 
            </div><!-- select-source -->
            
          </div>

          

          
        </div><!-- select-method -->
      
        <div id="shift-method" class="method-detail ">
          <a name="method-i-shift"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">shift    &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">shift(n) &rarr; array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the first element of <em>self</em> and removes it (shifting all
other elements down by one). Returns <code>nil</code> if the array is
empty.</p>

<p>If a number <em>n</em> is given, returns an array of the first n elements
(or less) just like <code>array.slice!(0, n)</code> does.</p>

<pre class="ruby"><span class="ruby-identifier">args</span> = [ <span class="ruby-string">&quot;-m&quot;</span>, <span class="ruby-string">&quot;-q&quot;</span>, <span class="ruby-string">&quot;filename&quot;</span> ]
<span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span>     <span class="ruby-comment">#=&gt; &quot;-m&quot;</span>
<span class="ruby-identifier">args</span>           <span class="ruby-comment">#=&gt; [&quot;-q&quot;, &quot;filename&quot;]</span>

<span class="ruby-identifier">args</span> = [ <span class="ruby-string">&quot;-m&quot;</span>, <span class="ruby-string">&quot;-q&quot;</span>, <span class="ruby-string">&quot;filename&quot;</span> ]
<span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span>(<span class="ruby-value">2</span>)  <span class="ruby-comment">#=&gt; [&quot;-m&quot;, &quot;-q&quot;]</span>
<span class="ruby-identifier">args</span>           <span class="ruby-comment">#=&gt; [&quot;filename&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="shift-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_shift_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE result;
    long n;

    if (argc == 0) {
        return rb_ary_shift(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_shared_first(argc, argv, ary, Qfalse);
    n = RARRAY(result)-&gt;len;
    if (FL_TEST(ary, ELTS_SHARED)) {
        RARRAY(ary)-&gt;ptr += n;
        RARRAY(ary)-&gt;len -= n;
        }
    else {
        MEMMOVE(RARRAY(ary)-&gt;ptr, RARRAY(ary)-&gt;ptr+n, VALUE, RARRAY(ary)-&gt;len-n);
        RARRAY(ary)-&gt;len -= n;
    }

    return result;
}
            </pre> 
            </div><!-- shift-source -->
            
          </div>

          

          
        </div><!-- shift-method -->
      
        <div id="shuffle-method" class="method-detail ">
          <a name="method-i-shuffle"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">shuffle &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array with elements of this array shuffled.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ]           <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle</span>                 <span class="ruby-comment">#=&gt; [2, 3, 1]</span>
</pre>
            

            
            <div class="method-source-code" id="shuffle-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_shuffle(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_shuffle_bang(ary);
    return ary;
}
            </pre> 
            </div><!-- shuffle-source -->
            
          </div>

          

          
        </div><!-- shuffle-method -->
      
        <div id="shuffle-21-method" class="method-detail ">
          <a name="method-i-shuffle-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">shuffle!        &rarr; array or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Shuffles elements in <em>self</em> in place.</p>
            

            
            <div class="method-source-code" id="shuffle-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_shuffle_bang(ary)
    VALUE ary;
{
    long i = RARRAY(ary)-&gt;len;

    rb_ary_modify(ary);
    while (i) {
        long j = rb_genrand_real()*i;
        VALUE tmp = RARRAY(ary)-&gt;ptr[--i];
        RARRAY(ary)-&gt;ptr[i] = RARRAY(ary)-&gt;ptr[j];
        RARRAY(ary)-&gt;ptr[j] = tmp;
    }
    return ary;
}
            </pre> 
            </div><!-- shuffle-21-source -->
            
          </div>

          

          
        </div><!-- shuffle-21-method -->
      
        <div id="size-method" class="method-detail method-alias">
          <a name="method-i-size"></a>

          
          <div class="method-heading">
            <span class="method-name">size</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="Array.html#method-i-length">length</a>
          </div>
          
        </div><!-- size-method -->
      
        <div id="slice-method" class="method-detail ">
          <a name="method-i-slice"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">slice(index)          &rarr; obj      or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(start, length)  &rarr; an_array or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(range)          &rarr; an_array or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Element Reference—Returns the element at <em>index</em>, or returns a
subarray starting at <em>start</em> and continuing for <em>length</em>
elements, or returns a subarray specified by <em>range</em>. Negative
indices count backward from the end of the array (-1 is the last element).
Returns nil if the index (or starting index) are out of range.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span> ]
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">+</span>  <span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>]    <span class="ruby-comment">#=&gt; &quot;cab&quot;</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span>]                   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]                <span class="ruby-comment">#=&gt; [ &quot;b&quot;, &quot;c&quot; ]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>]                <span class="ruby-comment">#=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">7</span>]                <span class="ruby-comment">#=&gt; [ &quot;e&quot; ]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]               <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-3</span>, <span class="ruby-value">3</span>]               <span class="ruby-comment">#=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]</span>
<span class="ruby-comment"># special cases</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">5</span>]                   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">5</span>, <span class="ruby-value">1</span>]                <span class="ruby-comment">#=&gt; []</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]               <span class="ruby-comment">#=&gt; []</span>
</pre>
            

            
            <div class="method-source-code" id="slice-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_aref(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE arg;
    long beg, len;

    if (argc == 2) {
        if (SYMBOL_P(argv[0])) {
            rb_raise(rb_eTypeError, &quot;Symbol as array index&quot;);
        }
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        if (beg &lt; 0) {
            beg += RARRAY(ary)-&gt;len;
        }
        return rb_ary_subseq(ary, beg, len);
    }
    if (argc != 1) {
        rb_scan_args(argc, argv, &quot;11&quot;, 0, 0);
    }
    arg = argv[0];
    /* special case - speeding up */
    if (FIXNUM_P(arg)) {
        return rb_ary_entry(ary, FIX2LONG(arg));
    }
    if (SYMBOL_P(arg)) {
        rb_raise(rb_eTypeError, &quot;Symbol as array index&quot;);
    }
    /* check if idx is Range */
    switch (rb_range_beg_len(arg, &amp;beg, &amp;len, RARRAY(ary)-&gt;len, 0)) {
      case Qfalse:
        break;
      case Qnil:
        return Qnil;
      default:
        return rb_ary_subseq(ary, beg, len);
    }
    return rb_ary_entry(ary, NUM2LONG(arg));
}
            </pre> 
            </div><!-- slice-source -->
            
          </div>

          

          
        </div><!-- slice-method -->
      
        <div id="slice-21-method" class="method-detail ">
          <a name="method-i-slice-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">slice!(index)         &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice!(start, length) &rarr; sub_array or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice!(range)         &rarr; sub_array or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deletes the element(s) given by an index (optionally with a length) or by a
range. Returns the deleted object, subarray, or <code>nil</code> if the
index is out of range. Equivalent to:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">slice!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">result</span> = <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>]
  <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>] = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">result</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">1</span>)     <span class="ruby-comment">#=&gt; &quot;b&quot;</span>
<span class="ruby-identifier">a</span>               <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">-1</span>)    <span class="ruby-comment">#=&gt; &quot;c&quot;</span>
<span class="ruby-identifier">a</span>               <span class="ruby-comment">#=&gt; [&quot;a&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">100</span>)   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>               <span class="ruby-comment">#=&gt; [&quot;a&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="slice-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_slice_bang(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE arg1, arg2;
    long pos, len, orig_len;

    rb_ary_modify_check(ary);
    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;arg1, &amp;arg2) == 2) {
        pos = NUM2LONG(arg1);
        len = NUM2LONG(arg2);
      delete_pos_len:
        if (len &lt; 0) return Qnil;
        orig_len = RARRAY_LEN(ary);
        if (pos &lt; 0) {
            pos += orig_len;
            if (pos &lt; 0) return Qnil;
        }
        else if (orig_len &lt; pos) return Qnil;
        if (orig_len &lt; pos + len) {
            len = orig_len - pos;
        }
        if (len == 0) return rb_ary_new2(0);
        arg2 = rb_ary_new4(len, RARRAY_PTR(ary)+pos);
        RBASIC(arg2)-&gt;klass = rb_obj_class(ary);
        rb_ary_splice(ary, pos, len, Qnil);    /* Qundef in 1.9 */
        return arg2;
    }

    if (!FIXNUM_P(arg1)) {
        switch (rb_range_beg_len(arg1, &amp;pos, &amp;len, RARRAY_LEN(ary), 0)) {
          case Qtrue:
            /* valid range */
            goto delete_pos_len;
          case Qnil:
            /* invalid range */
            return Qnil;
          default:
            /* not a range */
            break;
        }
    }

    return rb_ary_delete_at(ary, NUM2LONG(arg1));
}
            </pre> 
            </div><!-- slice-21-source -->
            
          </div>

          

          
        </div><!-- slice-21-method -->
      
        <div id="sort-method" class="method-detail ">
          <a name="method-i-sort"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sort                   &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sort {| a,b | block }  &rarr; an_array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array created by sorting <em>self</em>. Comparisons for the
sort will be done using the <code>&lt;=&gt;</code> operator or using an
optional code block. The block implements a comparison between <em>a</em>
and <em>b</em>, returning -1, 0, or +1. See also
<code>Enumerable#sort_by</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;e&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;b&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span>                    <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">y</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">x</span> }   <span class="ruby-comment">#=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="sort-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_sort(ary)
    VALUE ary;
{
    ary = rb_ary_dup(ary);
    rb_ary_sort_bang(ary);
    return ary;
}
            </pre> 
            </div><!-- sort-source -->
            
          </div>

          

          
        </div><!-- sort-method -->
      
        <div id="sort-21-method" class="method-detail ">
          <a name="method-i-sort-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sort!                   &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sort! {| a,b | block }  &rarr; array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sorts <em>self</em>. Comparisons for the sort will be done using the
<code>&lt;=&gt;</code> operator or using an optional code block. The block
implements a comparison between <em>a</em> and <em>b</em>, returning -1, 0,
or +1. See also <code>Enumerable#sort_by</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;e&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;b&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span>                    <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">y</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">x</span> }   <span class="ruby-comment">#=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="sort-21-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_sort_bang(ary)
    VALUE ary;
{
    rb_ary_modify(ary);
    if (RARRAY(ary)-&gt;len &gt; 1) {
        FL_SET(ary, ARY_TMPLOCK);      /* prohibit modification during sort */
        rb_ensure(sort_internal, ary, sort_unlock, ary);
    }
    return ary;
}
            </pre> 
            </div><!-- sort-21-source -->
            
          </div>

          

          
        </div><!-- sort-21-method -->
      
        <div id="take-method" class="method-detail ">
          <a name="method-i-take"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">take(n)               => array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns first n elements from <em>ary</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">3</span>)             <span class="ruby-comment"># =&gt; [1, 2, 3]</span>
</pre>
            

            
            <div class="method-source-code" id="take-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_take(obj, n)
    VALUE obj;
    VALUE n;
{
    long len = NUM2LONG(n);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }

    return rb_ary_subseq(obj, 0, len);
}
            </pre> 
            </div><!-- take-source -->
            
          </div>

          

          
        </div><!-- take-method -->
      
        <div id="take_while-method" class="method-detail ">
          <a name="method-i-take_while"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">take_while {|arr| block }   => array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes elements to the block until the block returns nil or false, then
stops iterating and returns an array of all prior elements.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> }   <span class="ruby-comment"># =&gt; [1, 2]</span>
</pre>
            

            
            <div class="method-source-code" id="take_while-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_take_while(ary)
    VALUE ary;
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
        if (!RTEST(rb_yield(RARRAY(ary)-&gt;ptr[i]))) break;
    }
    return rb_ary_take(ary, LONG2FIX(i));
}
            </pre> 
            </div><!-- take_while-source -->
            
          </div>

          

          
        </div><!-- take_while-method -->
      
        <div id="to_a-method" class="method-detail ">
          <a name="method-i-to_a"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_a     &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <em>self</em>. If called on a subclass of <a
href="Array.html">Array</a>, converts the receiver to an <a
href="Array.html">Array</a> object.</p>
            

            
            <div class="method-source-code" id="to_a-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_to_a(ary)
    VALUE ary;
{
    if (rb_obj_class(ary) != rb_cArray) {
        VALUE dup = rb_ary_new2(RARRAY(ary)-&gt;len);
        rb_ary_replace(dup, ary);
        return dup;
    }
    return ary;
}
            </pre> 
            </div><!-- to_a-source -->
            
          </div>

          

          
        </div><!-- to_a-method -->
      
        <div id="to_ary-method" class="method-detail ">
          <a name="method-i-to_ary"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_ary &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <em>self</em>.</p>
            

            
            <div class="method-source-code" id="to_ary-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_to_ary_m(ary)
    VALUE ary;
{
    return ary;
}
            </pre> 
            </div><!-- to_ary-source -->
            
          </div>

          

          
        </div><!-- to_ary-method -->
      
        <div id="to_s-method" class="method-detail ">
          <a name="method-i-to_s"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_s &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <em>self</em><code>.join</code>.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;e&quot;</span>, <span class="ruby-string">&quot;i&quot;</span>, <span class="ruby-string">&quot;o&quot;</span> ].<span class="ruby-identifier">to_s</span>   <span class="ruby-comment">#=&gt; &quot;aeio&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="to_s-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_to_s(ary)
    VALUE ary;
{
    if (RARRAY(ary)-&gt;len == 0) return rb_str_new(0, 0);
    
    return rb_ary_join(ary, rb_output_fs);
}
            </pre> 
            </div><!-- to_s-source -->
            
          </div>

          

          
        </div><!-- to_s-method -->
      
        <div id="transpose-method" class="method-detail ">
          <a name="method-i-transpose"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">transpose &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Assumes that <em>self</em> is an array of arrays and transposes the rows
and columns.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>], [<span class="ruby-value">3</span>,<span class="ruby-value">4</span>], [<span class="ruby-value">5</span>,<span class="ruby-value">6</span>]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">transpose</span>   <span class="ruby-comment">#=&gt; [[1, 3, 5], [2, 4, 6]]</span>
</pre>
            

            
            <div class="method-source-code" id="transpose-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_transpose(ary)
    VALUE ary;
{
    long elen = -1, alen, i, j;
    VALUE tmp, result = 0;

    alen = RARRAY(ary)-&gt;len;
    if (alen == 0) return rb_ary_dup(ary);
    for (i=0; i&lt;alen; i++) {
        tmp = to_ary(rb_ary_elt(ary, i));
        if (elen &lt; 0) {                /* first element */
            elen = RARRAY(tmp)-&gt;len;
            result = rb_ary_new2(elen);
            for (j=0; j&lt;elen; j++) {
                rb_ary_store(result, j, rb_ary_new2(alen));
            }
        }
        else if (elen != RARRAY(tmp)-&gt;len) {
            rb_raise(rb_eIndexError, &quot;element size differs (%d should be %d)&quot;,
                     RARRAY(tmp)-&gt;len, elen);
        }
        for (j=0; j&lt;elen; j++) {
            rb_ary_store(rb_ary_elt(result, j), i, rb_ary_elt(tmp, j));
        }
    }
    return result;
}
            </pre> 
            </div><!-- transpose-source -->
            
          </div>

          

          
        </div><!-- transpose-method -->
      
        <div id="uniq-method" class="method-detail ">
          <a name="method-i-uniq"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">uniq   &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array by removing duplicate values in <em>self</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq</span>   <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="uniq-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_uniq(ary)
    VALUE ary;
{
    ary = rb_ary_dup(ary);
    rb_ary_uniq_bang(ary);
    return ary;
}
            </pre> 
            </div><!-- uniq-source -->
            
          </div>

          

          
        </div><!-- uniq-method -->
      
        <div id="uniq-21-method" class="method-detail ">
          <a name="method-i-uniq-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">uniq! &rarr; array or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes duplicate elements from <em>self</em>. Returns <code>nil</code> if
no changes are made (that is, no duplicates are found).</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq!</span>   <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">b</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">b</span>.<span class="ruby-identifier">uniq!</span>   <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="uniq-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_uniq_bang(ary)
    VALUE ary;
{
    VALUE hash, v, vv;
    long i, j;

    hash = ary_make_hash(ary, 0);

    if (RARRAY(ary)-&gt;len == RHASH(hash)-&gt;tbl-&gt;num_entries) {
        return Qnil;
    }
    for (i=j=0; i&lt;RARRAY(ary)-&gt;len; i++) {
        v = vv = rb_ary_elt(ary, i);
        if (st_delete(RHASH(hash)-&gt;tbl, (st_data_t*)&amp;vv, 0)) {
            rb_ary_store(ary, j++, v);
        }
    }
    RARRAY(ary)-&gt;len = j;

    return ary;
}
            </pre> 
            </div><!-- uniq-21-source -->
            
          </div>

          

          
        </div><!-- uniq-21-method -->
      
        <div id="unshift-method" class="method-detail ">
          <a name="method-i-unshift"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">unshift(obj, ...)  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Prepends objects to the front of <em>array</em>. other elements up one.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-string">&quot;a&quot;</span>)   <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>)  <span class="ruby-comment">#=&gt; [ 1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="unshift-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_unshift_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long len = RARRAY(ary)-&gt;len;

    if (argc == 0) return ary;

    /* make rooms by setting the last item */
    rb_ary_store(ary, len + argc - 1, Qnil);

    /* sliding items */
    MEMMOVE(RARRAY(ary)-&gt;ptr + argc, RARRAY(ary)-&gt;ptr, VALUE, len);
    MEMCPY(RARRAY(ary)-&gt;ptr, argv, VALUE, argc);
    
    return ary;
}
            </pre> 
            </div><!-- unshift-source -->
            
          </div>

          

          
        </div><!-- unshift-method -->
      
        <div id="values_at-method" class="method-detail ">
          <a name="method-i-values_at"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">values_at(selector,... )  &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array containing the elements in <em>self</em> corresponding to
the given selector(s). The selectors may be either integer indices or
ranges.  See also <code>Array#select</code>.</p>

<pre>a = %w{ a b c d e f }
a.values_at(1, 3, 5)
a.values_at(1, 3, 5, 7)
a.values_at(-1, -3, -5, -7)
a.values_at(1..3, 2...5)</pre>
            

            
            <div class="method-source-code" id="values_at-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_values_at(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    return rb_values_at(ary, RARRAY(ary)-&gt;len, argc, argv, rb_ary_entry);
}
            </pre> 
            </div><!-- values_at-source -->
            
          </div>

          

          
        </div><!-- values_at-method -->
      
        <div id="zip-method" class="method-detail ">
          <a name="method-i-zip"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">zip(arg, ...)                   &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">zip(arg, ...) {| arr | block }  &rarr; nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Converts any arguments to arrays, then merges elements of <em>self</em>
with corresponding elements from each argument. This generates a sequence
of <code>self.size</code> <em>n</em>-element arrays, where <em>n</em> is
one more that the count of arguments. If the size of any argument is less
than <code>enumObj.size</code>, <code>nil</code> values are supplied. If a
block given, it is invoked for each output array, otherwise an array of
arrays is returned.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span> ]
<span class="ruby-identifier">b</span> = [ <span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span> ]

[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>].<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>)      <span class="ruby-comment">#=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]</span>
[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>].<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>)         <span class="ruby-comment">#=&gt; [[1, 4, 7], [2, 5, 8]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>([<span class="ruby-value">1</span>,<span class="ruby-value">2</span>],[<span class="ruby-value">8</span>])       <span class="ruby-comment">#=&gt; [[4,1,8], [5,2,nil], [6,nil,nil]]</span>
</pre>
            

            
            <div class="method-source-code" id="zip-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_zip(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    int i, j;
    long len;
    VALUE result;

    for (i=0; i&lt;argc; i++) {
        argv[i] = to_ary(argv[i]);
    }
    if (rb_block_given_p()) {
        for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
            VALUE tmp = rb_ary_new2(argc+1);

            rb_ary_push(tmp, rb_ary_elt(ary, i));
            for (j=0; j&lt;argc; j++) {
                rb_ary_push(tmp, rb_ary_elt(argv[j], i));
            }
            rb_yield(tmp);
        }
        return Qnil;
    }
    len = RARRAY(ary)-&gt;len;
    result = rb_ary_new2(len);
    for (i=0; i&lt;len; i++) {
        VALUE tmp = rb_ary_new2(argc+1);

        rb_ary_push(tmp, rb_ary_elt(ary, i));
        for (j=0; j&lt;argc; j++) {
            rb_ary_push(tmp, rb_ary_elt(argv[j], i));
        }
        rb_ary_push(result, tmp);
    }
    return result;
}
            </pre> 
            </div><!-- zip-source -->
            
          </div>

          

          
        </div><!-- zip-method -->
      
        <div id="7C-method" class="method-detail ">
          <a name="method-i-7C"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">array | other_array     &rarr;  an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Set Union—Returns a new array by joining this array with other_array,
removing duplicates.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ] <span class="ruby-operator">|</span> [ <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;a&quot;</span> ]
       <span class="ruby-comment">#=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</span>
</pre>
            

            
            <div class="method-source-code" id="7C-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_or(ary1, ary2)
    VALUE ary1, ary2;
{
    VALUE hash, ary3;
    VALUE v, vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new2(RARRAY(ary1)-&gt;len+RARRAY(ary2)-&gt;len);
    hash = ary_make_hash(ary1, ary2);

    for (i=0; i&lt;RARRAY(ary1)-&gt;len; i++) {
        v = vv = rb_ary_elt(ary1, i);
        if (st_delete(RHASH(hash)-&gt;tbl, (st_data_t*)&amp;vv, 0)) {
            rb_ary_push(ary3, v);
        }
    }
    for (i=0; i&lt;RARRAY(ary2)-&gt;len; i++) {
        v = vv = rb_ary_elt(ary2, i);
        if (st_delete(RHASH(hash)-&gt;tbl, (st_data_t*)&amp;vv, 0)) {
            rb_ary_push(ary3, v);
        }
    }
    return ary3;
}
            </pre> 
            </div><!-- 7C-source -->
            
          </div>

          

          
        </div><!-- 7C-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_Array_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Array_versioned").load("/associated/1.8.7/Array.html");</script> <div id='tx_Array' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Array").load("/associated/Array.html");</script> 
      
  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
      
<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 1.8.7</small></p> 
  
   <p> <a href="http://www.ruby-doc.org">Ruby-doc.org</a> is hosted by <a href="http://www.jamesbritt.com">James Britt</a> and <a href="http://www.neurogami.com">Neurogami</a>, an <a href="http://www.neurogami.com"> avant garage research + development in Scottsdale, AZ</a>.  </p>
 
    <p><small>Generated with Ruby-doc Rdoc Generator 0.24.6</small>.</p>
  </div>
</div>
  
 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.html");
    });

    </script>


 
    <script type='text/javascript'>

  function loadPlus(plusdocs){
    var img_h = $("img.carbonad-image").css('height');
    //if(img_h != undefined) { //---
      $(plusdocs).find("div[class='associated_wrapper']").each (function() {
          $("#" + this.id).append($(plusdocs).find("#" + this.id ));
          });
    //} // ---
  } // end loadPlusdocs


$(document).ready(function() {
    $.ajaxSetup({ cache: false });
      $.get('/associated/1.8.7/plus_Array.html', 
      function(plusdocs) {
      setTimeout(function() {
        loadPlus(plusdocs);
        }, 2000);
      }
      );
    });
</script>
		
</body>
</html>


