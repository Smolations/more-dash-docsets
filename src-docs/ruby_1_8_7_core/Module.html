<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.24.6  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <meta content="2013-08-24 23:20:02 -0700" http-equiv="change-date" />
  <!-- rel_prefix  = ''  ENV['RDOC_FOR_WEBSITE']   = false-->
    
    <!-- WHY? -->
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = ''  --> 
  <title>Class: Module (Ruby 1.8.7) </title>
  <!-- link rel="stylesheet" href=".css/obf.css"  -->
  <link rel="stylesheet" href="css/inuit.css" >
  <link rel="stylesheet" href="css/grid.inuit.css" >
  <link rel="stylesheet" href="css/2011.css" type="text/css" >
  <link rel="stylesheet" href="css/rdoc.css" type="text/css" >

  <script src="/js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="/js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

</head>

<body id="top" class="class rdocstar">
<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'></ul>
</div>
<span id='vulns-alert'></span>
</div> <!-- end action bar -->
 <div class='wrapper'>
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>eval.c</li>      
            
          
          <li class='in-file'>object.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-constants">::constants</a></li>
          
          <li><a href="#method-c-nesting">::nesting</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-i-3C">#<</a></li>
          
          <li><a href="#method-i-3C-3D">#<=</a></li>
          
          <li><a href="#method-i-3C-3D-3E">#<=></a></li>
          
          <li><a href="#method-i-3D-3D">#==</a></li>
          
          <li><a href="#method-i-3D-3D-3D">#===</a></li>
          
          <li><a href="#method-i-3E">#></a></li>
          
          <li><a href="#method-i-3E-3D">#>=</a></li>
          
          <li><a href="#method-i-alias_method">#alias_method</a></li>
          
          <li><a href="#method-i-ancestors">#ancestors</a></li>
          
          <li><a href="#method-i-append_features">#append_features</a></li>
          
          <li><a href="#method-i-attr">#attr</a></li>
          
          <li><a href="#method-i-attr_accessor">#attr_accessor</a></li>
          
          <li><a href="#method-i-attr_reader">#attr_reader</a></li>
          
          <li><a href="#method-i-attr_writer">#attr_writer</a></li>
          
          <li><a href="#method-i-autoload">#autoload</a></li>
          
          <li><a href="#method-i-autoload-3F">#autoload?</a></li>
          
          <li><a href="#method-i-class_eval">#class_eval</a></li>
          
          <li><a href="#method-i-class_exec">#class_exec</a></li>
          
          <li><a href="#method-i-class_variable_defined-3F">#class_variable_defined?</a></li>
          
          <li><a href="#method-i-class_variable_get">#class_variable_get</a></li>
          
          <li><a href="#method-i-class_variable_set">#class_variable_set</a></li>
          
          <li><a href="#method-i-class_variables">#class_variables</a></li>
          
          <li><a href="#method-i-const_defined-3F">#const_defined?</a></li>
          
          <li><a href="#method-i-const_get">#const_get</a></li>
          
          <li><a href="#method-i-const_missing">#const_missing</a></li>
          
          <li><a href="#method-i-const_set">#const_set</a></li>
          
          <li><a href="#method-i-constants">#constants</a></li>
          
          <li><a href="#method-i-define_method">#define_method</a></li>
          
          <li><a href="#method-i-extend_object">#extend_object</a></li>
          
          <li><a href="#method-i-extended">#extended</a></li>
          
          <li><a href="#method-i-freeze">#freeze</a></li>
          
          <li><a href="#method-i-include">#include</a></li>
          
          <li><a href="#method-i-include-3F">#include?</a></li>
          
          <li><a href="#method-i-included">#included</a></li>
          
          <li><a href="#method-i-included_modules">#included_modules</a></li>
          
          <li><a href="#method-i-instance_method">#instance_method</a></li>
          
          <li><a href="#method-i-instance_methods">#instance_methods</a></li>
          
          <li><a href="#method-i-method_added">#method_added</a></li>
          
          <li><a href="#method-i-method_defined-3F">#method_defined?</a></li>
          
          <li><a href="#method-i-method_removed">#method_removed</a></li>
          
          <li><a href="#method-i-method_undefined">#method_undefined</a></li>
          
          <li><a href="#method-i-module_eval">#module_eval</a></li>
          
          <li><a href="#method-i-module_exec">#module_exec</a></li>
          
          <li><a href="#method-i-module_function">#module_function</a></li>
          
          <li><a href="#method-i-name">#name</a></li>
          
          <li><a href="#method-i-private">#private</a></li>
          
          <li><a href="#method-i-private_class_method">#private_class_method</a></li>
          
          <li><a href="#method-i-private_instance_methods">#private_instance_methods</a></li>
          
          <li><a href="#method-i-private_method_defined-3F">#private_method_defined?</a></li>
          
          <li><a href="#method-i-protected">#protected</a></li>
          
          <li><a href="#method-i-protected_instance_methods">#protected_instance_methods</a></li>
          
          <li><a href="#method-i-protected_method_defined-3F">#protected_method_defined?</a></li>
          
          <li><a href="#method-i-public">#public</a></li>
          
          <li><a href="#method-i-public_class_method">#public_class_method</a></li>
          
          <li><a href="#method-i-public_instance_methods">#public_instance_methods</a></li>
          
          <li><a href="#method-i-public_method_defined-3F">#public_method_defined?</a></li>
          
          <li><a href="#method-i-remove_class_variable">#remove_class_variable</a></li>
          
          <li><a href="#method-i-remove_const">#remove_const</a></li>
          
          <li><a href="#method-i-remove_method">#remove_method</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-undef_method">#undef_method</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="./ArgumentError.html">ArgumentError</a></li>
        
          
          
          <li><a href="./Array.html">Array</a></li>
        
          
          
          <li><a href="./Bignum.html">Bignum</a></li>
        
          
          
          <li><a href="./Binding.html">Binding</a></li>
        
          
          
          <li><a href="./Class.html">Class</a></li>
        
          
          
          <li><a href="./Comparable.html">Comparable</a></li>
        
          
          
          <li><a href="./Continuation.html">Continuation</a></li>
        
          
          
          <li><a href="./Data.html">Data</a></li>
        
          
          
          <li><a href="./Dir.html">Dir</a></li>
        
          
          
          <li><a href="./EOFError.html">EOFError</a></li>
        
          
          
          <li><a href="./Enumerable.html">Enumerable</a></li>
        
          
          
          <li><a href="./Enumerable/Enumerator.html">Enumerable::Enumerator</a></li>
        
          
          
          <li><a href="./Errno.html">Errno</a></li>
        
          
          
          <li><a href="./Exception.html">Exception</a></li>
        
          
          
          <li><a href="./FalseClass.html">FalseClass</a></li>
        
          
          
          <li><a href="./File.html">File</a></li>
        
          
          
          <li><a href="./File/Constants.html">File::Constants</a></li>
        
          
          
          <li><a href="./File/Stat.html">File::Stat</a></li>
        
          
          
          <li><a href="./FileTest.html">FileTest</a></li>
        
          
          
          <li><a href="./Fixnum.html">Fixnum</a></li>
        
          
          
          <li><a href="./Float.html">Float</a></li>
        
          
          
          <li><a href="./FloatDomainError.html">FloatDomainError</a></li>
        
          
          
          <li><a href="./GC.html">GC</a></li>
        
          
          
          <li><a href="./Hash.html">Hash</a></li>
        
          
          
          <li><a href="./IO.html">IO</a></li>
        
          
          
          <li><a href="./IOError.html">IOError</a></li>
        
          
          
          <li><a href="./IndexError.html">IndexError</a></li>
        
          
          
          <li><a href="./Integer.html">Integer</a></li>
        
          
          
          <li><a href="./Interrupt.html">Interrupt</a></li>
        
          
          
          <li><a href="./Kernel.html">Kernel</a></li>
        
          
          
          <li><a href="./LoadError.html">LoadError</a></li>
        
          
          
          <li><a href="./LocalJumpError.html">LocalJumpError</a></li>
        
          
          
          <li><a href="./Marshal.html">Marshal</a></li>
        
          
          
          <li><a href="./MatchData.html">MatchData</a></li>
        
          
          
          <li><a href="./Math.html">Math</a></li>
        
          
          
          <li><a href="./Method.html">Method</a></li>
        
          
          
          <li><a href="./Module.html">Module</a></li>
        
          
          
          <li><a href="./NameError.html">NameError</a></li>
        
          
          
          <li><a href="./NameError/message.html">NameError::message</a></li>
        
          
          
          <li><a href="./NilClass.html">NilClass</a></li>
        
          
          
          <li><a href="./NoMemoryError.html">NoMemoryError</a></li>
        
          
          
          <li><a href="./NoMethodError.html">NoMethodError</a></li>
        
          
          
          <li><a href="./NotImplementedError.html">NotImplementedError</a></li>
        
          
          
          <li><a href="./Numeric.html">Numeric</a></li>
        
          
          
          <li><a href="./Object.html">Object</a></li>
        
          
          
          <li><a href="./ObjectSpace.html">ObjectSpace</a></li>
        
          
          
          <li><a href="./Precision.html">Precision</a></li>
        
          
          
          <li><a href="./Proc.html">Proc</a></li>
        
          
          
          <li><a href="./Process.html">Process</a></li>
        
          
          
          <li><a href="./Process/GID.html">Process::GID</a></li>
        
          
          
          <li><a href="./Process/Status.html">Process::Status</a></li>
        
          
          
          <li><a href="./Process/Sys.html">Process::Sys</a></li>
        
          
          
          <li><a href="./Process/UID.html">Process::UID</a></li>
        
          
          
          <li><a href="./Range.html">Range</a></li>
        
          
          
          <li><a href="./RangeError.html">RangeError</a></li>
        
          
          
          <li><a href="./Regexp.html">Regexp</a></li>
        
          
          
          <li><a href="./RegexpError.html">RegexpError</a></li>
        
          
          
          <li><a href="./RuntimeError.html">RuntimeError</a></li>
        
          
          
          <li><a href="./ScriptError.html">ScriptError</a></li>
        
          
          
          <li><a href="./SecurityError.html">SecurityError</a></li>
        
          
          
          <li><a href="./Signal.html">Signal</a></li>
        
          
          
          <li><a href="./SignalException.html">SignalException</a></li>
        
          
          
          <li><a href="./StandardError.html">StandardError</a></li>
        
          
          
          <li><a href="./StopIteration.html">StopIteration</a></li>
        
          
          
          <li><a href="./String.html">String</a></li>
        
          
          
          <li><a href="./Struct.html">Struct</a></li>
        
          
          
          <li><a href="./Symbol.html">Symbol</a></li>
        
          
          
          <li><a href="./SyntaxError.html">SyntaxError</a></li>
        
          
          
          <li><a href="./SystemCallError.html">SystemCallError</a></li>
        
          
          
          <li><a href="./SystemExit.html">SystemExit</a></li>
        
          
          
          <li><a href="./SystemStackError.html">SystemStackError</a></li>
        
          
          
          <li><a href="./Thread.html">Thread</a></li>
        
          
          
          <li><a href="./ThreadError.html">ThreadError</a></li>
        
          
          
          <li><a href="./ThreadGroup.html">ThreadGroup</a></li>
        
          
          
          <li><a href="./Time.html">Time</a></li>
        
          
          
          <li><a href="./TrueClass.html">TrueClass</a></li>
        
          
          
          <li><a href="./TypeError.html">TypeError</a></li>
        
          
          
          <li><a href="./UnboundMethod.html">UnboundMethod</a></li>
        
          
          
          <li><a href="./ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          
          
          <li><a href="./fatal.html">fatal</a></li>
        
          
          
          <li><a href="./unknown.html">unknown</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
    
  </div> 
  <div id="documentation">
    <h1 class="class">Module</h1>

    <div id="description" class="description">
      
<p>A <code>Module</code> is a collection of methods and constants. The methods
in a module may be instance methods or module methods. Instance methods
appear as methods in a class when the module is included, module methods do
not. Conversely, module methods may be called without creating an
encapsulating object, while instance methods may not. (See
<code>Module#module_function</code>)</p>

<p>In the descriptions that follow, the parameter <em>syml</em> refers to a
symbol, which is either a quoted string or a <code>Symbol</code> (such as
<code>:name</code>).</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Mod</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Math</span>
  <span class="ruby-constant">CONST</span> = <span class="ruby-value">1</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">meth</span>
    <span class="ruby-comment">#  ...</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Mod</span>.<span class="ruby-identifier">class</span>              <span class="ruby-comment">#=&gt; Module</span>
<span class="ruby-constant">Mod</span>.<span class="ruby-identifier">constants</span>          <span class="ruby-comment">#=&gt; [&quot;E&quot;, &quot;PI&quot;, &quot;CONST&quot;]</span>
<span class="ruby-constant">Mod</span>.<span class="ruby-identifier">instance_methods</span>   <span class="ruby-comment">#=&gt; [&quot;meth&quot;]</span>
</pre>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="constants-method" class="method-detail ">
          <a name="method-c-constants"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">constants   => array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of the names of all constants defined in the system. This
list includes the names of all modules and classes.</p>

<pre>p Module.constants.sort[1..5]</pre>

<p><em>produces:</em></p>

<pre>[&quot;ARGV&quot;, &quot;ArgumentError&quot;, &quot;Array&quot;, &quot;Bignum&quot;, &quot;Binding&quot;]</pre>
            

            
            <div class="method-source-code" id="constants-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_s_constants()
{
    NODE *cbase = ruby_cref;
    void *data = 0;

    while (cbase) {
        if (!NIL_P(cbase-&gt;nd_clss)) {
            data = rb_mod_const_at(cbase-&gt;nd_clss, data);
        }
        cbase = cbase-&gt;nd_next;
    }

    if (!NIL_P(ruby_cbase)) {
        data = rb_mod_const_of(ruby_cbase, data);
    }
    return rb_const_list(data);
}
            </pre> 
            </div><!-- constants-source -->
            
          </div>

          

          
        </div><!-- constants-method -->
      
        <div id="nesting-method" class="method-detail ">
          <a name="method-c-nesting"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">nesting    => array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the list of <code>Modules</code> nested at the point of call.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">M1</span>
  <span class="ruby-keyword">module</span> <span class="ruby-constant">M2</span>
    <span class="ruby-identifier">$a</span> = <span class="ruby-constant">Module</span>.<span class="ruby-identifier">nesting</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">$a</span>           <span class="ruby-comment">#=&gt; [M1::M2, M1]</span>
<span class="ruby-identifier">$a</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">name</span>   <span class="ruby-comment">#=&gt; &quot;M1::M2&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="nesting-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_nesting()
{
    NODE *cbase = ruby_cref;
    VALUE ary = rb_ary_new();

    while (cbase &amp;&amp; cbase-&gt;nd_next) {
        if (!NIL_P(cbase-&gt;nd_clss)) rb_ary_push(ary, cbase-&gt;nd_clss);
        cbase = cbase-&gt;nd_next;
    }
    if (ruby_wrapper &amp;&amp; RARRAY(ary)-&gt;len == 0) {
        rb_ary_push(ary, ruby_wrapper);
    }
    return ary;
}
            </pre> 
            </div><!-- nesting-source -->
            
          </div>

          

          
        </div><!-- nesting-method -->
      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new                  => mod</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new {|mod| block }   => mod</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a new anonymous module. If a block is given, it is passed the
module object, and the block is evaluated in the context of this module
using <code>module_eval</code>.</p>

<pre class="ruby"><span class="ruby-constant">Fred</span> = <span class="ruby-constant">Module</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">meth1</span>
    <span class="ruby-string">&quot;hello&quot;</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">meth2</span>
    <span class="ruby-string">&quot;bye&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">a</span> = <span class="ruby-string">&quot;my string&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">Fred</span>)   <span class="ruby-comment">#=&gt; &quot;my string&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">meth1</span>          <span class="ruby-comment">#=&gt; &quot;hello&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">meth2</span>          <span class="ruby-comment">#=&gt; &quot;bye&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="new-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_initialize(module)
    VALUE module;
{
    if (rb_block_given_p()) {
        rb_mod_module_eval(0, 0, module);
    }
    return Qnil;
}
            </pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="3C-method" class="method-detail ">
          <a name="method-i-3C"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">mod < other   =>  true, false, or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if <em>mod</em> is a subclass of <em>other</em>. Returns 
<code>nil</code> if there’s no relationship between the two.  (Think of the
relationship in terms of the class definition:  “class A&lt;B” implies
“A&lt;B”).</p>
            

            
            <div class="method-source-code" id="3C-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_lt(mod, arg)
    VALUE mod, arg;
{
    if (mod == arg) return Qfalse;
    return rb_class_inherited_p(mod, arg);
}
            </pre> 
            </div><!-- 3C-source -->
            
          </div>

          

          
        </div><!-- 3C-method -->
      
        <div id="3C-3D-method" class="method-detail ">
          <a name="method-i-3C-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">mod <= other   =>  true, false, or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if <em>mod</em> is a subclass of <em>other</em> or is the same
as <em>other</em>. Returns  <code>nil</code> if there’s no relationship
between the two.  (Think of the relationship in terms of the class
definition:  “class A&lt;B” implies “A&lt;B”).</p>
            

            
            <div class="method-source-code" id="3C-3D-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_class_inherited_p(mod, arg)
    VALUE mod, arg;
{
    VALUE start = mod;

    if (mod == arg) return Qtrue;
    switch (TYPE(arg)) {
      case T_MODULE:
      case T_CLASS:
        break;
      default:
        rb_raise(rb_eTypeError, &quot;compared with non class/module&quot;);
    }

    if (FL_TEST(mod, FL_SINGLETON)) {
        if (RCLASS(mod)-&gt;m_tbl == RCLASS(arg)-&gt;m_tbl)
            return Qtrue;
        mod = RBASIC(mod)-&gt;klass;
    }
    while (mod) {
        if (RCLASS(mod)-&gt;m_tbl == RCLASS(arg)-&gt;m_tbl)
            return Qtrue;
        mod = RCLASS(mod)-&gt;super;
    }
    /* not mod &lt; arg; check if mod &gt; arg */
    while (arg) {
        if (RCLASS(arg)-&gt;m_tbl == RCLASS(start)-&gt;m_tbl)
            return Qfalse;
        arg = RCLASS(arg)-&gt;super;
    }
    return Qnil;
}
            </pre> 
            </div><!-- 3C-3D-source -->
            
          </div>

          

          
        </div><!-- 3C-3D-method -->
      
        <div id="3C-3D-3E-method" class="method-detail ">
          <a name="method-i-3C-3D-3E"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">mod <=> other_mod   => -1, 0, +1, or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Comparison—Returns -1 if <em>mod</em> includes <em>other_mod</em>, 0 if
<em>mod</em> is the same as <em>other_mod</em>, and +1 if <em>mod</em> is
included by <em>other_mod</em> or if <em>mod</em> has no relationship with
<em>other_mod</em>. Returns <code>nil</code> if <em>other_mod</em> is not a
module.</p>
            

            
            <div class="method-source-code" id="3C-3D-3E-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_cmp(mod, arg)
    VALUE mod, arg;
{
    VALUE cmp;

    if (mod == arg) return INT2FIX(0);
    switch (TYPE(arg)) {
      case T_MODULE:
      case T_CLASS:
        break;
      default:
        return Qnil;
    }

    cmp = rb_class_inherited_p(mod, arg);
    if (NIL_P(cmp)) return Qnil;
    if (cmp) {
        return INT2FIX(-1);
    }
    return INT2FIX(1);
}
            </pre> 
            </div><!-- 3C-3D-3E-source -->
            
          </div>

          

          
        </div><!-- 3C-3D-3E-method -->
      
        <div id="3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">obj == other        => true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">equal?(other)   => true or false</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">eql?(other)     => true or false</span>
            
          </div>
          
          
          <div>
  
            
            <p>Equality—At the <code>Object</code> level, <code>==</code> returns
<code>true</code> only if <em>obj</em> and <em>other</em> are the same
object. Typically, this method is overridden in descendent classes to
provide class-specific meaning.</p>

<p>Unlike <code>==</code>, the <code>equal?</code> method should never be
overridden by subclasses: it is used to determine object identity (that is,
<code>a.equal?(b)</code> iff <code>a</code> is the same object as
<code>b</code>).</p>

<p>The <code>eql?</code> method returns <code>true</code> if <em>obj</em> and
<em>anObject</em> have the same value. Used by <code>Hash</code> to test
members for equality. For objects of class <code>Object</code>,
<code>eql?</code> is synonymous with <code>==</code>. Subclasses normally
continue this tradition, but there are exceptions. <code>Numeric</code>
types, for example, perform type conversion across <code>==</code>, but not
across <code>eql?</code>, so:</p>

<pre class="ruby"><span class="ruby-value">1</span> <span class="ruby-operator">==</span> <span class="ruby-value">1.0</span>     <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-value">1</span>.<span class="ruby-identifier">eql?</span> <span class="ruby-value">1.0</span>   <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="3D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_obj_equal(obj1, obj2)
    VALUE obj1, obj2;
{
    if (obj1 == obj2) return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- 3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-method -->
      
        <div id="3D-3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">mod === obj    => true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Case Equality—Returns <code>true</code> if <em>anObject</em> is an instance
of <em>mod</em> or one of <em>mod</em>’s descendents. Of limited use for
modules, but can be used in <code>case</code> statements to classify
objects by class.</p>
            

            
            <div class="method-source-code" id="3D-3D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_eqq(mod, arg)
    VALUE mod, arg;
{
    return rb_obj_is_kind_of(arg, mod);
}
            </pre> 
            </div><!-- 3D-3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-3D-method -->
      
        <div id="3E-method" class="method-detail ">
          <a name="method-i-3E"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">mod > other   =>  true, false, or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if <em>mod</em> is an ancestor of <em>other</em>. Returns 
<code>nil</code> if there’s no relationship between the two.  (Think of the
relationship in terms of the class definition:  “class A&lt;B” implies
“B&gt;A”).</p>
            

            
            <div class="method-source-code" id="3E-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_gt(mod, arg)
    VALUE mod, arg;
{
    if (mod == arg) return Qfalse;
    return rb_mod_ge(mod, arg);
}
            </pre> 
            </div><!-- 3E-source -->
            
          </div>

          

          
        </div><!-- 3E-method -->
      
        <div id="3E-3D-method" class="method-detail ">
          <a name="method-i-3E-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">mod >= other   =>  true, false, or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if <em>mod</em> is an ancestor of <em>other</em>, or the two
modules are the same. Returns  <code>nil</code> if there’s no relationship
between the two.  (Think of the relationship in terms of the class
definition:  “class A&lt;B” implies “B&gt;A”).</p>
            

            
            <div class="method-source-code" id="3E-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_ge(mod, arg)
    VALUE mod, arg;
{
    switch (TYPE(arg)) {
      case T_MODULE:
      case T_CLASS:
        break;
      default:
        rb_raise(rb_eTypeError, &quot;compared with non class/module&quot;);
    }

    return rb_class_inherited_p(arg, mod);
}
            </pre> 
            </div><!-- 3E-3D-source -->
            
          </div>

          

          
        </div><!-- 3E-3D-method -->
      
        <div id="ancestors-method" class="method-detail ">
          <a name="method-i-ancestors"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ancestors &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a list of modules included in <em>mod</em> (including <em>mod</em>
itself).</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Mod</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Math</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Comparable</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">Mod</span>.<span class="ruby-identifier">ancestors</span>    <span class="ruby-comment">#=&gt; [Mod, Comparable, Math]</span>
<span class="ruby-constant">Math</span>.<span class="ruby-identifier">ancestors</span>   <span class="ruby-comment">#=&gt; [Math]</span>
</pre>
            

            
            <div class="method-source-code" id="ancestors-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_ancestors(mod)
    VALUE mod;
{
    VALUE p, ary = rb_ary_new();

    for (p = mod; p; p = RCLASS(p)-&gt;super) {
	if (FL_TEST(p, FL_SINGLETON))
	    continue;
	if (BUILTIN_TYPE(p) == T_ICLASS) {
	    rb_ary_push(ary, RBASIC(p)-&gt;klass);
	}
	else {
	    rb_ary_push(ary, p);
	}
    }
    return ary;
}
            </pre> 
            </div><!-- ancestors-source -->
            
          </div>

          

          
        </div><!-- ancestors-method -->
      
        <div id="autoload-method" class="method-detail ">
          <a name="method-i-autoload"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">autoload(name, filename)   => nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Registers <em>filename</em> to be loaded (using
<code>Kernel::require</code>)  the first time that <em>name</em> (which may
be a <code>String</code> or a symbol) is accessed in the namespace of
<em>mod</em>.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">A</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">A</span>.<span class="ruby-identifier">autoload</span>(:<span class="ruby-constant">B</span>, <span class="ruby-string">&quot;b&quot;</span>)
<span class="ruby-constant">A</span><span class="ruby-operator">::</span><span class="ruby-constant">B</span>.<span class="ruby-identifier">doit</span>            <span class="ruby-comment"># autoloads &quot;b&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="autoload-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_autoload(mod, sym, file)
    VALUE mod;
    VALUE sym;
    VALUE file;
{
    ID id = rb_to_id(sym);

    Check_SafeStr(file);
    rb_autoload(mod, id, RSTRING(file)-&gt;ptr);
    return Qnil;
}
            </pre> 
            </div><!-- autoload-source -->
            
          </div>

          

          
        </div><!-- autoload-method -->
      
        <div id="autoload-3F-method" class="method-detail ">
          <a name="method-i-autoload-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">autoload?(name)   => String or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <em>filename</em> to be loaded if <em>name</em> is registered as
<code>autoload</code> in the namespace of <em>mod</em>.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">A</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">A</span>.<span class="ruby-identifier">autoload</span>(:<span class="ruby-constant">B</span>, <span class="ruby-string">&quot;b&quot;</span>)
<span class="ruby-constant">A</span>.<span class="ruby-identifier">autoload?</span>(:<span class="ruby-constant">B</span>)            <span class="ruby-comment"># =&gt; &quot;b&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="autoload-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_autoload_p(mod, sym)
    VALUE mod, sym;
{
    return rb_autoload_p(mod, rb_to_id(sym));
}
            </pre> 
            </div><!-- autoload-3F-source -->
            
          </div>

          

          
        </div><!-- autoload-3F-method -->
      
        <div id="class_eval-method" class="method-detail ">
          <a name="method-i-class_eval"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">class_eval(string [, filename [, lineno]])  => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Evaluates the string or block in the context of <em>mod</em>. This can be
used to add methods to a class. <code>module_eval</code> returns the result
of evaluating its argument. The optional <em>filename</em> and
<em>lineno</em> parameters set the text for error messages.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Thing</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">a</span> = <span class="ruby-string">%q{def hello() &quot;Hello there!&quot; end}</span>
<span class="ruby-constant">Thing</span>.<span class="ruby-identifier">module_eval</span>(<span class="ruby-identifier">a</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-constant">Thing</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">hello</span>()
<span class="ruby-constant">Thing</span>.<span class="ruby-identifier">module_eval</span>(<span class="ruby-string">&quot;invalid code&quot;</span>, <span class="ruby-string">&quot;dummy&quot;</span>, <span class="ruby-value">123</span>)
</pre>

<p><em>produces:</em></p>

<pre>Hello there!
dummy:123:in `module_eval': undefined local variable
    or method `code' for Thing:Class</pre>
            

            
            <div class="method-source-code" id="class_eval-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_module_eval(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    return specific_eval(argc, argv, mod, mod);
}
            </pre> 
            </div><!-- class_eval-source -->
            
          </div>

          

          
        </div><!-- class_eval-method -->
      
        <div id="class_exec-method" class="method-detail ">
          <a name="method-i-class_exec"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">class_exec(arg...) {|var...| block }        => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Evaluates the given block in the context of the class/module. The method
defined in the block will belong to the receiver.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Thing</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Thing</span>.<span class="ruby-identifier">class_exec</span>{
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">hello</span>() <span class="ruby-string">&quot;Hello there!&quot;</span> <span class="ruby-keyword">end</span>
}
<span class="ruby-identifier">puts</span> <span class="ruby-constant">Thing</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">hello</span>()
</pre>

<p><em>produces:</em></p>

<pre>Hello there!</pre>
            

            
            <div class="method-source-code" id="class_exec-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_module_exec(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    return yield_under(mod, mod, rb_ary_new4(argc, argv));
}
            </pre> 
            </div><!-- class_exec-source -->
            
          </div>

          

          
        </div><!-- class_exec-method -->
      
        <div id="class_variable_defined-3F-method" class="method-detail ">
          <a name="method-i-class_variable_defined-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">class_variable_defined?(symbol)    => true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if the given class variable is defined in
<em>obj</em>.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Fred</span>
  <span class="ruby-identifier">@@foo</span> = <span class="ruby-value">99</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Fred</span>.<span class="ruby-identifier">class_variable_defined?</span>(:<span class="ruby-identifier">@@foo</span>)    <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">Fred</span>.<span class="ruby-identifier">class_variable_defined?</span>(:<span class="ruby-identifier">@@bar</span>)    <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="class_variable_defined-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_cvar_defined(obj, iv)
    VALUE obj, iv;
{
    ID id = rb_to_id(iv);

    if (!rb_is_class_id(id)) {
        rb_name_error(id, &quot;`%s' is not allowed as a class variable name&quot;, rb_id2name(id));
    }
    return rb_cvar_defined(obj, id);
}
            </pre> 
            </div><!-- class_variable_defined-3F-source -->
            
          </div>

          

          
        </div><!-- class_variable_defined-3F-method -->
      
        <div id="class_variables-method" class="method-detail ">
          <a name="method-i-class_variables"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">class_variables   => array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of the names of class variables in <em>mod</em> and the
ancestors of <em>mod</em>.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">One</span>
  <span class="ruby-identifier">@@var1</span> = <span class="ruby-value">1</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">Two</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">One</span>
  <span class="ruby-identifier">@@var2</span> = <span class="ruby-value">2</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">One</span>.<span class="ruby-identifier">class_variables</span>   <span class="ruby-comment">#=&gt; [&quot;@@var1&quot;]</span>
<span class="ruby-constant">Two</span>.<span class="ruby-identifier">class_variables</span>   <span class="ruby-comment">#=&gt; [&quot;@@var2&quot;, &quot;@@var1&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="class_variables-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_class_variables(obj)
    VALUE obj;
{
    VALUE ary = rb_ary_new();

    for (;;) {
	if (RCLASS(obj)-&gt;iv_tbl) {
	    st_foreach_safe(RCLASS(obj)-&gt;iv_tbl, cv_i, ary);
	}
	obj = RCLASS(obj)-&gt;super;
	if (!obj) break;
    }
    return ary;
}
            </pre> 
            </div><!-- class_variables-source -->
            
          </div>

          

          
        </div><!-- class_variables-method -->
      
        <div id="const_defined-3F-method" class="method-detail ">
          <a name="method-i-const_defined-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">const_defined?(sym)   => true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if a constant with the given name is defined by
<em>mod</em>.</p>

<pre class="ruby"><span class="ruby-constant">Math</span>.<span class="ruby-identifier">const_defined?</span> <span class="ruby-string">&quot;PI&quot;</span>   <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="const_defined-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_const_defined(mod, name)
    VALUE mod, name;
{
    ID id = rb_to_id(name);

    if (!rb_is_const_id(id)) {
        rb_name_error(id, &quot;wrong constant name %s&quot;, rb_id2name(id));
    }
    return rb_const_defined_at(mod, id);
}
            </pre> 
            </div><!-- const_defined-3F-source -->
            
          </div>

          

          
        </div><!-- const_defined-3F-method -->
      
        <div id="const_get-method" class="method-detail ">
          <a name="method-i-const_get"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">const_get(sym)    => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the value of the named constant in <em>mod</em>.</p>

<pre class="ruby"><span class="ruby-constant">Math</span>.<span class="ruby-identifier">const_get</span>(:<span class="ruby-constant">PI</span>)   <span class="ruby-comment">#=&gt; 3.14159265358979</span>
</pre>
            

            
            <div class="method-source-code" id="const_get-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_const_get(mod, name)
    VALUE mod, name;
{
    ID id = rb_to_id(name);

    if (!rb_is_const_id(id)) {
        rb_name_error(id, &quot;wrong constant name %s&quot;, rb_id2name(id));
    }
    return rb_const_get(mod, id);
}
            </pre> 
            </div><!-- const_get-source -->
            
          </div>

          

          
        </div><!-- const_get-method -->
      
        <div id="const_missing-method" class="method-detail ">
          <a name="method-i-const_missing"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">const_missing(sym)    => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invoked when a reference is made to an undefined constant in <em>mod</em>.
It is passed a symbol for the undefined constant, and returns a value to be
used for that constant. The following code is a (very bad) example: if
reference is made to an undefined constant, it attempts to load a file
whose name is the lowercase version of the constant (thus class
<code>Fred</code> is assumed to be in file <code>fred.rb</code>). If found,
it returns the value of the loaded class. It therefore implements a
perverse kind of autoload facility.</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-constant">Object</span>.<span class="ruby-identifier">const_missing</span>(<span class="ruby-identifier">name</span>)
  <span class="ruby-ivar">@looked_for</span> <span class="ruby-operator">||=</span> {}
  <span class="ruby-identifier">str_name</span> = <span class="ruby-identifier">name</span>.<span class="ruby-identifier">to_s</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Class not found: #{name}&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@looked_for</span>[<span class="ruby-identifier">str_name</span>]
  <span class="ruby-ivar">@looked_for</span>[<span class="ruby-identifier">str_name</span>] = <span class="ruby-value">1</span>
  <span class="ruby-identifier">file</span> = <span class="ruby-identifier">str_name</span>.<span class="ruby-identifier">downcase</span>
  <span class="ruby-identifier">require</span> <span class="ruby-identifier">file</span>
  <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">const_get</span>(<span class="ruby-identifier">name</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">klass</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">klass</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Class not found: #{name}&quot;</span>
<span class="ruby-keyword">end</span>
</pre>
            

            
            <div class="method-source-code" id="const_missing-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_const_missing(klass, name)
    VALUE klass, name;
{
    ruby_frame = ruby_frame-&gt;prev; /* pop frame for &quot;const_missing&quot; */
    uninitialized_constant(klass, rb_to_id(name));
    return Qnil;		/* not reached */
}
            </pre> 
            </div><!-- const_missing-source -->
            
          </div>

          

          
        </div><!-- const_missing-method -->
      
        <div id="const_set-method" class="method-detail ">
          <a name="method-i-const_set"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">const_set(sym, obj)    => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the named constant to the given object, returning that object. Creates
a new constant if no constant with the given name previously existed.</p>

<pre class="ruby"><span class="ruby-constant">Math</span>.<span class="ruby-identifier">const_set</span>(<span class="ruby-string">&quot;HIGH_SCHOOL_PI&quot;</span>, <span class="ruby-value">22.0</span><span class="ruby-operator">/</span><span class="ruby-value">7.0</span>)   <span class="ruby-comment">#=&gt; 3.14285714285714</span>
<span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-constant">HIGH_SCHOOL_PI</span> <span class="ruby-operator">-</span> <span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-constant">PI</span>              <span class="ruby-comment">#=&gt; 0.00126448926734968</span>
</pre>
            

            
            <div class="method-source-code" id="const_set-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_const_set(mod, name, value)
    VALUE mod, name, value;
{
    ID id = rb_to_id(name);

    if (!rb_is_const_id(id)) {
        rb_name_error(id, &quot;wrong constant name %s&quot;, rb_id2name(id));
    }
    rb_const_set(mod, id, value);
    return value;
}
            </pre> 
            </div><!-- const_set-source -->
            
          </div>

          

          
        </div><!-- const_set-method -->
      
        <div id="constants-method" class="method-detail ">
          <a name="method-i-constants"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">constants    => array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of the names of the constants accessible in <em>mod</em>.
This includes the names of constants in any included modules (example at
start of section).</p>
            

            
            <div class="method-source-code" id="constants-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_constants(mod)
    VALUE mod;
{
    return rb_const_list(rb_mod_const_of(mod, 0));
}
            </pre> 
            </div><!-- constants-source -->
            
          </div>

          

          
        </div><!-- constants-method -->
      
        <div id="freeze-method" class="method-detail ">
          <a name="method-i-freeze"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">freeze</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Prevents further modifications to <em>mod</em>.</p>
            

            
            <div class="method-source-code" id="freeze-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_freeze(mod)
    VALUE mod;
{
    rb_mod_to_s(mod);
    return rb_obj_freeze(mod);
}
            </pre> 
            </div><!-- freeze-source -->
            
          </div>

          

          
        </div><!-- freeze-method -->
      
        <div id="include-3F-method" class="method-detail ">
          <a name="method-i-include-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">include?(module)    => true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <em>module</em> is included in <em>mod</em> or
one of <em>mod</em>’s ancestors.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">A</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">B</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">A</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">C</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">B</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">B</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-constant">A</span>)   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-constant">A</span>)   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">A</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-constant">A</span>)   <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="include-3F-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_include_p(mod, mod2)
    VALUE mod;
    VALUE mod2;
{
    VALUE p;

    Check_Type(mod2, T_MODULE);
    for (p = RCLASS(mod)-&gt;super; p; p = RCLASS(p)-&gt;super) {
	if (BUILTIN_TYPE(p) == T_ICLASS) {
	    if (RBASIC(p)-&gt;klass == mod2) return Qtrue;
	}
    }
    return Qfalse;
}
            </pre> 
            </div><!-- include-3F-source -->
            
          </div>

          

          
        </div><!-- include-3F-method -->
      
        <div id="included_modules-method" class="method-detail ">
          <a name="method-i-included_modules"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">included_modules &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the list of modules included in <em>mod</em>.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Mixin</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">module</span> <span class="ruby-constant">Outer</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Mixin</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">Mixin</span>.<span class="ruby-identifier">included_modules</span>   <span class="ruby-comment">#=&gt; []</span>
<span class="ruby-constant">Outer</span>.<span class="ruby-identifier">included_modules</span>   <span class="ruby-comment">#=&gt; [Mixin]</span>
</pre>
            

            
            <div class="method-source-code" id="included_modules-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_included_modules(mod)
    VALUE mod;
{
    VALUE ary = rb_ary_new();
    VALUE p;

    for (p = RCLASS(mod)-&gt;super; p; p = RCLASS(p)-&gt;super) {
	if (BUILTIN_TYPE(p) == T_ICLASS) {
	    rb_ary_push(ary, RBASIC(p)-&gt;klass);
	}
    }
    return ary;
}
            </pre> 
            </div><!-- included_modules-source -->
            
          </div>

          

          
        </div><!-- included_modules-method -->
      
        <div id="instance_method-method" class="method-detail ">
          <a name="method-i-instance_method"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">instance_method(symbol)   => unbound_method</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an <code>UnboundMethod</code> representing the given instance
method in <em>mod</em>.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Interpreter</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">do_a</span>() <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;there, &quot;</span>; <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">do_d</span>() <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;Hello &quot;</span>;  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">do_e</span>() <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;!\n&quot;</span>;     <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">do_v</span>() <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;Dave&quot;</span>;    <span class="ruby-keyword">end</span>
  <span class="ruby-constant">Dispatcher</span> = {
   <span class="ruby-value">?a</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">instance_method</span>(:<span class="ruby-identifier">do_a</span>),
   <span class="ruby-value">?d</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">instance_method</span>(:<span class="ruby-identifier">do_d</span>),
   <span class="ruby-value">?e</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">instance_method</span>(:<span class="ruby-identifier">do_e</span>),
   <span class="ruby-value">?v</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">instance_method</span>(:<span class="ruby-identifier">do_v</span>)
  }
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">interpret</span>(<span class="ruby-identifier">string</span>)
    <span class="ruby-identifier">string</span>.<span class="ruby-identifier">each_byte</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-constant">Dispatcher</span>[<span class="ruby-identifier">b</span>].<span class="ruby-identifier">bind</span>(<span class="ruby-keyword">self</span>).<span class="ruby-identifier">call</span> }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">interpreter</span> = <span class="ruby-constant">Interpreter</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">interpreter</span>.<span class="ruby-identifier">interpret</span>(<span class="ruby-string">'dave'</span>)
</pre>

<p><em>produces:</em></p>

<pre>Hello there, Dave!</pre>
            

            
            <div class="method-source-code" id="instance_method-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_method(mod, vid)
    VALUE mod;
    VALUE vid;
{
    return mnew(mod, Qundef, rb_to_id(vid), rb_cUnboundMethod);
}
            </pre> 
            </div><!-- instance_method-source -->
            
          </div>

          

          
        </div><!-- instance_method-method -->
      
        <div id="instance_methods-method" class="method-detail ">
          <a name="method-i-instance_methods"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">instance_methods(include_super=true)   => array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array containing the names of public instance methods in the
receiver. For a module, these are the public methods; for a class, they are
the instance (not singleton) methods. With no argument, or with an argument
that is <code>false</code>, the instance methods in <em>mod</em> are
returned, otherwise the methods in <em>mod</em> and <em>mod</em>’s
superclasses are returned.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method1</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">B</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method2</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">C</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">B</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method3</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">A</span>.<span class="ruby-identifier">instance_methods</span>                <span class="ruby-comment">#=&gt; [&quot;method1&quot;]</span>
<span class="ruby-constant">B</span>.<span class="ruby-identifier">instance_methods</span>(<span class="ruby-keyword">false</span>)         <span class="ruby-comment">#=&gt; [&quot;method2&quot;]</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">instance_methods</span>(<span class="ruby-keyword">false</span>)         <span class="ruby-comment">#=&gt; [&quot;method3&quot;]</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">instance_methods</span>(<span class="ruby-keyword">true</span>).<span class="ruby-identifier">length</span>   <span class="ruby-comment">#=&gt; 43</span>
</pre>
            

            
            <div class="method-source-code" id="instance_methods-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_class_instance_methods(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    return class_instance_method_list(argc, argv, mod, ins_methods_i);
}
            </pre> 
            </div><!-- instance_methods-source -->
            
          </div>

          

          
        </div><!-- instance_methods-method -->
      
        <div id="method_defined-3F-method" class="method-detail ">
          <a name="method-i-method_defined-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">method_defined?(symbol)    => true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if the named method is defined by <em>mod</em>
(or its included modules and, if <em>mod</em> is a class, its ancestors).
Public and protected methods are matched.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method1</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">B</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method2</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">C</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">B</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method3</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">A</span>.<span class="ruby-identifier">method_defined?</span> :<span class="ruby-identifier">method1</span>    <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">method_defined?</span> <span class="ruby-string">&quot;method1&quot;</span>   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">method_defined?</span> <span class="ruby-string">&quot;method2&quot;</span>   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">method_defined?</span> <span class="ruby-string">&quot;method3&quot;</span>   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">method_defined?</span> <span class="ruby-string">&quot;method4&quot;</span>   <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="method_defined-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_method_defined(mod, mid)
    VALUE mod, mid;
{
    return rb_method_boundp(mod, rb_to_id(mid), 1);
}
            </pre> 
            </div><!-- method_defined-3F-source -->
            
          </div>

          

          
        </div><!-- method_defined-3F-method -->
      
        <div id="module_eval-method" class="method-detail ">
          <a name="method-i-module_eval"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">module_eval {|| block }                     => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Evaluates the string or block in the context of <em>mod</em>. This can be
used to add methods to a class. <code>module_eval</code> returns the result
of evaluating its argument. The optional <em>filename</em> and
<em>lineno</em> parameters set the text for error messages.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Thing</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">a</span> = <span class="ruby-string">%q{def hello() &quot;Hello there!&quot; end}</span>
<span class="ruby-constant">Thing</span>.<span class="ruby-identifier">module_eval</span>(<span class="ruby-identifier">a</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-constant">Thing</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">hello</span>()
<span class="ruby-constant">Thing</span>.<span class="ruby-identifier">module_eval</span>(<span class="ruby-string">&quot;invalid code&quot;</span>, <span class="ruby-string">&quot;dummy&quot;</span>, <span class="ruby-value">123</span>)
</pre>

<p><em>produces:</em></p>

<pre>Hello there!
dummy:123:in `module_eval': undefined local variable
    or method `code' for Thing:Class</pre>
            

            
            <div class="method-source-code" id="module_eval-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_module_eval(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    return specific_eval(argc, argv, mod, mod);
}
            </pre> 
            </div><!-- module_eval-source -->
            
          </div>

          

          
        </div><!-- module_eval-method -->
      
        <div id="module_exec-method" class="method-detail ">
          <a name="method-i-module_exec"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">module_exec(arg...) {|var...| block }       => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Evaluates the given block in the context of the class/module. The method
defined in the block will belong to the receiver.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Thing</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Thing</span>.<span class="ruby-identifier">class_exec</span>{
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">hello</span>() <span class="ruby-string">&quot;Hello there!&quot;</span> <span class="ruby-keyword">end</span>
}
<span class="ruby-identifier">puts</span> <span class="ruby-constant">Thing</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">hello</span>()
</pre>

<p><em>produces:</em></p>

<pre>Hello there!</pre>
            

            
            <div class="method-source-code" id="module_exec-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_module_exec(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    return yield_under(mod, mod, rb_ary_new4(argc, argv));
}
            </pre> 
            </div><!-- module_exec-source -->
            
          </div>

          

          
        </div><!-- module_exec-method -->
      
        <div id="name-method" class="method-detail ">
          <a name="method-i-name"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">name    => string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the name of the module <em>mod</em>.</p>
            

            
            <div class="method-source-code" id="name-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_name(mod)
    VALUE mod;
{
    VALUE path = classname(mod);

    if (!NIL_P(path)) return rb_str_dup(path);
    return rb_str_new(0,0);
}
            </pre> 
            </div><!-- name-source -->
            
          </div>

          

          
        </div><!-- name-method -->
      
        <div id="private_class_method-method" class="method-detail ">
          <a name="method-i-private_class_method"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">private_class_method(symbol, ...)   => mod</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Makes existing class methods private. Often used to hide the default
constructor <code>new</code>.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">SimpleSingleton</span>  <span class="ruby-comment"># Not thread safe</span>
  <span class="ruby-identifier">private_class_method</span> :<span class="ruby-identifier">new</span>
  <span class="ruby-keyword">def</span> <span class="ruby-constant">SimpleSingleton</span>.<span class="ruby-identifier">create</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
    <span class="ruby-ivar">@me</span> = <span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>) <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span> <span class="ruby-ivar">@me</span>
    <span class="ruby-ivar">@me</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>
            

            
            <div class="method-source-code" id="private_class_method-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_private_method(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    set_method_visibility(CLASS_OF(obj), argc, argv, NOEX_PRIVATE);
    return obj;
}
            </pre> 
            </div><!-- private_class_method-source -->
            
          </div>

          

          
        </div><!-- private_class_method-method -->
      
        <div id="private_instance_methods-method" class="method-detail ">
          <a name="method-i-private_instance_methods"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">private_instance_methods(include_super=true)    => array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a list of the private instance methods defined in <em>mod</em>. If
the optional parameter is not <code>false</code>, the methods of any
ancestors are included.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Mod</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method1</span>()  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">private</span> :<span class="ruby-identifier">method1</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method2</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Mod</span>.<span class="ruby-identifier">instance_methods</span>           <span class="ruby-comment">#=&gt; [&quot;method2&quot;]</span>
<span class="ruby-constant">Mod</span>.<span class="ruby-identifier">private_instance_methods</span>   <span class="ruby-comment">#=&gt; [&quot;method1&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="private_instance_methods-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_class_private_instance_methods(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    return class_instance_method_list(argc, argv, mod, ins_methods_priv_i);
}
            </pre> 
            </div><!-- private_instance_methods-source -->
            
          </div>

          

          
        </div><!-- private_instance_methods-method -->
      
        <div id="private_method_defined-3F-method" class="method-detail ">
          <a name="method-i-private_method_defined-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">private_method_defined?(symbol)    => true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if the named private method is defined by _ mod_
(or its included modules and, if <em>mod</em> is a class, its ancestors).</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method1</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">B</span>
  <span class="ruby-identifier">private</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method2</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">C</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">B</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method3</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">A</span>.<span class="ruby-identifier">method_defined?</span> :<span class="ruby-identifier">method1</span>            <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">private_method_defined?</span> <span class="ruby-string">&quot;method1&quot;</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">private_method_defined?</span> <span class="ruby-string">&quot;method2&quot;</span>   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">method_defined?</span> <span class="ruby-string">&quot;method2&quot;</span>           <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="private_method_defined-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_private_method_defined(mod, mid)
    VALUE mod, mid;
{
    ID id = rb_to_id(mid);
    int noex;

    if (rb_get_method_body(&amp;mod, &amp;id, &amp;noex)) {
        if (VISI_CHECK(noex, NOEX_PRIVATE))
            return Qtrue;
    }
    return Qfalse;
}
            </pre> 
            </div><!-- private_method_defined-3F-source -->
            
          </div>

          

          
        </div><!-- private_method_defined-3F-method -->
      
        <div id="protected_instance_methods-method" class="method-detail ">
          <a name="method-i-protected_instance_methods"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">protected_instance_methods(include_super=true)   => array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a list of the protected instance methods defined in <em>mod</em>.
If the optional parameter is not <code>false</code>, the methods of any
ancestors are included.</p>
            

            
            <div class="method-source-code" id="protected_instance_methods-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_class_protected_instance_methods(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    return class_instance_method_list(argc, argv, mod, ins_methods_prot_i);
}
            </pre> 
            </div><!-- protected_instance_methods-source -->
            
          </div>

          

          
        </div><!-- protected_instance_methods-method -->
      
        <div id="protected_method_defined-3F-method" class="method-detail ">
          <a name="method-i-protected_method_defined-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">protected_method_defined?(symbol)   => true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if the named protected method is defined by
<em>mod</em> (or its included modules and, if <em>mod</em> is a class, its
ancestors).</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method1</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">B</span>
  <span class="ruby-identifier">protected</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method2</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">C</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">B</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method3</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">A</span>.<span class="ruby-identifier">method_defined?</span> :<span class="ruby-identifier">method1</span>              <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">protected_method_defined?</span> <span class="ruby-string">&quot;method1&quot;</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">protected_method_defined?</span> <span class="ruby-string">&quot;method2&quot;</span>   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">method_defined?</span> <span class="ruby-string">&quot;method2&quot;</span>             <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="protected_method_defined-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_protected_method_defined(mod, mid)
    VALUE mod, mid;
{
    ID id = rb_to_id(mid);
    int noex;

    if (rb_get_method_body(&amp;mod, &amp;id, &amp;noex)) {
        if (VISI_CHECK(noex, NOEX_PROTECTED))
            return Qtrue;
    }
    return Qfalse;
}
            </pre> 
            </div><!-- protected_method_defined-3F-source -->
            
          </div>

          

          
        </div><!-- protected_method_defined-3F-method -->
      
        <div id="public_class_method-method" class="method-detail ">
          <a name="method-i-public_class_method"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">public_class_method(symbol, ...)    => mod</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Makes a list of existing class methods public.</p>
            

            
            <div class="method-source-code" id="public_class_method-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_public_method(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    set_method_visibility(CLASS_OF(obj), argc, argv, NOEX_PUBLIC);
    return obj;
}
            </pre> 
            </div><!-- public_class_method-source -->
            
          </div>

          

          
        </div><!-- public_class_method-method -->
      
        <div id="public_instance_methods-method" class="method-detail ">
          <a name="method-i-public_instance_methods"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">public_instance_methods(include_super=true)   => array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a list of the public instance methods defined in <em>mod</em>. If
the optional parameter is not <code>false</code>, the methods of any
ancestors are included.</p>
            

            
            <div class="method-source-code" id="public_instance_methods-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_class_public_instance_methods(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    return class_instance_method_list(argc, argv, mod, ins_methods_pub_i);
}
            </pre> 
            </div><!-- public_instance_methods-source -->
            
          </div>

          

          
        </div><!-- public_instance_methods-method -->
      
        <div id="public_method_defined-3F-method" class="method-detail ">
          <a name="method-i-public_method_defined-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">public_method_defined?(symbol)   => true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if the named public method is defined by
<em>mod</em> (or its included modules and, if <em>mod</em> is a class, its
ancestors).</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method1</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">B</span>
  <span class="ruby-identifier">protected</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method2</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">C</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">B</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">method3</span>()  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">A</span>.<span class="ruby-identifier">method_defined?</span> :<span class="ruby-identifier">method1</span>           <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">public_method_defined?</span> <span class="ruby-string">&quot;method1&quot;</span>   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">public_method_defined?</span> <span class="ruby-string">&quot;method2&quot;</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">method_defined?</span> <span class="ruby-string">&quot;method2&quot;</span>          <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="public_method_defined-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_public_method_defined(mod, mid)
    VALUE mod, mid;
{
    ID id = rb_to_id(mid);
    int noex;

    if (rb_get_method_body(&amp;mod, &amp;id, &amp;noex)) {
        if (VISI_CHECK(noex, NOEX_PUBLIC))
            return Qtrue;
    }
    return Qfalse;
}
            </pre> 
            </div><!-- public_method_defined-3F-source -->
            
          </div>

          

          
        </div><!-- public_method_defined-3F-method -->
      
        <div id="to_s-method" class="method-detail ">
          <a name="method-i-to_s"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_s   => string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Return a string representing this module or class. For basic classes and
modules, this is the name. For singletons, we show information on the thing
we’re attached to as well.</p>
            

            
            <div class="method-source-code" id="to_s-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_to_s(klass)
    VALUE klass;

{
    if (FL_TEST(klass, FL_SINGLETON)) {
        VALUE s = rb_str_new2(&quot;#&lt;&quot;);
        VALUE v = rb_iv_get(klass, &quot;__attached__&quot;);

        rb_str_cat2(s, &quot;Class:&quot;);
        switch (TYPE(v)) {
          case T_CLASS: case T_MODULE:
            rb_str_append(s, rb_inspect(v));
            break;
          default:
            rb_str_append(s, rb_any_to_s(v));
            break;
        }
        rb_str_cat2(s, &quot;&gt;&quot;);

        return s;
    }
    return rb_str_dup(rb_class_name(klass));
}
            </pre> 
            </div><!-- to_s-source -->
            
          </div>

          

          
        </div><!-- to_s-method -->
      
      </div><!-- public-instance-method-details -->
    
      <div id="private-instance-method-details" class="method-section section">
        <h3 class="section-header">Private Instance Methods</h3>

      
        <div id="alias_method-method" class="method-detail ">
          <a name="method-i-alias_method"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">alias_method(new_name, old_name)   => self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Makes <em>new_name</em> a new copy of the method <em>old_name</em>. This
can be used to retain access to methods that are overridden.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Mod</span>
  <span class="ruby-identifier">alias_method</span> :<span class="ruby-identifier">orig_exit</span>, :<span class="ruby-identifier">exit</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">exit</span>(<span class="ruby-identifier">code</span>=<span class="ruby-value">0</span>)
    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Exiting with code #{code}&quot;</span>
    <span class="ruby-identifier">orig_exit</span>(<span class="ruby-identifier">code</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">include</span> <span class="ruby-constant">Mod</span>
<span class="ruby-identifier">exit</span>(<span class="ruby-value">99</span>)
</pre>

<p><em>produces:</em></p>

<pre>Exiting with code 99</pre>
            

            
            <div class="method-source-code" id="alias_method-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_alias_method(mod, newname, oldname)
    VALUE mod, newname, oldname;
{
    rb_alias(mod, rb_to_id(newname), rb_to_id(oldname));
    return mod;
}
            </pre> 
            </div><!-- alias_method-source -->
            
          </div>

          

          
        </div><!-- alias_method-method -->
      
        <div id="append_features-method" class="method-detail ">
          <a name="method-i-append_features"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">append_features(mod)   => mod</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>When this module is included in another, Ruby calls
<code>append_features</code> in this module, passing it the receiving
module in <em>mod</em>. Ruby’s default implementation is to add the
constants, methods, and module variables of this module to <em>mod</em> if
this module has not already been added to <em>mod</em> or one of its
ancestors. See also <code>Module#include</code>.</p>
            

            
            <div class="method-source-code" id="append_features-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_append_features(module, include)
    VALUE module, include;
{
    switch (TYPE(include)) {
      case T_CLASS:
      case T_MODULE:
        break;
      default:
        Check_Type(include, T_CLASS);
        break;
    }
    rb_include_module(include, module);

    return module;
}
            </pre> 
            </div><!-- append_features-source -->
            
          </div>

          

          
        </div><!-- append_features-method -->
      
        <div id="attr-method" class="method-detail ">
          <a name="method-i-attr"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">attr(symbol, writable=false)    => nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Defines a named attribute for this module, where the name is
<em>symbol.</em><code>id2name</code>, creating an instance variable
(<code>@name</code>) and a corresponding access method to read it. If the
optional <em>writable</em> argument is <code>true</code>, also creates a
method called <code>name=</code> to set the attribute.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Mod</span>
  <span class="ruby-identifier">attr</span>  :<span class="ruby-identifier">size</span>, <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span>
</pre>

<p><em>is equivalent to:</em></p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Mod</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">size</span>
    <span class="ruby-ivar">@size</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">size=</span>(<span class="ruby-identifier">val</span>)
    <span class="ruby-ivar">@size</span> = <span class="ruby-identifier">val</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>
            

            
            <div class="method-source-code" id="attr-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_attr(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE name, pub;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;name, &amp;pub);
    rb_attr(klass, rb_to_id(name), 1, RTEST(pub), Qtrue);
    return Qnil;
}
            </pre> 
            </div><!-- attr-source -->
            
          </div>

          

          
        </div><!-- attr-method -->
      
        <div id="attr_accessor-method" class="method-detail ">
          <a name="method-i-attr_accessor"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">attr_accessor(symbol, ...)    => nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Equivalent to calling “<code>attr</code><em>symbol</em><code>, true</code>”
on each <em>symbol</em> in turn.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Mod</span>
  <span class="ruby-identifier">attr_accessor</span>(:<span class="ruby-identifier">one</span>, :<span class="ruby-identifier">two</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Mod</span>.<span class="ruby-identifier">instance_methods</span>.<span class="ruby-identifier">sort</span>   <span class="ruby-comment">#=&gt; [&quot;one&quot;, &quot;one=&quot;, &quot;two&quot;, &quot;two=&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="attr_accessor-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_attr_accessor(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    int i;

    for (i=0; i&lt;argc; i++) {
        rb_attr(klass, rb_to_id(argv[i]), 1, 1, Qtrue);
    }
    return Qnil;
}
            </pre> 
            </div><!-- attr_accessor-source -->
            
          </div>

          

          
        </div><!-- attr_accessor-method -->
      
        <div id="attr_reader-method" class="method-detail ">
          <a name="method-i-attr_reader"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">attr_reader(symbol, ...)    => nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates instance variables and corresponding methods that return the value
of each instance variable. Equivalent to calling
“<code>attr</code><em>:name</em>” on each name in turn.</p>
            

            
            <div class="method-source-code" id="attr_reader-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_attr_reader(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    int i;

    for (i=0; i&lt;argc; i++) {
        rb_attr(klass, rb_to_id(argv[i]), 1, 0, Qtrue);
    }
    return Qnil;
}
            </pre> 
            </div><!-- attr_reader-source -->
            
          </div>

          

          
        </div><!-- attr_reader-method -->
      
        <div id="attr_writer-method" class="method-detail ">
          <a name="method-i-attr_writer"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">attr_writer(symbol, ...)    => nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates an accessor method to allow assignment to the attribute
<em>aSymbol</em><code>.id2name</code>.</p>
            

            
            <div class="method-source-code" id="attr_writer-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_attr_writer(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    int i;

    for (i=0; i&lt;argc; i++) {
        rb_attr(klass, rb_to_id(argv[i]), 0, 1, Qtrue);
    }
    return Qnil;
}
            </pre> 
            </div><!-- attr_writer-source -->
            
          </div>

          

          
        </div><!-- attr_writer-method -->
      
        <div id="class_variable_get-method" class="method-detail ">
          <a name="method-i-class_variable_get"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">class_variable_get(symbol)    => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the value of the given class variable (or throws a
<code>NameError</code> exception). The <code>@@</code> part of the variable
name should be included for regular class variables</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Fred</span>
  <span class="ruby-identifier">@@foo</span> = <span class="ruby-value">99</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">def</span> <span class="ruby-constant">Fred</span>.<span class="ruby-identifier">foo</span>
  <span class="ruby-identifier">class_variable_get</span>(:<span class="ruby-identifier">@@foo</span>)     <span class="ruby-comment">#=&gt; 99</span>
<span class="ruby-keyword">end</span>
</pre>
            

            
            <div class="method-source-code" id="class_variable_get-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_cvar_get(obj, iv)
    VALUE obj, iv;
{
    ID id = rb_to_id(iv);

    if (!rb_is_class_id(id)) {
        rb_name_error(id, &quot;`%s' is not allowed as a class variable name&quot;, rb_id2name(id));
    }
    return rb_cvar_get(obj, id);
}
            </pre> 
            </div><!-- class_variable_get-source -->
            
          </div>

          

          
        </div><!-- class_variable_get-method -->
      
        <div id="class_variable_set-method" class="method-detail ">
          <a name="method-i-class_variable_set"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">class_variable_set(symbol, obj)    => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the class variable names by <em>symbol</em> to <em>object</em>.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Fred</span>
  <span class="ruby-identifier">@@foo</span> = <span class="ruby-value">99</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">foo</span>
    <span class="ruby-identifier">@@foo</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">def</span> <span class="ruby-constant">Fred</span>.<span class="ruby-identifier">foo</span>
  <span class="ruby-identifier">class_variable_set</span>(:<span class="ruby-identifier">@@foo</span>, <span class="ruby-value">101</span>)      <span class="ruby-comment">#=&gt; 101</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Fred</span>.<span class="ruby-identifier">foo</span>
<span class="ruby-constant">Fred</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">foo</span>                             <span class="ruby-comment">#=&gt; 101</span>
</pre>
            

            
            <div class="method-source-code" id="class_variable_set-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_cvar_set(obj, iv, val)
    VALUE obj, iv, val;
{
    ID id = rb_to_id(iv);

    if (!rb_is_class_id(id)) {
        rb_name_error(id, &quot;`%s' is not allowed as a class variable name&quot;, rb_id2name(id));
    }
    rb_cvar_set(obj, id, val, Qfalse);
    return val;
}
            </pre> 
            </div><!-- class_variable_set-source -->
            
          </div>

          

          
        </div><!-- class_variable_set-method -->
      
        <div id="define_method-method" class="method-detail ">
          <a name="method-i-define_method"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">define_method(symbol, method)     => new_method</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">define_method(symbol) { block }   => proc</span>
            
          </div>
          
          
          <div>
  
            
            <p>Defines an instance method in the receiver. The <em>method</em> parameter
can be a <code>Proc</code> or <code>Method</code> object. If a block is
specified, it is used as the method body. This block is evaluated using
<code>instance_eval</code>, a point that is tricky to demonstrate because
<code>define_method</code> is private. (This is why we resort to the
<code>send</code> hack in this example.)</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">fred</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;In Fred&quot;</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">create_method</span>(<span class="ruby-identifier">name</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">send</span>(:<span class="ruby-identifier">define_method</span>, <span class="ruby-identifier">name</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">define_method</span>(:<span class="ruby-identifier">wilma</span>) { <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Charge it!&quot;</span> }
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">B</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">A</span>
  <span class="ruby-identifier">define_method</span>(:<span class="ruby-identifier">barney</span>, <span class="ruby-identifier">instance_method</span>(:<span class="ruby-identifier">fred</span>))
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">a</span> = <span class="ruby-constant">B</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">barney</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">wilma</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">create_method</span>(:<span class="ruby-identifier">betty</span>) { <span class="ruby-identifier">p</span> <span class="ruby-keyword">self</span> }
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">betty</span>
</pre>

<p><em>produces:</em></p>

<pre>In Fred
Charge it!
#&lt;B:0x401b39e8&gt;</pre>
            

            
            <div class="method-source-code" id="define_method-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_define_method(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    ID id;
    VALUE body, orig;
    NODE *node;
    int noex;

    if (argc == 1) {
        id = rb_to_id(argv[0]);
        body = proc_lambda();
    }
    else if (argc == 2) {
        id = rb_to_id(argv[0]);
        body = argv[1];
        if (!rb_obj_is_method(body) &amp;&amp; !rb_obj_is_proc(body)) {
            rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected Proc/Method)&quot;,
                     rb_obj_classname(body));
        }
    }
    else {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 1)&quot;, argc);
    }
    orig = body;
    if (RDATA(body)-&gt;dmark == (RUBY_DATA_FUNC)bm_mark) {
        node = NEW_DMETHOD(method_unbind(body));
    }
    else if (RDATA(body)-&gt;dmark == (RUBY_DATA_FUNC)blk_mark) {
        struct BLOCK *block;

        body = proc_clone(body);
        Data_Get_Struct(body, struct BLOCK, block);
        block-&gt;frame.last_func = id;
        block-&gt;frame.orig_func = id;
        block-&gt;frame.last_class = mod;
        node = NEW_BMETHOD(body);
    }
    else {
        /* type error */
        rb_raise(rb_eTypeError, &quot;wrong argument type (expected Proc/Method)&quot;);
    }

    noex = NOEX_PUBLIC;
    if (ruby_cbase == mod) {
        if (SCOPE_TEST(SCOPE_PRIVATE)) {
            noex = NOEX_PRIVATE;
        }
        else if (SCOPE_TEST(SCOPE_PROTECTED)) {
            noex = NOEX_PROTECTED;
        }
    }
    rb_add_method(mod, id, node, noex);
    return orig;
}
            </pre> 
            </div><!-- define_method-source -->
            
          </div>

          

          
        </div><!-- define_method-method -->
      
        <div id="extend_object-method" class="method-detail ">
          <a name="method-i-extend_object"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">extend_object(obj)    => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Extends the specified object by adding this module’s constants and methods
(which are added as singleton methods). This is the callback method used by
<code>Object#extend</code>.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Picky</span>
  <span class="ruby-keyword">def</span> <span class="ruby-constant">Picky</span>.<span class="ruby-identifier">extend_object</span>(<span class="ruby-identifier">o</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-constant">String</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">o</span>
      <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Can't add Picky to a String&quot;</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Picky added to #{o.class}&quot;</span>
      <span class="ruby-keyword">super</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
(<span class="ruby-identifier">s</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>).<span class="ruby-identifier">extend</span> <span class="ruby-constant">Picky</span>  <span class="ruby-comment"># Call Object.extend</span>
(<span class="ruby-identifier">s</span> = <span class="ruby-string">&quot;quick brown fox&quot;</span>).<span class="ruby-identifier">extend</span> <span class="ruby-constant">Picky</span>
</pre>

<p><em>produces:</em></p>

<pre>Picky added to Array
Can't add Picky to a String</pre>
            

            
            <div class="method-source-code" id="extend_object-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_extend_object(mod, obj)
    VALUE mod, obj;
{
    rb_extend_object(obj, mod);
    return obj;
}
            </pre> 
            </div><!-- extend_object-source -->
            
          </div>

          

          
        </div><!-- extend_object-method -->
      
        <div id="extended-method" class="method-detail ">
          <a name="method-i-extended"></a>

          
          <div class="method-heading">
            <span class="method-name">extended</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Not documented</p>
            

            
            <div class="method-source-code" id="extended-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_obj_dummy()
{
    return Qnil;
}
            </pre> 
            </div><!-- extended-source -->
            
          </div>

          

          
        </div><!-- extended-method -->
      
        <div id="include-method" class="method-detail ">
          <a name="method-i-include"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">include(module, ...)    => self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes <code>Module.append_features</code> on each parameter in turn.</p>
            

            
            <div class="method-source-code" id="include-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_include(argc, argv, module)
    int argc;
    VALUE *argv;
    VALUE module;
{
    int i;

    for (i=0; i&lt;argc; i++) Check_Type(argv[i], T_MODULE);
    while (argc--) {
        rb_funcall(argv[argc], rb_intern(&quot;append_features&quot;), 1, module);
        rb_funcall(argv[argc], rb_intern(&quot;included&quot;), 1, module);
    }
    return module;
}
            </pre> 
            </div><!-- include-source -->
            
          </div>

          

          
        </div><!-- include-method -->
      
        <div id="included-method" class="method-detail ">
          <a name="method-i-included"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">included( othermod )</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Callback invoked whenever the receiver is included in another module or
class. This should be used in preference to
<code>Module.append_features</code> if your code wants to perform some
action when a module is included in another.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-constant">A</span>.<span class="ruby-identifier">included</span>(<span class="ruby-identifier">mod</span>)
    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{self} included in #{mod}&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">module</span> <span class="ruby-constant">Enumerable</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">A</span>
<span class="ruby-keyword">end</span>
</pre>
            

            
            <div class="method-source-code" id="included-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_obj_dummy()
{
    return Qnil;
}
            </pre> 
            </div><!-- included-source -->
            
          </div>

          

          
        </div><!-- included-method -->
      
        <div id="method_added-method" class="method-detail ">
          <a name="method-i-method_added"></a>

          
          <div class="method-heading">
            <span class="method-name">method_added</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Not documented</p>
            

            
            <div class="method-source-code" id="method_added-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_obj_dummy()
{
    return Qnil;
}
            </pre> 
            </div><!-- method_added-source -->
            
          </div>

          

          
        </div><!-- method_added-method -->
      
        <div id="method_removed-method" class="method-detail ">
          <a name="method-i-method_removed"></a>

          
          <div class="method-heading">
            <span class="method-name">method_removed</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Not documented</p>
            

            
            <div class="method-source-code" id="method_removed-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_obj_dummy()
{
    return Qnil;
}
            </pre> 
            </div><!-- method_removed-source -->
            
          </div>

          

          
        </div><!-- method_removed-method -->
      
        <div id="method_undefined-method" class="method-detail ">
          <a name="method-i-method_undefined"></a>

          
          <div class="method-heading">
            <span class="method-name">method_undefined</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Not documented</p>
            

            
            <div class="method-source-code" id="method_undefined-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_obj_dummy()
{
    return Qnil;
}
            </pre> 
            </div><!-- method_undefined-source -->
            
          </div>

          

          
        </div><!-- method_undefined-method -->
      
        <div id="module_function-method" class="method-detail ">
          <a name="method-i-module_function"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">module_function(symbol, ...)    => self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates module functions for the named methods. These functions may be
called with the module as a receiver, and also become available as instance
methods to classes that mix in the module. <a href="Module.html">Module</a>
functions are copies of the original, and so may be changed independently.
The instance-method versions are made private. If used with no arguments,
subsequently defined methods become module functions.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Mod</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">one</span>
    <span class="ruby-string">&quot;This is one&quot;</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">module_function</span> :<span class="ruby-identifier">one</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">Cls</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Mod</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">callOne</span>
    <span class="ruby-identifier">one</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Mod</span>.<span class="ruby-identifier">one</span>     <span class="ruby-comment">#=&gt; &quot;This is one&quot;</span>
<span class="ruby-identifier">c</span> = <span class="ruby-constant">Cls</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">callOne</span>   <span class="ruby-comment">#=&gt; &quot;This is one&quot;</span>
<span class="ruby-keyword">module</span> <span class="ruby-constant">Mod</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">one</span>
    <span class="ruby-string">&quot;This is the new one&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Mod</span>.<span class="ruby-identifier">one</span>     <span class="ruby-comment">#=&gt; &quot;This is one&quot;</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">callOne</span>   <span class="ruby-comment">#=&gt; &quot;This is the new one&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="module_function-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_modfunc(argc, argv, module)
    int argc;
    VALUE *argv;
    VALUE module;
{
    int i;
    ID id;
    NODE *body;

    if (TYPE(module) != T_MODULE) {
        rb_raise(rb_eTypeError, &quot;module_function must be called for modules&quot;);
    }

    secure_visibility(module);
    if (argc == 0) {
        SCOPE_SET(SCOPE_MODFUNC);
        return module;
    }

    set_method_visibility(module, argc, argv, NOEX_PRIVATE);
    for (i=0; i&lt;argc; i++) {
        VALUE m = module;

        id = rb_to_id(argv[i]);
        for (;;) {
            body = search_method(m, id, &amp;m);
            if (body == 0) {
                body = search_method(rb_cObject, id, &amp;m);
            }
            if (body == 0 || body-&gt;nd_body == 0) {
                print_undef(module, id);
            }
            if (nd_type(body-&gt;nd_body) != NODE_ZSUPER) {
                break;                /* normal case: need not to follow 'super' link */
            }
            m = RCLASS(m)-&gt;super;
            if (!m) break;
        }
        rb_add_method(rb_singleton_class(module), id, body-&gt;nd_body, NOEX_PUBLIC);
    }
    return module;
}
            </pre> 
            </div><!-- module_function-source -->
            
          </div>

          

          
        </div><!-- module_function-method -->
      
        <div id="private-method" class="method-detail ">
          <a name="method-i-private"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">private                 => self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">private(symbol, ...)    => self</span>
            
          </div>
          
          
          <div>
  
            
            <p>With no arguments, sets the default visibility for subsequently defined
methods to private. With arguments, sets the named methods to have private
visibility.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Mod</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">a</span>()  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">b</span>()  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">private</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">c</span>()  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">private</span> :<span class="ruby-identifier">a</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Mod</span>.<span class="ruby-identifier">private_instance_methods</span>   <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;c&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="private-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_private(argc, argv, module)
    int argc;
    VALUE *argv;
    VALUE module;
{
    secure_visibility(module);
    if (argc == 0) {
        SCOPE_SET(SCOPE_PRIVATE);
    }
    else {
        set_method_visibility(module, argc, argv, NOEX_PRIVATE);
    }
    return module;
}
            </pre> 
            </div><!-- private-source -->
            
          </div>

          

          
        </div><!-- private-method -->
      
        <div id="protected-method" class="method-detail ">
          <a name="method-i-protected"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">protected                => self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">protected(symbol, ...)   => self</span>
            
          </div>
          
          
          <div>
  
            
            <p>With no arguments, sets the default visibility for subsequently defined
methods to protected. With arguments, sets the named methods to have
protected visibility.</p>
            

            
            <div class="method-source-code" id="protected-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_protected(argc, argv, module)
    int argc;
    VALUE *argv;
    VALUE module;
{
    secure_visibility(module);
    if (argc == 0) {
        SCOPE_SET(SCOPE_PROTECTED);
    }
    else {
        set_method_visibility(module, argc, argv, NOEX_PROTECTED);
    }
    return module;
}
            </pre> 
            </div><!-- protected-source -->
            
          </div>

          

          
        </div><!-- protected-method -->
      
        <div id="public-method" class="method-detail ">
          <a name="method-i-public"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">public                 => self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">public(symbol, ...)    => self</span>
            
          </div>
          
          
          <div>
  
            
            <p>With no arguments, sets the default visibility for subsequently defined
methods to public. With arguments, sets the named methods to have public
visibility.</p>
            

            
            <div class="method-source-code" id="public-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_public(argc, argv, module)
    int argc;
    VALUE *argv;
    VALUE module;
{
    secure_visibility(module);
    if (argc == 0) {
        SCOPE_SET(SCOPE_PUBLIC);
    }
    else {
        set_method_visibility(module, argc, argv, NOEX_PUBLIC);
    }
    return module;
}
            </pre> 
            </div><!-- public-source -->
            
          </div>

          

          
        </div><!-- public-method -->
      
        <div id="remove_class_variable-method" class="method-detail ">
          <a name="method-i-remove_class_variable"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">remove_class_variable(sym)    => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes the definition of the <em>sym</em>, returning that constant’s
value.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Dummy</span>
  <span class="ruby-identifier">@@var</span> = <span class="ruby-value">99</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-identifier">@@var</span>
  <span class="ruby-identifier">remove_class_variable</span>(:<span class="ruby-identifier">@@var</span>)
  <span class="ruby-identifier">puts</span>(<span class="ruby-keyword">defined?</span> <span class="ruby-identifier">@@var</span>)
<span class="ruby-keyword">end</span>
</pre>

<p><em>produces:</em></p>

<pre>99
nil</pre>
            

            
            <div class="method-source-code" id="remove_class_variable-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_remove_cvar(mod, name)
    VALUE mod, name;
{
    ID id = rb_to_id(name);
    VALUE val;

    if (!rb_is_class_id(id)) {
	rb_name_error(id, &quot;wrong class variable name %s&quot;, rb_id2name(id));
    }
    if (!OBJ_TAINTED(mod) &amp;&amp; rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: can't remove class variable&quot;);
    if (OBJ_FROZEN(mod)) rb_error_frozen(&quot;class/module&quot;);

    if (RCLASS(mod)-&gt;iv_tbl &amp;&amp; st_delete(ROBJECT(mod)-&gt;iv_tbl, (st_data_t*)&amp;id, &amp;val)) {
	return val;
    }
    if (rb_cvar_defined(mod, id)) {
	rb_name_error(id, &quot;cannot remove %s for %s&quot;,
		 rb_id2name(id), rb_class2name(mod));
    }
    rb_name_error(id, &quot;class variable %s not defined for %s&quot;,
		  rb_id2name(id), rb_class2name(mod));
    return Qnil;		/* not reached */
}
            </pre> 
            </div><!-- remove_class_variable-source -->
            
          </div>

          

          
        </div><!-- remove_class_variable-method -->
      
        <div id="remove_const-method" class="method-detail ">
          <a name="method-i-remove_const"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">remove_const(sym)   => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes the definition of the given constant, returning that constant’s
value. Predefined classes and singleton objects (such as <em>true</em>)
cannot be removed.</p>
            

            
            <div class="method-source-code" id="remove_const-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_mod_remove_const(mod, name)
    VALUE mod, name;
{
    ID id = rb_to_id(name);
    VALUE val;

    if (!rb_is_const_id(id)) {
	rb_name_error(id, &quot;`%s' is not allowed as a constant name&quot;, rb_id2name(id));
    }
    if (!OBJ_TAINTED(mod) &amp;&amp; rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: can't remove constant&quot;);
    if (OBJ_FROZEN(mod)) rb_error_frozen(&quot;class/module&quot;);

    if (RCLASS(mod)-&gt;iv_tbl &amp;&amp; st_delete(ROBJECT(mod)-&gt;iv_tbl, (st_data_t*)&amp;id, &amp;val)) {
	if (val == Qundef) {
	    autoload_delete(mod, id);
	    val = Qnil;
	}
	return val;
    }
    if (rb_const_defined_at(mod, id)) {
	rb_name_error(id, &quot;cannot remove %s::%s&quot;,
		 rb_class2name(mod), rb_id2name(id));
    }
    rb_name_error(id, &quot;constant %s::%s not defined&quot;,
		  rb_class2name(mod), rb_id2name(id));
    return Qnil;		/* not reached */
}
            </pre> 
            </div><!-- remove_const-source -->
            
          </div>

          

          
        </div><!-- remove_const-method -->
      
        <div id="remove_method-method" class="method-detail ">
          <a name="method-i-remove_method"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">remove_method(symbol)   => self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes the method identified by <em>symbol</em> from the current class.
For an example, see <code>Module.undef_method</code>.</p>
            

            
            <div class="method-source-code" id="remove_method-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_remove_method(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    int i;

    for (i=0; i&lt;argc; i++) {
        remove_method(mod, rb_to_id(argv[i]));
    }
    return mod;
}
            </pre> 
            </div><!-- remove_method-source -->
            
          </div>

          

          
        </div><!-- remove_method-method -->
      
        <div id="undef_method-method" class="method-detail ">
          <a name="method-i-undef_method"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">undef_method(symbol)    => self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Prevents the current class from responding to calls to the named method.
Contrast this with <code>remove_method</code>, which deletes the method
from the particular class; Ruby will still search superclasses and mixed-in
modules for a possible receiver.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Parent</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">hello</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;In parent&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">Child</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Parent</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">hello</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;In child&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">c</span> = <span class="ruby-constant">Child</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">hello</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Child</span>
  <span class="ruby-identifier">remove_method</span> :<span class="ruby-identifier">hello</span>  <span class="ruby-comment"># remove from child, still in parent</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">hello</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Child</span>
  <span class="ruby-identifier">undef_method</span> :<span class="ruby-identifier">hello</span>   <span class="ruby-comment"># prevent any calls to 'hello'</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">hello</span>
</pre>

<p><em>produces:</em></p>

<pre>In child
In parent
prog.rb:23: undefined method `hello' for #&lt;Child:0x401b3bb4&gt; (NoMethodError)</pre>
            

            
            <div class="method-source-code" id="undef_method-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_mod_undef_method(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    int i;

    for (i=0; i&lt;argc; i++) {
        rb_undef(mod, rb_to_id(argv[i]));
    }
    return mod;
}
            </pre> 
            </div><!-- undef_method-source -->
            
          </div>

          

          
        </div><!-- undef_method-method -->
      
      </div><!-- private-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_Module_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Module_versioned").load("/associated/1.8.7/Module.html");</script> <div id='tx_Module' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Module").load("/associated/Module.html");</script> 
      
  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
      
<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 1.8.7</small></p> 
  
   <p> <a href="http://www.ruby-doc.org">Ruby-doc.org</a> is provided by <a href="http://www.jamesbritt.com">James Britt</a> and <a href="http://www.neurogami.com">Neurogami</a>. <a href="http://www.neurogami.com">Hack your world.  Feed your head.  Live curious</a>.  </p>
 
    <p><small>Generated with Ruby-doc Rdoc Generator 0.24.6</small>.</p>
  </div>
</div>
  
 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.html");
    });

    </script>


 
    <script type='text/javascript'>

  function loadPlus(plusdocs){
    var img_h = $("img.carbonad-image").css('height');
    //if(img_h != undefined) { //---
      $(plusdocs).find("div[class='associated_wrapper']").each (function() {
          $("#" + this.id).append($(plusdocs).find("#" + this.id ));
          });
    //} // ---
  } // end loadPlusdocs


$(document).ready(function() {
    $.ajaxSetup({ cache: false });
      $.get('/associated/1.8.7/plus_Module.html', 
      function(plusdocs) {
      setTimeout(function() {
        loadPlus(plusdocs);
        }, 2000);
      }
      );
    });
</script>
		
</body>
</html>


